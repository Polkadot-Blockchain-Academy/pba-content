<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Platform Agnostic Bytecode</title>
  <link rel="icon" href="./../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../dist/reset.css" />
  <link rel="stylesheet" href="./../../dist/reveal.css" />
  <link rel="stylesheet" href="./../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# Platform Agnostic Bytecode
</script></section><section  data-markdown><script type="text/template">
## Review of Compilers

<img src="./img/pab/compiling.png" />

ðŸ¤¯ Fun Side Reading: <!-- .element: class="fragment" data-fragment-index="1" -->
[Reflections on Trusting Trust](https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf) <!-- .element: class="fragment" data-fragment-index="1" -->

<aside class="notes"><p>Just a very quick reminder of how compilers work.
Humans write programs in some human readable language like Lauren talked about.
Then the compiler translates the semantics of that program into an equivalent program in a much lower more machine-readable language called a bytecode.</p>
<p>CLICK</p>
<p>Whenever I show this diagram or talk about compilers, I always like to mention one of my favorite essays ever.
Ken Thompson&#39;s 1984 Turing Award lecture.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Definition

A PAB is a bytecode that follows two main principles:

- Turing Completeness, as a standard bytecode would respect

<!-- .element: class="fragment" data-fragment-index="1" -->

- Support for tooling that makes it executable on every machine

<!-- .element: class="fragment" data-fragment-index="2" -->

<aside class="notes"><p>Ideally a bytecode like this is designed to be executed on a virtual machine that follows general known patterns.</p>
</aside></script></section><section ><section data-markdown><script type="text/template">
<pba-cols>
<pba-col left>

<pba-flex center>

###### High Level Languages

<img style="width: 30%" src="./img/pab/rust_logo.png" />

<img style="width: 30%" src="./img/pab/c_logo.png" />

<img style="width: 30%" src="./img/pab/c++_logo.png" />

</pba-flex>
</pba-col>
<!-- .element: class="fragment" data-fragment-index="1" -->

<pba-col center>
<pba-flex center>

###### PABs

<img style="width: 30%" src="./img/pab/jvm_logo.png" />
<img style="width: 30%" src="./img/pab/wasm_logo.png" />
<img style="width: 20%" src="./img/pab/eth_logo.png" />
<img style="width: 30%" src="./img/pab/risc-v_logo.png" />

</pba-flex>
</pba-col>
<!-- .element: class="fragment" data-fragment-index="2" -->

<pba-col right>
<pba-flex center>

###### Architecture's bytecode

<img style="width: 30%" src="./img/pab/intel_logo.png" />
<img style="width: 30%" src="./img/pab/arm_logo.png" />
<img style="width: 30%" src="./img/pab/risc-v_logo.png" />

</pba-flex>
</pba-col>
<!-- .element: class="fragment" data-fragment-index="3" -->

</pba-cols>

<aside class="notes"><p>From left to right you can see different levels of abstraction over the program that will ultimately be run on some machine.
Generally, from a high level language you need two compilation step if you want to pass through a PAB.</p>
<p>Other examples of PABs used right now:</p>
<ul>
<li>Inside the Linux Kernel -&gt; eBPF</li>
<li>Inside browsers -&gt; Wasm</li>
<li>Inside Blockchains -&gt; Wasm<ul>
<li>Full nodes</li>
<li>Light nodes (Wasm inside Wasm)</li>
</ul>
</li>
<li>LLVM Toolchain -&gt; LLVM IR</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Compiling in a PAB

<img src="./img/pab/compiling_twice.png" />

<aside class="notes"><p>So when we are using a PAB, we need to compile twice.
This is, of course, the cost to using a PAB.
In this lesson we&#39;ll also explore the advantages.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
#### What a PAB allows is:

<pba-flex center>

- Portability
  <!-- .element: class="fragment" data-fragment-index="1" -->
      - Avoid Hardware Centralization
  <!-- .element: class="fragment" data-fragment-index="3" -->
- Determinism
  <!-- .element: class="fragment" data-fragment-index="2" -->
      - Make consensus possible
  <!-- .element: class="fragment" data-fragment-index="4" -->

</pba-flex>

<aside class="notes"><p>The main goal of a PAB is to make the code <strong>portable</strong>, you should be able to compile it once and then share it around without caring about the architecture on which will be executed. Of course in a decentralized network we want that different nodes, with different architectures came up to the same result if the input are the same, that&#39;s called <strong>determinism</strong>, if a PAB would not have determinism then reaching consensus is impossible.</p>
</aside></script></section><section data-markdown><script type="text/template">
##### That's why PABs are so important
</script></section></section><section ><section data-markdown><script type="text/template">
## Desireable Features

- Hardware Independence
<!-- .element: class="fragment" data-fragment-index="1" -->
- Efficiency: minimize overhead vs. native
<!-- .element: class="fragment" data-fragment-index="2" -->
- Tool Simplicity
<!-- .element: class="fragment" data-fragment-index="3" -->
- Support as Compilation Target
<!-- .element: class="fragment" data-fragment-index="4" -->
- Sandboxing
<!-- .element: class="fragment" data-fragment-index="5" -->
- Deterministic execution
<!-- .element: class="fragment" data-fragment-index="5" -->

<aside class="notes"><ul>
<li>Hardware Independence: It should not be tightly related to a specific architecture, otherwise the execution on different machine could be convoluted</li>
<li>Efficiency: the execution and compilation of a PAB should be efficient, the problem for a PAB is that in the execution time is also considered the &quot;translation&quot; to the machine&#39;s bytecode or the interpretation</li>
<li>Support as Compilation Target: The PAB should be possible to be compiled by as many as possible High Level languages</li>
<li>Tool Simplicity: If the tools that makes the PAB executable are extremely complex then nobody will use it</li>
<li>Deterministic execution: Same execution (always) on any platform</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
### Sandboxing?

An environment for running untrusted code without affecting the host.

<!-- .element: class="fragment" data-fragment-index="1" -->

<img style="height: 300px" src="./img/pab/sandbox.jpg" />

A SmartContract is _Arbitrary Code_ that may be executed on other people's infrastructure, we don't want SmartContracts capable of destroying the nodes on which they are executed

<!-- .element: class="fragment" data-fragment-index="2" -->

<aside class="notes"><p>CLICK read definition</p>
<p>The term sandbox is an analogy to kids playing in a sandbox.
The parent puts the kid in the sandbox and tells them they can play in the sandbox and they are safe as long as they stay in.
Don&#39;t go in the woods and get bitten by a snake or in the road and get hit by a car.
Just stay in the sandbox.</p>
<p>Of course the analogy isn&#39;t perfect.
The children in the sandbox stay there because the parent asked them to.
They could leave anytime they wanted to.
For actual untrusted code, a better analogy would be a walled garden or a Jail</p>
</aside></script></section><section data-markdown><script type="text/template">
### Sandboxing?

<img src="./img/pab/jail.jpg" /> <!-- .element: class="fragment" data-fragment-index="1" -->

A sandboxed environment must be created by the executor of the PAB.

<!-- .element: class="fragment" data-fragment-index="2" -->

<aside class="notes"><p>Of course the security can be seen by various point of view and some examples are:</p>
<ul>
<li>Compilation takes too much time -&gt; &quot;compiler bomb&quot;</li>
<li>Access to the environment -&gt; &quot;buffer overflow&quot; techniques</li>
</ul>
<p>Those things can&#39;t be addressed by the PAB itself but they can give good guidelines and code design to make an 100% secure implementation of the executor possible.</p>
</aside></script></section></section><section  data-markdown><script type="text/template">
## PAB's lifecycle example

<div class="r-stack">
<img style="width: 70%" src="./img/pab/pab_path_1.svg" />
<img style="width: 70%" src="./img/pab/pab_path_2.svg"/>
<!-- .element: class="fragment" data-fragment-index="1" -->
<img style="width: 70%" src="./img/pab/pab_path_3.svg"/>
<!-- .element: class="fragment" data-fragment-index="2" -->
<img style="width: 70%" src="./img/pab/pab_path_4.svg"/>
<!-- .element: class="fragment" data-fragment-index="3" -->
<img style="width: 70%" src="./img/pab/pab_path_5.svg"/>
<!-- .element: class="fragment" data-fragment-index="4" -->
<img style="width: 70%" src="./img/pab/pab_path_6.svg"/>
<!-- .element: class="fragment" data-fragment-index="5" -->
</div>
</script></section><section  data-markdown><script type="text/template">
<pba-cols>
<pba-col center>

# WebAssembly

- Parachain validation function
- Contracts (so far)

<!-- .element: class="fragment" data-fragment-index="1" -->

</pba-col>
<pba-col center>

<img style="width: 70%" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/WebAssembly_Logo.svg/1200px-WebAssembly_Logo.svg.png" />

</pba-col>
</pba-cols>
</script></section><section  data-markdown><script type="text/template">
## WebAssembly and Polkadot

<img style="width: 70%" src="img/wasm/polkadot.png" />
</script></section><section  data-markdown><script type="text/template">
## Wasm's key points

<pba-flex center>

- Hardware independent
  <!-- .element: class="fragment" data-fragment-index="1" -->
  - Binary instruction format for a stack-based virtual machine
  - Altough with "locals" (registers) and higher level control flow elements
  <!-- .element: class="fragment" data-fragment-index="1" -->
- Supported as compilation target by many languages
  <!-- .element: class="fragment" data-fragment-index="2" -->
  - Rust, C, C++ and many others
  <!-- .element: class="fragment" data-fragment-index="2" -->
- Fast (with near-native performance when compiled - more later)
<!-- .element: class="fragment" data-fragment-index="3" -->
- Safe (executed in a sandboxed environment)
<!-- .element: class="fragment" data-fragment-index="4" -->

</pba-flex>

<aside class="notes"><p>Wasm seems to respect every rating points we defined before</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Stack-Based Virtual Machine Example

<pba-cols>
<pba-col center>

Adding two number in wasm text representation (.wat)

<!-- .element: class="fragment fade-out" data-fragment-index="1" -->

```wasm [1-12|5|6|8]
(module
  (import "console" "log" (func $log (param i32)))
  (func $main
    ;; load `10` and `3` onto the stack
    i32.const 10
    i32.const 3

    i32.add ;; add up both numbers
    call $log ;; log the result
  )
  (start $main)
)
```

<!-- .element: class="fragment" data-fragment-index="0" -->

</pba-col>
<pba-col center>

<div class="r-stack">
<img src="./img/pab/stack_1.svg" style="width: 100%">
<!-- .element: class="fragment" data-fragment-index="1" -->
<img src="./img/pab/stack_2.svg" style="width: 100%">
<!-- .element: class="fragment" data-fragment-index="2" -->
<img src="./img/pab/stack_3.svg" style="width: 100%">
<!-- .element: class="fragment" data-fragment-index="3" -->
<img src="./img/pab/stack_4.svg" style="width: 100%">
<!-- .element: class="fragment" data-fragment-index="4" -->
<img src="./img/pab/stack_5.svg" style="width: 100%">
<!-- .element: class="fragment" data-fragment-index="5" -->
<img src="./img/pab/stack_6.svg" style="width: 100%">
<!-- .element: class="fragment" data-fragment-index="6" -->
</div>

</pba-col>
</pba-cols>

<aside class="notes"><p>Wasm has also a text representation,
Wat has some features that allow for better readability:</p>
<ul>
<li>Stack push operations can be grouped to its consuming instruction.</li>
<li>Labels can be applied to elements.</li>
<li>Blocks can enclosed with parenthesis instead of explicit start/end instructions.</li>
</ul>
<p>Instructions push results to the stack and use values on the stack as arguments, the compilation process generally translate this stack-based bytecode to register based, where registers are used to pass values to instructions as a primary mechanism. The compilation will try to elide the wasm stack and work with only the architecture registers.</p>
<p>There is another type of stack used in wasm and that&#39;s called: shadow stack, resource to learn more: <a href="https://hackmd.io/RNp7oBzKQmmaGvssJDHxrw">https://hackmd.io/RNp7oBzKQmmaGvssJDHxrw</a></p>
</aside></script></section><section  data-markdown><script type="text/template">
## How Wasm is executed

<pba-flex left>

There are multiple ways to execute wasm:

- Ahead Of Time Compilation
  - Program is stored in executable format on disk
  - Thus it can be executed directly (after linking and loading)
- Just in Time Compilation
  - Program isn't stored in executable format
  - Instead it's compiled into an executable format just before it is executed
- Single Pass Compilation
  - Same as JIT but tries to minimize work done during compilation
  - Used in situations when JIT can't spend much time
- Interpretation
  - Program isn't store in executable format and never compiled into such
  - Instead, the programs instruction are _interpreted_ one by one
- ...

<!-- .element: class="fragment" data-fragment-index="1" -->

</pba-flex >

<aside class="notes"><p>AOT: Compile all the code at the beginning, this allows to makes a lot of improvement to the final code efficiency
JIT: The code is compiled only when needed, examples are functions that are compiled only when called, this leave space only to partials improvements
SPC: This is a specific technique of compilation that is made in linear time, the compilation is done only passing once on the code
Interpretation: The wasm blob is treated as any other interpreted language and executed in a Virtual Machine</p>
</aside></script></section><section  data-markdown><script type="text/template">
### Wasmtime

- Stand alone, sandboxed Wasm environment
- Wasmtime is compiling Wasm code
- Built on the optimizing Cranelift code generator to (quickly) generate high-quality machine code either at runtime (JIT) or ahead-of-time (AOT)

<!--TODO: graphics-->

<aside class="notes"><ul>
<li>wasmtime book: <a href="https://docs.wasmtime.dev/">https://docs.wasmtime.dev/</a></li>
<li>Used in substrate as embedder for the blockchain logic</li>
</ul>
<p>Cranelift is a fast, secure, relatively simple and innovative compiler backend. It takes an intermediate representation of a program generated by some frontend and compiles it to executable machine code</p>
</aside></script></section><section  data-markdown><script type="text/template">
#### Wasm lifecycle in Wasmtime

<div class="r-stack">
<img style="width: 70%" src="./img/pab/wasmtime_exec_1.svg" />
<img style="width: 70%" src="./img/pab/wasmtime_exec_2.svg"/>
<!-- .element: class="fragment" data-fragment-index="1" -->
<img style="width: 70%" src="./img/pab/wasmtime_exec_3.svg"/>
<!-- .element: class="fragment" data-fragment-index="2" -->
<img style="width: 70%" src="./img/pab/wasmtime_exec_4.svg"/>
<!-- .element: class="fragment" data-fragment-index="3" -->
</div>
</script></section><section  data-markdown><script type="text/template">
### Wasmi

- Wasm interpreter
- Minimal compilation work but the interpreter is still very fast
  - The wasm code is transpiled to WasmI IR, another stack-based bytecode
  - The WasmI IR is then interpreted by a Virtual Machine
- First approach for contracts on Polkadot (pallet-contracts)

<!--TODO: graphics-->

<aside class="notes"><p>proposal to switch from a stack based ir to registry based ir <a href="https://github.com/paritytech/wasmi/issues/361">https://github.com/paritytech/wasmi/issues/361</a></p>
<p>paper explaining the efficiency of translating wasm to registry based code <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/webassembly-interpreter-design-wasm-micro-runtime.html">https://www.intel.com/content/www/us/en/developer/articles/technical/webassembly-interpreter-design-wasm-micro-runtime.html</a> <!-- markdown-link-check-disable-line --></p>
<p>Due to it&#39;s characteristics it is mainly used to execute SmartContracts on chain</p>
</aside></script></section><section  data-markdown><script type="text/template">
#### Wasm lifecycle in Wasmi

<div class="r-stack">
<img style="width: 70%" src="./img/pab/wasmi_exec_1.svg" />
<img style="width: 70%" src="./img/pab/wasmi_exec_2.svg"/>
<!-- .element: class="fragment" data-fragment-index="1" -->
<img style="width: 70%" src="./img/pab/wasmi_exec_3.svg"/>
<!-- .element: class="fragment" data-fragment-index="2" -->
<img style="width: 70%" src="./img/pab/wasmi_exec_4.svg"/>
<!-- .element: class="fragment" data-fragment-index="3" -->
</div>

<!-- Really nice slide but there's not enough knowledge about substrate

There are also light clients, where both Runtime and Client are implemented in wasm, so we have:

- A browser as embedder of the node's client
  - the node's client as embedder for the node's runtime
    - the node's runtime as embedder for the SmartContract


<img style="height: 30vh" src="./img/pab/mind-blown-explosion.gif" />

We have a double recursion of a PAB that embed itself

-->
</script></section><section  data-markdown><script type="text/template">
### Wasmi

- Why use something different for contracts? Why not use Wasmtime?

<!-- .element: class="fragment" data-fragment-index="1" -->

- Mainly because compilation is too slow and resulting code isn't deterministic.

<!-- .element: class="fragment" data-fragment-index="2" -->

- We'll investigate this in the next lecture.

<!-- .element: class="fragment" data-fragment-index="2" -->
</script></section><section  data-markdown><script type="text/template">
# Alternatives
</script></section><section  data-markdown><script type="text/template">
## EVM

- The **Ethereum Virtual Machine** executes a stack machine
- See previous lecture
</script></section><section  data-markdown><script type="text/template">
## Solana

- Berkeley Packet Filter
- eBPF used in Linux
  - Allows untrusted code execution in kernel space
  - Bytecode verifier prevents attacks
  - For example: No unbounded loops allowed
- Solana uses a eBPF variant for contracts (rBPF / Solana VM)

<aside class="notes"><p><a href="https://forum.polkadot.network/t/ebpf-contracts-hackathon/1084">https://forum.polkadot.network/t/ebpf-contracts-hackathon/1084</a></p>
<h2 id="polkavm">PolkaVM</h2>
<p>More to be said about that very soon!</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Additional Resources! ðŸ˜‹

> Check speaker notes (click "s" ðŸ˜‰)

<aside class="notes"><ul>
<li><p>More on PAB:</p>
<ul>
<li><a href="https://github.com/gabriele-0201/IPABDN/blob/main/thesis/IPABDN.pdf">https://github.com/gabriele-0201/IPABDN/blob/main/thesis/IPABDN.pdf</a></li>
</ul>
</li>
<li><p>More on Rust target spec:</p>
<ul>
<li><a href="https://rust-lang.github.io/rfcs/0131-target-specification.html">https://rust-lang.github.io/rfcs/0131-target-specification.html</a></li>
</ul>
</li>
<li><p>Lin Clark&#39;s awesome talks on WASI (not super relevant to our work though):</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=fh9WXPu0hw8">https://www.youtube.com/watch?v=fh9WXPu0hw8</a></li>
<li><a href="https://www.youtube.com/watch?v=HktWin_LPf4">https://www.youtube.com/watch?v=HktWin_LPf4</a></li>
</ul>
</li>
<li><p><code>wasm-unknown</code> vs <code>wasm-wasi</code>:</p>
<ul>
<li><a href="https://users.rust-lang.org/t/wasm32-unknown-unknown-vs-wasm32-wasi/78325/5">https://users.rust-lang.org/t/wasm32-unknown-unknown-vs-wasm32-wasi/78325/5</a></li>
</ul>
</li>
<li><p><code>extern &quot;C&quot;</code>:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/keyword.extern.html">https://doc.rust-lang.org/std/keyword.extern.html</a></li>
<li><a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code">https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code</a></li>
</ul>
</li>
<li><p>Chapter 11 of this book is a great read: <a href="https://nostarch.com/rust-rustaceans">https://nostarch.com/rust-rustaceans</a></p>
</li>
</ul>
</aside></script></section>
    </article>
  </main>

  <script src="./../../dist/reveal.js"></script>

  <script src="./../../plugin/markdown/markdown.js"></script>
  <script src="./../../plugin/highlight/highlight.js"></script>
  <script src="./../../plugin/zoom/zoom.js"></script>
  <script src="./../../plugin/notes/notes.js"></script>
  <script src="./../../plugin/math/math.js"></script>

  <script src="./../../assets/plugin/mermaid.js"></script>
  <script src="./../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../assets/plugin/chart/chart.js"></script>
  <script src="./../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
