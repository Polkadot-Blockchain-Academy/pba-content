<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>SCALE</title>
  <link rel="icon" href="./../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../dist/reset.css" />
  <link rel="stylesheet" href="./../../dist/reveal.css" />
  <link rel="stylesheet" href="./../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# SCALE
</script></section><section  data-markdown><script type="text/template">
#Â SCALE: Introduction

## Serialization

- The process of translating a data structure or object state into a format that can be stored.
- Types of Serialization: Self-Describing vs Non Self-Describing
- Codecs: Encoders/Decoders
</script></section><section  data-markdown><script type="text/template">
## SCALE: Simple Concatenated Aggregate Little-Endian

Designed for high-performance, copy-free data encoding and decoding in resource-constrained environments.

- Non Self describing: the context must be known to decode.
- Little-Endian: has some performance benefits, like free casting.
</script></section><section  data-markdown><script type="text/template">
### Little-Endian

<img src="./endian.png" />
</script></section><section  data-markdown><script type="text/template">
## Little-Endian vs Big-Endian Example:

- How to encode the `15` decimal value as a `u32`:

  - Big-Endian: &nbsp;&nbsp; `0x 00 00 00 ff`
  - Little-Endian: `0x ff 00 00 00`
</script></section><section  data-markdown><script type="text/template">
## SCALE Basic Primitives

- u8, u16, u32, u64, u128, u256
- i8, i16, i32, i64, i128, i256
- boolean (specialized u8)

<aside class="notes"><p>Nothing fancy here</p>
</aside></script></section><section  data-markdown><script type="text/template">
## SCALE: Compact

- It can optimally store any integer from `0` to `2^536` without wasting memory.

- The least significant 2 **bits** of the **first byte** indicate the number of bytes that are used.
  - `0` => 1 byte, from 0 to 64 (2^6 - 1)
  - `1` => 2 bytes, from 64 to 16383 (2^14 - 1)
  - `2` => 4 bytes, from 16384 to 1073741823 (2^30 - 1)
  - `4` => The remaing bits of the first byte indicate the length (+4)
</script></section><section  data-markdown><script type="text/template">
## SCALE: Compact

- Examples:

  - `1` &nbsp; -> `0b_000001_00` &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -> `0x04`<!-- .element: class="fragment" -->
  - `2` &nbsp; -> `0b_000010_00` &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -> `0x08`<!-- .element: class="fragment" -->
  - `3` &nbsp; -> `0b_000011_00` &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -> `0x09`<!-- .element: class="fragment" -->
  - `63` -> `0b_111111_00` &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-> `0xfc`<!-- .element: class="fragment" -->
  - `64` -> `0b_000000_01_00000001` -> `0x0101`<!-- .element: class="fragment" -->
  - `65` -> `0b_000001_01_00000001` -> `0x0501`<!-- .element: class="fragment" -->
</script></section><section  data-markdown><script type="text/template">
## SCALE: Compact

- Exercise:
  - Manually decode `0x01ff` and `0x05`
</script></section><section  data-markdown><script type="text/template">
## SCALE Complex types

A "complex" type is a codec that references other types.

- Enum (AKA variants, tagged unions, discriminated union, etc).<!-- .element: class="fragment" -->
- Tuples: Simply the concatenation of different types of codecs.<!-- .element: class="fragment" -->
- Structs: Same as tuples, but the values are named (only relevant on the context).<!-- .element: class="fragment" -->
- Vectors: A collection of a dynamic size of any other type.<!-- .element: class="fragment" -->
<li class="fragment">- Specialized Enums:
<ul>
  <li>- Option: The first byte indicates whether there is a value or not.</li>
  <li>- Result: An Enum which always has 2 different tags, one for success and one for error.</li>
</ul></li>
- Specialized Vector: String -> Vector(u8)<!-- .element: class="fragment" -->
- Opaque: A "meta-type" which is a "de-facto" standard, an specialized Vector of bytes.<!-- .element: class="fragment" -->
</script></section><section  data-markdown><script type="text/template">
# SCALE Complex types: Enum

- The first byte indicates the index of the "tag".
- Example:

```js
Enum({
  foo: u16,
  bar: boolean,
  baz: _void,
});
```

- `0x000100` => `foo(1)`
- `0x0100` => `bar(false)`
- `0x02` => `baz`

- Observations:
  - Enums make it possible to have circular Codec definitions.
  - `Result` and `Option` are specialized Enums.
  - There can't be more than 256 options.
</script></section><section  data-markdown><script type="text/template">
# SCALE Complex types: Structs and Tuples

- Structs and Tuples are conceptually the same thing, but Structs have named values in its definitions.
- Example:

```js
Tuple(Tuple(u8, u8, u8), boolean, Option(u32));
```

```js
Struct({
  color: Struct({ red: u8, green: u8, blue: u8 }),
  isReady: boolean,
  price: Option(u32),
});
```
</script></section><section  data-markdown><script type="text/template">
# SCALE: Complex types: Vectors

- A compact encoded number indicates the number of instances that follow.

- Example:

```js
Vector(compact);
```

- `0x00` => `[]`
- `0x0404` => `[1]`
- `0x080400` => `[1, 0]`
- `0x0904000101` `[1, 0, 64]`

- Common Vectors:
  - `String` => `Vector(u8)`
  - `Bytes` => `Vector(u8)`

<aside class="notes"><p>Mention Fixed sized Arrays and explain why conceptually they are the same as a Tuple.</p>
</aside></script></section><section  data-markdown><script type="text/template">
# SCALE: "Opaque"

- Sometimes its convenient to use a Vector of bytes, so that we don't have to decode everything.
- Example: The body of a block is: `Vector(Opaque(Extrinsic))` => `Vector(Vector(u8))`
</script></section>
    </article>
  </main>

  <script src="./../../dist/reveal.js"></script>

  <script src="./../../plugin/markdown/markdown.js"></script>
  <script src="./../../plugin/highlight/highlight.js"></script>
  <script src="./../../plugin/zoom/zoom.js"></script>
  <script src="./../../plugin/notes/notes.js"></script>
  <script src="./../../plugin/math/math.js"></script>

  <script src="./../../assets/plugin/mermaid.js"></script>
  <script src="./../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../assets/plugin/chart/chart.js"></script>
  <script src="./../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
