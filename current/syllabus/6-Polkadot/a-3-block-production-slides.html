<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Polkadot Block Production</title>
  <link rel="icon" href="./../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../dist/reset.css" />
  <link rel="stylesheet" href="./../../dist/reveal.css" />
  <link rel="stylesheet" href="./../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# Block Production

<aside class="notes"><p>In this lecture weâ€™ll be covering what is block authoring as well as how it interacts with various consensus styles.</p>
</aside></script></section><section  data-markdown><script type="text/template">
# Block Production

## Agenda

- Authoring Overview

- AURA

- BABE

- Safrole

- Equivocations
</script></section><section  data-markdown><script type="text/template">
# Block Production

## Actors

- Validators
</script></section><section  data-markdown><script type="text/template">
# Block Production

## Overview

- Leader election problem
- Most fundemental validator/miner duty
- Leads to extending the blockchain
- Unthrottled block authoring would lead to a fork chaos

<aside class="notes"><p>First we are gonna start with a quick overview. Block authoring is the most primitive and fundemental validaot responsibility there is.</p>
<p>In fact in Bitcoin and most proof of work chains it was the only responsibility. There was nothing else than collecting transactions and authoring a block that contains them. This would in turn extend the blockchain. Someone always has to author the block.</p>
<p>We could technically allow anyone to author anytime, but this would lead to a forkful chaos. Chaos like that would be borderline imppossible to manage. All nodes couldnt import all the blocks, reexcuting them localy can be expensive so we need to slow things down.</p>
<p>So the main issue we&#39;ll be solving is ordering and throttling of authoring.</p>
<p>We will not be focusing on proof of work or simillar authoring mechanisms on this lecture, instead we will be exploring the authoring methods used in Polkadot and its ecosystem. As you remember from the previous lecture we already are given a few nice primitives from staking.</p>
</aside></script></section><section  data-markdown><script type="text/template">
# Block Production

## Prerequisites

- Well bounded set of validators
- All validators have stake exposure

<aside class="notes"><p>As one of the prerequisite we have a bounded set of validators. This is given to use by the staking submodule we will explore tomorrow. FOr now we take it for granted.</p>
<p>So the staking system already yielded us a small bounded set of authorities and the job of the block authoring module is to further narrow it down into individual block authoring spaced over time.</p>
<p>Additionally all the validators have something at stake. We can leverage that stake to potentially punish them and reward them proportionally.</p>
</aside></script></section><section ><section data-markdown><script type="text/template">
# Block Production

## Throttling

<pba-cols>
<pba-col>
  <ul>
    <li>Split the 24h authority term period into 6s timeslots</li>
    <li>Ideally there should be 1 block per timeslot</li>
  </ul>
</pba-col>
<pba-col>
<img style="width: 700px" src="./img/timeslot.drawio.svg" />
</pba-col>
</pba-cols>

<aside class="notes"><p>To slow down production we introduce the idea of a timeslot. Timeslot corresponds to specific amount of real world time, for instance 6s in Polkadot. We assume that all nodes have access to a commonly synchronised clock. Then based on their clocks we expect that in every time slot there will be a single block created.</p>
</aside></script></section><section data-markdown><script type="text/template">
# Block Production

## Throttling

<table border="1" cellspacing="0" cellpadding="8">
  <thead>
    <tr>
      <th>Polkadot</th>
      <th>Time</th>
      <th>Slots</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Slot</td>
      <td>6 seconds</td>
      <td>1</td>
    </tr>
    <tr>
      <td>Session/Epoch</td>
      <td>4 hours</td>
      <td>2_400</td>
    </tr>
    <tr>
      <td>Era</td>
      <td>24 hours</td>
      <td>14_400</td>
    </tr>
  </tbody>
</table>

<aside class="notes"><p>Timeslots are then further grouped into bigger time slices. For instance 4h which are used to schedule validator duties other than block authoring.
Staking elections happen every 24h, so every day our validator set can drastically change.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
# Block Production

## Aura

<pba-cols>
<pba-col>
  <ul>
    <li>Just a round-robin scheme</li>
    <li>Problems?</li>
  </ul>
</pba-col>
<pba-col>
<img style="width: 400px" src="./img/aura.png" />
</pba-col>
</pba-cols>

<aside class="notes"><p>So now that we have our 14_400 timeslots it is time to figure out who authors when. And the first and most naive solution is just to do a round robin. Pick any atribtrary ordering and everyone takes turns. We have much more timeslots than validators so a full lopp will complete a few times so noone will be omitted.</p>
</aside></script></section><section data-markdown><script type="text/template">
# Block Production

## Aura

<pba-cols>
<pba-col>
  <ul>
    <li>Just a round-robin scheme</li>
    <li>Problems?</li>
      <ul>
        <li>Next authority is known well in advance</li>
        <li>Makes it easy to pinpoint DDoS and censor</li>
    </ul>
  </ul>
</pba-col>
<pba-col>
<img style="width: 400px" src="./img/aura.png" />
</pba-col>
</pba-cols>

<aside class="notes"><p>The main problem is that it is apparent and public who the next author will be. You don&#39;t have to guess and can plan to for instance DDoS them exactly when they are authoring. DDoSing the whole active set is not viable but DDoSing a single author once in a while is totally doable. This could be abused to censor and manipulate the chain or affect the randomness aggregators.</p>
<p>So we need a solution that is a bit more secretive in how it chooses the validators.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
# Block Production

## BABE

### (Blind Assignment for Block Extension)

<aside class="notes"><p>And this is where BABE comes in. Babe stands for Blind Assignment for Block Extension so you can already see in the name that it will be trying to be more secretive with the blind part. What we want to achieve is some obfuscation and secrecy hiding who is the next author. It will be someone from the active set, that is our anonymity set but who exactly should be hidden for as long as possible.</p>
</aside></script></section><section data-markdown><script type="text/template">
# Block Production

## BABE

<pba-cols>
<pba-col>
  <ul>
    <li>One VRF output per validator per slot</li>
    <li>Outputs are kept hidden</li>
  </ul>
  </ul>
</pba-col>
<pba-col>
<img style="width: 400px" src="./img/vrf.png" />
</pba-col>
</pba-cols>

<aside class="notes"><p>BABE uses VRFs to achieve its blind assignment. I hope that you all remember what are verifiable random functions. They are random generators where you usually use some entropy context and your private key to generate some outputs which are later verifiable with your corresponding public key. A very useful primitive.</p>
</aside></script></section><section data-markdown><script type="text/template">
# Block Production

## BABE

<pba-cols>
<pba-col>
  <ul>
    <li>One VRF output per validator per slot</li>
    <li>Outputs are kept hidden</li>
    <li>If the output is below a set threshold: </li>
      <ul>
    <li>publish output to claim the slot</li>
    <li>author the corresponding block</li>
  </ul>
  </ul>
</pba-col>
<pba-col>
<img style="width: 400px" src="./img/babe_1.drawio.svg" />
</pba-col>
</pba-cols>

<aside class="notes"><p>So in Babe every validator generates a VRF output for every slot they see in the future. But they keep those outputs hidden. Then if their random number is below a specific constant threshold it means that they will be able to publish their number and claim the slow to author a block.</p>
<p>Untill you publish your result and prove it noone else knew you would win. This makes it so the attackers don;t even know who to DDoS.</p>
<p>This is exactly like Proof of Work whre they are looking for a small hash, but in BABE the validators get only a single try instead of endlesslly computing the hashes. You either get it or dont. No need to waste energy.</p>
</aside></script></section><section data-markdown><script type="text/template">
# Block Production

## BABE

<pba-cols>
<pba-col>
    <b>Any problems with that approach?</b>
  <ul>
  </ul>
</pba-col>
<pba-col>
<img style="width: 400px" src="./img/babe_1.drawio.svg" />
</pba-col>
</pba-cols>

<aside class="notes"><p>Does anyone see an obvious issue with this approach of rolling the dice and claiming slots?</p>
</aside></script></section><section data-markdown><script type="text/template">
# Block Production

## BABE

<pba-cols>
<pba-col>
    <b>Any problems with that approach?</b>
  <ul>
    <li>Sometimes no validators claim the slot</li>
    <li>[...]</li>
  </ul>
</pba-col>
<pba-col>
<img style="width: 400px" src="./img/babe_3.drawio.svg" />
</pba-col>
</pba-cols>

<aside class="notes"><p>The main problem is that sometimes simply no validator will get a random value below the threshold. This would cause the blockchain to skip a slot which is very undesirable. We want a nice and consistent block time.</p>
</aside></script></section><section data-markdown><script type="text/template">
# Block Production

## BABE

<pba-cols>
<pba-col>
    <b>Any problems with that approach?</b>
  <ul>
    <li>Sometimes no validators claim the slot</li>
    <li>Sometimes two validators can claim the same slot</li>
  </ul>
</pba-col>
<pba-col>
<img style="width: 400px" src="./img/babe_2.drawio.svg" />
</pba-col>
</pba-cols>

<aside class="notes"><p>And on top of that it is possible that sometimes we will get multiple validators claiming a slot if many of them got lucky. This would in turn cause a fork. We can deal with them in the long run but they waste a lot of computation and add extra complexity.</p>
</aside></script></section><section data-markdown><script type="text/template">
# Block Production

## BABE

<pba-cols>
<pba-col>
    
  <ul>
    <li><b>BABE uses Aura as plan B</b></li>
    <li>For every slot we try and find a VRF winner and we call those <b>primaries</b></li>
    <li>If no primary is present default to AURA and select a <b>secondary</b> author</li>
  </ul>
</pba-col>
<pba-col>
<img style="width: 600px" src="./img/fusion.jpg" />
</pba-col>
</pba-cols>

<aside class="notes"><p>To deal with the eventuality BABE introduces AURA as a backup plan. We still try to get a VRF winner every slot and those are called primaries. But if it fails and no priamry is selected we default to aura to subbly a backup validator called a secondary.</p>
<p>This combination leads to preserving the security benefits of BABE while benefitting for the predictability and efficiency of AURA. It injects just enough randomness to make censorship and DDoSing very difficult.</p>
<p>In reality VRF thresholds are configured so that around 25% of the slots have a primary author.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
# Block Production

## Safrole

<aside class="notes"><p>And finally we can take a look at the newest iteration of the block authoring mechanism and it&#39;s called Safrole. Safrole is not something that is being used in Polkadot today but it will is planned to release together with JAM.</p>
</aside></script></section><section data-markdown><script type="text/template">
# Block Production

## Safrole

- Aims to (mostly) elimate forks
- Reduce the reliance on AURA
- Keep complete privacy for ALL block authors
</script></section><section data-markdown><script type="text/template">
# Block Production

## Safrole

<img style="width: 400px" src="./img/babe_1.drawio.svg" />
</script></section><section data-markdown><script type="text/template">
# Block Production

## Safrole

<img style="width: 400px" src="./img/safrole_t.drawio.svg" />
</script></section><section data-markdown><script type="text/template">
# Block Production

## Safrole

<img style="width: 400px" src="./img/safrole.drawio.svg" />
</script></section><section data-markdown><script type="text/template">
# Block Production

## Safrole

Two main difficulties:

- When ordering them tickets need to be anonymous
- When ordering tickets they need to be validated

How can they be both validated and anonymous?
</script></section><section data-markdown><script type="text/template">
# Block Production

## Safrole

- Mixnets obfuscate the origin of a ticket
- Ring VRFs prove that it belongs to A validator but not which
- Owner validator can identify when claiming the slot
</script></section></section><section  data-markdown><script type="text/template">
# Block Production

## Equivocations

<pba-cols>
<pba-col>
    <b>Ambigious or conflicting statements</b>
</pba-col>
<pba-col>
<img style="width: 400px" src="./img/equiv.png" />
</pba-col>
</pba-cols>

<aside class="notes"><p>We discussed how the protocol operates and if everything goes according to plan validators will start authoring their blocks. Unfortunately there some validators might now want to paly along with the rules. The main malicious behavaiour they can exhibit is called an equiovcation.</p>
<p>An our case equivocation will be strickly referring to giving conflicting statements. Imagine you have a single phone number. You met Alice and Bob and given them your numbers. But you give them two different numbers. At this point we dont even need to check what exact numbers you&#39;ve given them. As long as we know they were two different numbers we know you lied at some point. You equivocated.</p>
<p>The same malicious behaviour can be done by block authors. An author can technically claim as slot and then author multiple blocks and try to double spend. Other nodes will be importing the blocks and if they detect two blocks from the same author on the same slot they will report him for equivocation. This is very easily provable as long as we have access to the two different blocks.</p>
<p>This proof be permisionlessly provided on chain and will be verified and then trigger slashes to the offending validators.</p>
</aside></script></section><section  data-markdown><script type="text/template">
# Questions
</script></section>
    </article>
  </main>

  <script src="./../../dist/reveal.js"></script>

  <script src="./../../plugin/markdown/markdown.js"></script>
  <script src="./../../plugin/highlight/highlight.js"></script>
  <script src="./../../plugin/zoom/zoom.js"></script>
  <script src="./../../plugin/notes/notes.js"></script>
  <script src="./../../plugin/math/math.js"></script>

  <script src="./../../assets/plugin/mermaid.js"></script>
  <script src="./../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../assets/plugin/chart/chart.js"></script>
  <script src="./../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
