<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Substrate Transaction Pool</title>
  <link rel="icon" href="./../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../dist/reset.css" />
  <link rel="stylesheet" href="./../../dist/reveal.css" />
  <link rel="stylesheet" href="./../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# Substrate Transaction Pool
</script></section><section  data-markdown><script type="text/template">
## Why Transaction Pool?

Because it is a (‚õìÔ∏è blockspace) market.

<pba-cols>
<pba-col>
<img style="width: 500px;" src="./img/tx-pool/BlockspaceBooth.png" />
</pba-col>

<pba-col>
<img style="width: 500px; margin-left: -100px; margin-top: 250px;" src="./img/tx-pool/short-line.png" /> <!-- .element: class="fragment" -->
</pba-col>

<pba-col>
<img style="width: 700px; margin-left: -100px; margin-top: 100px;" src="./img/tx-pool/long-line.png" /> <!-- .element: class="fragment" -->
</pba-col>

</pba-cols>

<aside class="notes"><p>The blockchain produces blockspace, and users buy that blockspace.
Why do they buy it?
So they can contribute to the shared story.
So they can interact with the shared state machine.
You can think of these users standing in line with transactions in their hand, waiting for the chance to put their transactions into the chain&#39;s blockspace.
Sometimes the demand for blockspace is low and the queue is short.
In this case the queue gets completely emptied each time a new block is created.
Other times it gets long and backed up.
Then when a block comes, only a part of the queue gets emptied.</p>
<p>This simple model provides some good intuition about how the transaction pool works, but it is a bit simplified.</p>
<p>First, It is actually a priority queue.
You can jump the line by offering to bribe the block producers.</p>
<p>Second, it is more accurate to think of the transactions themselves waiting in line, not the users who sent those transactions.</p>
<p>Let&#39;s take a closer look.</p>
</aside></script></section><section ><section data-markdown><script type="text/template">
## Context

<image rounded src="../../assets/img/5-Substrate/dev-pool-context.svg">

<aside class="notes"><ul>
<li>Gossip</li>
<li>Queue of all transactions, queue of ready transactions.</li>
<li>Then given to the block author, only READY ones.</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
### Context

Any Transaction Pool has two main objectives:

1. Validate Transactions
   - Ready, Future, or üóëÔ∏è?
2. Order them
   - Within each list, who is first?
</script></section></section><section ><section data-markdown><script type="text/template">
## 1. Transaction Validation

Moving transactions from one list to the other.

<diagram class="mermaid" style="display: flex; width: 80%">
graph LR
    W["ü§† Wild West"] --"üòà"--> T["üóëÔ∏è"]
    W --"üòá ‚åõÔ∏è"--> R["‚úÖ Ready"]
    W --"üòá ‚è≥"--> F["‚è∞ Future"]
</diagram>
</script></section><section data-markdown><script type="text/template">
### 1. Transaction Validation

- Transaction validity is exclusively outside of the transaction pool, and is **100% determined by the Runtime**.
- Transaction validation should be **cheap** to perform.
- Transaction pool is entirely an **offchain operation**.
  - No state change

<aside class="notes"><p>Important, must pause and ask!</p>
<ul>
<li>Why is it from the runtime? because the transaction format is opaque and the node doesn&#39;t even know what to do with it.</li>
<li>Why does it have to be cheap? wild west, unpaid, DoS!</li>
<li>Pesky question: but be aware that from the runtime&#39;s perspective, the node could be malicious. The runtime cannot trust the node to obey.</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
### 1. Transaction Validation

The runtime API.

```rust[1-100|6]
impl TaggedTransactionQueue<Block> for Runtime {
  fn validate_transaction(
    source: TransactionSource,
    tx: <Block  as BlockT>::Extrinsic,
    block_hash: <Block as BlockT>::Hash,
  ) -> TransactionValidity {
    ..
  }
}
```
</script></section><section data-markdown><script type="text/template">
### 1. Transaction Validation

```rust[1-100|5-6|8-9|11-12|14-100|1-100]
pub type TransactionValidity = Result<ValidTransaction, TransactionValidityError>;

/// This is going into `Ready` or `Future`
pub struct ValidTransaction {
  /// If in "Ready", what is the priority?
  pub priority: u64,

  /// For how long is this validity?
  pub longevity: u64,

  /// Should be propagate it?
  pub propagate: bool,

  /// Does this require any other tag to be present in ready?
  ///
  /// This determines "Ready" or "Future".
  pub requires: Vec<Tag>,
  /// Does this provide any tags?
  pub provides: Vec<Tag>,
}

type Tag = Vec<u8>
```
</script></section><section data-markdown><script type="text/template">
### 1. Transaction Validation: Banning

- Once certain transaction is discovered to be invalid, **its hash** is banned for a fixed duration of time.
- Default in substrate is `Duration::from_secs(60 * 30)`, can be configured via CLI.

<aside class="notes"><p>See: <a href="https://github.com/paritytech/substrate/pull/11786">https://github.com/paritytech/substrate/pull/11786</a></p>
<p>we probably also ban the peer who sent us that transaction? but have to learn.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## 2. Transaction Ordering

- `provides` and `requires` is a very flexible mechanism; it allows you to:
  - Specify if a transaction is "Ready" or "Future"
  - Within each, what transactions should ge before which.

<aside class="notes"><p>it essentially forms a graph.</p>
<p>Order mostly matters within the ready pool. I am not sure if the code maintains an order in <code>future</code> as well. In any
case, not a big big deal.</p>
</aside></script></section><section data-markdown><script type="text/template">
### 2. Transaction Ordering: Quiz Time.

<pba-cols>
<pba-col>

```
(
  A,
  provides: vec![],
  requires: vec![]
)
```

</pba-col>

<pba-col>
<table>
<thead>
  <tr>
    <th>Ready</th>
    <th>Future</th>
  </tr>
</thead>
<tbody class="fragment">
  <tr>
    <td>
    <pre>(A, pr: vec![], rq: vec![])</pre>
    </td>
    <td></td>
  </tr>
</tbody>
</table>
</pba-col>

</pba-cols>
</script></section><section data-markdown><script type="text/template">
### 2. Transaction Ordering: Quiz Time.

<pba-cols>
<pba-col>

```
(
  B,
  provides: vec![1],
  requires: vec![2]
)
```

</pba-col>

<pba-col>
<table>
<thead>
  <tr>
    <th>Ready</th>
    <th>Future</th>
  </tr>
</thead>
<tbody class="fragment">
  <tr>
    <td>
      <pre>(A, pr: vec![], rq: vec![])</pre>
    </td>
    <td>
      <pre>(B, pr: vec![1], rq: vec![2])</pre>
    </td>
  </tr>
</tbody>
</table>
</pba-col>

</pba-cols>
</script></section><section data-markdown><script type="text/template">
### 2. Transaction Ordering: Quiz Time.

<pba-cols>
<pba-col>

```
(
  C,
  provides: vec![2],
  requires: vec![3]
)
```

</pba-col>

<pba-col>
<table>
<thead>
  <tr>
    <th>Ready</th>
    <th>Future</th>
  </tr>
</thead>
<tbody class="fragment">
  <tr>
    <td>
      <pre>(A, pr: vec![], rq: vec![])</pre>
    </td>
    <td>
      <pre>(B, pr: vec![1], rq: vec![2])</pre>
    </td>
  </tr>
  <tr>
    <td>
    </td>
    <td>
      <pre>(C, pr: vec![2], rq: vec![3])</pre>
    </td>
  </tr>
</tbody>
</table>
</pba-col>

</pba-cols>
</script></section><section data-markdown><script type="text/template">
### 2. Transaction Ordering: Quiz Time.

<pba-cols>
<pba-col>

```
(
  D,
  provides: vec![1],
  requires: vec![0]
)
```

</pba-col>

<pba-col>
<table>
<thead>
  <tr>
    <th>Ready</th>
    <th>Future</th>
  </tr>
</thead>
<tbody class="fragment">
  <tr>
    <td>
      <pre>(A, pr: vec![], rq: vec![])</pre>
    </td>
    <td>
    </td>
  </tr>
  <tr>
    <td>
      <pre>(D, pr: vec![1], rq: vec![])</pre>
    </td>
    <td>
    </td>
  </tr>
  <tr>
    <td>
      <pre>(B, pr: vec![1], rq: vec![2])</pre>
    </td>
    <td>
    </td>
  </tr>
  <tr>
    <td>
      <pre>(C, pr: vec![2], rq: vec![3])</pre>
    </td>
    <td>
    </td>
  </tr>
</tbody>
</table>
</pba-col>

</pba-cols>

<aside class="notes"><p>The oder in this slide matters and it is top to bottom.</p>
</aside></script></section><section data-markdown><script type="text/template">
### 2. Transaction Ordering: `priority`

From the **Ready pool**, when all requirements are met, then `priority` dictates the order.

Further tie breakers:

2. ttl: shortest `longevity` goes first
3. time in the queue: longest to have waited goes first

<!-- .element: class="fragment" -->

<aside class="notes"><p><a href="https://github.com/paritytech/polkadot-sdk/blob/bc53b9a03a742f8b658806a01a7bf853cb9a86cd/substrate/client/transaction-pool/src/graph/ready.rs#L146">https://github.com/paritytech/polkadot-sdk/blob/bc53b9a03a742f8b658806a01a7bf853cb9a86cd/substrate/client/transaction-pool/src/graph/ready.rs#L146</a></p>
</aside></script></section><section data-markdown><script type="text/template">
### 2. Transaction Ordering: `priority`

> How can the pool be a pure FIFO?

<aside class="notes"><p>All priorities set to 0.</p>
</aside></script></section><section data-markdown><script type="text/template">
### 2. Transaction Ordering: `nonce`

Purposes of a nonce:

1. Ordering
2. Replay protection
3. Double spend protection
</script></section><section data-markdown><script type="text/template">
### 2. Transaction Ordering: `nonce`

- ‚úÖ You will implement a nonce system using the above primitives as a part of your assignment.
- General idea: `require -> (account, nonce - 1).encode()`, provide: `provides -> (account, nonce).encode()`

<aside class="notes"><p>Transaction Ordering: Each time a transaction is sent from an account, the nonce increases by one. This sequential
numbering ensures that transactions are processed in the order they are sent.</p>
<p>Double Spending Prevention: Since each transaction has a unique nonce, it&#39;s impossible for two transactions with the
same nonce to both be valid. This stops attackers from attempting to send the same funds twice.</p>
<p>Replay Attack Protection: In a replay attack, a valid transaction is maliciously or fraudulently repeated or delayed.
With a nonce, once a transaction is executed, any attempt to execute it again will fail since the nonce will no longer
match the current state of the account.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Shower Thought: Runtime vs STF

> Transaction pool is entirely an **offchain operation**

<aside class="notes"><p>what we said before. What does this imply?</p>
</aside></script></section><section data-markdown><script type="text/template">
### Shower Thought: Runtime vs STF

<img style="width: 1100px;" src="./img/tx-pool/peter-parker-glasses-off.png" />

<aside class="notes"><p>It is commonly said that the runtime is basically your STF.
This is a good first order approximation.
It is nearly true.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Shower Thought: Runtime vs STF

<img style="width: 1100px;" src="./img/tx-pool/peter-parker-glasses-on.png" />

<aside class="notes"><p>But as we can see here, when we put our glasses on, actually only some of the apis are part of the stf. the non-stf
parts are runtime APIs that are called and use, but don&#39;t really contribute to the STF. typically the runtime cannot
make assumptions about these. From the PoV of the runtime, when doing the main consensus critical work (authoring,
importing) these did not happen.</p>
</aside></script></section></section><section  data-markdown><script type="text/template">
## Lecture Recap

- Blockspace Market, Competition.
- Main tasks:
  - Validate (valid and invalid)
  - Order (split valid into "Ready" and "Future")
    - provides and requires
    - priority: Fee/tip
- By Runtime, but not in STF

<aside class="notes"><ul>
<li>Each node&#39;s pool is a local wild west.</li>
<li>Because it is wild west, the transaction pool must only check static and cheap things.</li>
<li>The block author won&#39;t trust the pool validation, and re-execute all checks.</li>
<li>Shower Thought: Transaction queue validation is part of the runtime, but not part of the STF.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
## Additional Resources

> Check speaker notes (click "s" üòâ)

<img width="300px" rounded src="../../assets/img/5-Substrate/thats_all_folks.png" />

<aside class="notes"><p><a href="https://github.com/paritytech/polkadot-sdk/blob/bc53b9a03a742f8b658806a01a7bf853cb9a86cd/substrate/client/transaction-pool/src/graph/ready.rs#L149">https://github.com/paritytech/polkadot-sdk/blob/bc53b9a03a742f8b658806a01a7bf853cb9a86cd/substrate/client/transaction-pool/src/graph/ready.rs#L149</a></p>
<p>Original pool PR from ages ago, old but gold: <a href="https://github.com/paritytech/substrate/issues/728">https://github.com/paritytech/substrate/issues/728</a></p>
<blockquote>
<p>Work towards a flexible transaction queue that relies <strong>only on runtime logic to provide comprehensive dependency and queuing management</strong>... should not be aware of the concepts of accounts, signatures, indexes or nonces.</p>
</blockquote>
<blockquote>
<p>Returns <code>Valid</code> if the transaction can be <strong>statically</strong> validated; ... the u64 is the priority used to determine which of a mutually exclusive set of transactions are better to include... Any transactions that do get included in a block should be instantly discarded (and banned) if they result in a panic execution.</p>
</blockquote>
<h3 id="post-lecture">Post Lecture</h3>
<p>More about MEV</p>
</aside></script></section><section  data-markdown><script type="text/template">
# Appendix
</script></section><section  data-markdown><script type="text/template">
## Transaction Pool Submission API

```rust
pub enum TransactionStatus<Hash, BlockHash> {
	/// Transaction is part of the future queue.
	Future,
	/// Transaction is part of the ready queue.
	Ready,
	/// The transaction has been broadcast to the given peers.
	Broadcast(Vec<String>),
	/// Transaction has been included in block with given hash.
	InBlock(BlockHash),
	/// The block this transaction was included in has been retracted.
	Retracted(BlockHash),
	/// Maximum number of finality watchers has been reached,
	/// old watchers are being removed.
	FinalityTimeout(BlockHash),
	/// Transaction has been finalized by a finality-gadget, e.g GRANDPA
	Finalized(BlockHash),
	/// Transaction has been replaced in the pool, by another transaction
	/// that provides the same tags. (e.g. same (sender, nonce)).
	Usurped(Hash),
	/// Transaction has been dropped from the pool because of the limit.
	Dropped,
	/// Transaction is no longer valid in the current state.
	Invalid,
}
```
</script></section>
    </article>
  </main>

  <script src="./../../dist/reveal.js"></script>

  <script src="./../../plugin/markdown/markdown.js"></script>
  <script src="./../../plugin/highlight/highlight.js"></script>
  <script src="./../../plugin/zoom/zoom.js"></script>
  <script src="./../../plugin/notes/notes.js"></script>
  <script src="./../../plugin/math/math.js"></script>

  <script src="./../../assets/plugin/mermaid.js"></script>
  <script src="./../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../assets/plugin/chart/chart.js"></script>
  <script src="./../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
