<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Light Clients and Bridges</title>
  <link rel="shortcut icon" href="./../../assets/favicon.ico" />
  <link rel="stylesheet" href="./../../dist/reset.css" />
  <link rel="stylesheet" href="./../../dist/reveal.css" />
  <link rel="stylesheet" href="./../../assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../assets/img/0-Shared/logo/pba-logo-white.svg"
      alt="PBA Logo">
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# Light Clients

<pba-cols>
<pba-col>

<img rounded style="width:400px" alt="Pierre Krieger aka Tomaka" src="./img/tomaka.png" />

</pba-col>
<pba-col>

> <div> What can I say?</div> <!-- .element: class="fragment" -->
> <div> It's a client but light.</div>  <!-- .element: class="fragment" -->

</pba-col>
</pba-cols>
</script></section><section ><section data-markdown><script type="text/template">
## üò¢ Running a Node is Hard üò≠

<pba-cols>
<pba-col>
<pba-flex center>

Ideally:

- Everyone runs their own node.

</pba-flex>
</pba-col>
<pba-col>

<pba-flex center>
<div>

Reality:

- It takes a lot of disk, memory, etc
- It takes some know-how
- I don't need it _all the time_

</div>
<!-- .element: class="fragment" -->

</pba-flex>
</pba-col>
</pba-cols>

<aside class="notes"><p>The bitcoin whitepaper clearly assumes that users will run their own nodes.
This is the most trustless and decentralized way to operate, and you should do it whenever you can.
If you think you can&#39;t you&#39;re probably wrong.
Just ask the Monero community.</p>
<p>There are <em>some</em> reasons not to run a full node and the reality is that not everyone will.
So even though we should always run our own nodes, let&#39;s look at some alternatives and ways we can make node running more accessible.</p>
</aside></script></section><section data-markdown><script type="text/template">
## RPC Nodes

AKA, trust somebody else's node.

<pba-flex center>

<ul>
<li>üïµÔ∏è Spy on you (<a href="https://decrypt.co/115486/infura-collect-metamask-users-ip-ethereum-addresses-after-privacy-policy-update">like infura</a>).</li> <!-- .element: class="fragment" -->
 
<li>üîû Censor you <!-- .element: class="fragment" -->
<li>ü§• Lie to you <!-- .element: class="fragment" -->
<li>üíî Steal your boyfriend <!-- .element: class="fragment" -->
</ul>

</pba-flex>

<aside class="notes"><p>The easiest thing to do is just trust some expert to run a node for you.
Very web2.
Lot&#39;s of things can go wrong.</p>
<p>So this is definitely not the best option.
Let&#39;s see if we can do better.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Lighten the Load

For resource constrained systems and people in a hurry

<pba-flex center>

- Phone
- Raspberry pi
- Microcontroller
- Inside Web Browser

</pba-flex>

<aside class="notes"><p>One of the complaints was that the node takes too much resources.
This is especially true if we want people to be able to run the node in all kinds of exotic environments.
And we do want that because we want people to run their own node even when they&#39;re just paying the bill at dinner from their phone or liking social posts while scrolling on the bus.
Let&#39;s make the client lighter so it doesn&#39;t require as much resources.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Light Client Duties

<pba-flex center>

- ‚ùå Sync blocks
- ‚ùå Execute blocks
- ‚úÖ Sync headers
- ‚ùî Maintain Transaction Pool
- ‚úÖ Checks consensus
- ‚ùå Maintains state

</pba-flex>

<aside class="notes"><p>This is what a typical light client does.
There is not a single definition of light client.
There are varying degrees of lightness to suit your needs.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Trustless

<img style="width:900px; margin-top:-30px" alt="Bitcoin SPV diagram checking Merkle root" src="./img/bitcoin-spv.png" />

<pba-flex center>

- Relies on full node for data
- Does not have to trust data
- State root helps a lot

</pba-flex>

<aside class="notes"><p>The figure is from the Bitcoin whitepaper.
The concept of light clients has been around since bitcoin.
At that time it was known as Simplified Payment Verification.
You could confirm that a payment was sent or received.
But you couldn&#39;t confirm that the tokens in question still existed or anything else about the state.</p>
<p>Chains with state roots can have much more powerful light clients</p>
</aside></script></section><section data-markdown><script type="text/template">
## Syncing Strategies

<pba-flex center>

- Full header sync
- Checkpoints in code
- Warp sync

</pba-flex>

<aside class="notes"><p>We also need to address the use case of clients that are not always on.
For example if you only need your node on your phone, or when using a specific web page, that means it will have some syncing to do.</p>
<p>Doing a full sync is already a lot faster than on a full client because you aren&#39;t downloading or executing the blocks.
But by the time you have a few million headers, it does still take some time.</p>
<p>The naive solution is to just have relatively recent headers hard-coded in the client.
This works pretty well.
You already have to trust the client developers for the entire implementation so you aren&#39;t trusting a new party at least.</p>
<p>Warp sync is possible when you have deterministic finality.
In dead simple PoA you just check that the authorities have signed the latest block and you are good.
If you have authority hand-offs, there is more work to be done.
You have to check that each authority set signs the transition to the next authority set.
But this is still only even N blocks instead of every block.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Self Defense

Stay in the gossip protocol or you might get got.

<img rounded width="500px" alt="You get nothing! You Lose! Good day sir!" src="./img/wanka.jpg" />
<!-- .element: class="fragment" -->

<aside class="notes"><p>In the main gossip protocol, if authorities finalize two conflicting blocks, then we can prove that they have broken the rules and slash them.
If we don&#39;t watch the gossip and only peer with a single full node, then our view is entirely defined by that node.
They may gossip us an attack chain and we won&#39;t know.
So it is important to communicate with many different full nodes.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Bridges

Transport layers between independent consensus systems

<img rounded width="700px" alt="Bridge spanning space between blockchains" src="./img/basic-bridge.svg" />

<aside class="notes"><p>Generally speaking bridges move arbitrary data between unrelated consensus systems.
Basically between different blockchains, and those messages can evoke arbitrary side effects on the target chain.
To keep it concrete, we&#39;ll mostly talk about moving tokens.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Source and Target Chain

<img rounded width="700px" src="./img/bridge-source-target.svg" />

<aside class="notes"><p>By convention we speak of bridges as being one-directional.
When we talk about trustless bridge design this is a core concept in the design.
It is less critical but still useful for trusted bridges.</p>
<p>A two-way bridge is really just two one-way bridge.
Think of a two-way
street.
There is a dedicated lane for each direction.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Source Chain Re-Orgs

<img width="900px" alt="What should target chain do when source chain re-orgs" src="./img/bridge-reorg.png" />

<aside class="notes"><p>On PoW chains this is truly just a judgement call and a prayer.
If the source chain has deterministic finality w can do better.
We need to wait for finality.
But even this isn&#39;t foolproof.
More on this after we cover the basic design.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Bridge Models

<pba-cols>
<pba-col>

### Trust-based

Trusted intermediary makes a transfer manually.<br/>
Eg. Wrapped bitcoin on ethereum (WBTC)

</pba-col>
<pba-col>

### Trustless

Trustless is the goal,<br/>like almost everything in web3.

</pba-col>
</pba-cols>

<aside class="notes"><p>The trust based bridges are not at all ideal.
You have to entirely trust an intermediary.
You send the intermediary tokens on the source chain.
Once the intermediary is satisfied that they really own the source tokens, they send you some target tokens on the target chain.
Or they don&#39;t whatever, not their problem.</p>
<p>You can make they trust properties slightly better by using a multisig or a group of people so you only have to trust some subset of them.
But this does not fundamentally eliminate the trust agreement.
One classic example is the WBTC foundation.
You send them bitcoin, they wait for &quot;enough&quot; block confirmations, and then they mint you an ERC20 token on Ethereum.
And they provide the same service in reverse too.</p>
<p>A lot of the trusted bridge design can be improved and we&#39;ll talk about that in detail in the next few slides.
But it&#39;s worth observing here that we will never be able to eliminate the part about &quot;Once the intermediary is satisfied that they really own the source tokens&quot;.
The bridge can never be stronger than the consensus on the source chain</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Trustless bridge design

<pba-flex center>

- Most trustless way to interact with blockchain<br/>is to run a node
- This is true for individuals _and_ other blockchains
- A blockchain is extremely resource constrained.
- Run a source chain light client on the target chain

</pba-flex>

<aside class="notes"></aside></script></section><section data-markdown><script type="text/template">
## BTC Relay

<img width="1000px" src="./img/btc-relay.svg" />
</script></section></section><section ><section data-markdown><script type="text/template">
## Bridge Design Challenges

<img rounded width="1100px" src="./img/bridge-collapse.webp">

<aside class="notes"><p>Bridges present their own set of design challenges beyond what we encounter in regular stand-alone light clients.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Peers?

<pba-flex center>

- How can we peer without networking?
- Enter the **Relayer** - a permissionless and trustless role
- Need at least one honest relayer

</pba-flex>

<aside class="notes"><p>On-chain logic doesn&#39;t have network IO, so how do we peer?
There is a role known as a relayer.
It is an off-chain agent who watches the source chain, and submits headers and finality proofs from the source chain to the target chain through transactions.
Anyone can start a relayer.
It is typically a little piece of software that you run.
But there is nothing magic about it.
You could perform the relayer task manually by copying header data from an explorer into metamask for example.</p>
<p>You do need at least one honest relayer for the chain to get the correct header info.
For this reason a large decentralized relayer group is nice.
But even if you don&#39;t trust any relayer out there, you can always run your own.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Finality and Equivocation

TODO Figure of competing finalized chain
TODO Seun's achiles heel meme

<aside class="notes"><p>It is not safe to accept headers as finalized immediately even if there is a deterministic finality proof.
Let that sink in.
Even if there is a valid finality proof, it is not safe to accept them as finalized.
Why not?</p>
<p>Because the validators may be equivocating.
They don&#39;t send equivocations to real nodes on the network because those equivocations will be gossiped around and reported on the source chain and the validators will be slashed accordingly.
But remember a light client on the target chain has no way to report such equivocations back to the source chain.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Equivocation Incentives

<pba-flex center>

- Add a **Challenge Period** and
- Add Fishermen - reverse of relayers

<div>

**OR**

- Stake Relayers
  so they can be slashed

</div>
<!-- .element: class="fragment" -->

</pba-flex>

<aside class="notes"><p>There are basically two classes of solutions.
Both of them require a waiting period aka challenge period before accepting a header with a finality proof as final.</p>
<p>One is to add a role of fishermen.
They are responsible for noticing when the header candidate on the target chain is different from the one in the main source chain protocol and reporting this behavior back to the source chain so the validators can be slashed there.
Two problems:</p>
<ol>
<li>Fishermen have weak incentives.
If they do a good job there will be no equivocations and they will not get paid.</li>
<li>Target chain is relying on the foreign source chain to keep the bridge secure instead of owning that security itself.</li>
</ol>
<p>The other is to have the relayer role require a security deposit.
If it turns out that a relayer relays an attack header, that relayer is slashed and the relayer who reports it gets a reward.
Relayers will expect to earn some reward for the opportunity cost of their stake which makes the bridge operation more expensive.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Multichain Apps

TODO Figure of stack with two blockchains on the bottom layer
</script></section><section data-markdown><script type="text/template">
## We have a header, now what?

<pba-flex center>

- App users submit proofs
- Need a source chain transaction?<br/>
  Submit an spv-style transaction proof
- Need some source chain state?<br/>
  Submit a state proof

</pba-flex>

<aside class="notes"><p>The header sync is just the foundation.
Now Applications can build on top of it with the best possible trust guarantees.</p>
<p>If you need some source chain transaction, your app needs to require an spv-style transaction proof to check against the header&#39;s extrinsics root.</p>
<p>If you need some source chain state, your app needs to require a state proof to check against the header&#39;s state root.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Multichain Security

<img rounded style="width: 500px; margin-top:-30px" src="./img/strong-and-weak-.png" />

<aside class="notes"><p>This kind of trustless bridge <em>with proper incentives</em> gets us information about the source chain to the target chain with security about as high as it was on the source chain.
If you are building an app that spans multiple chains consider the security guarantees on both chains.
The weaker security of the two is the security your app has.
More abstractly, your app consumes two different kinds of blockspace that may be of different qualities.
Your app is only as quality as the lower of the blockspaces.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Example

Depository - Mint model - Full backing

TODO - complete slide
</script></section></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#4A2439" -->

# Questions
</script></section>
    </article>
  </main>

  <script src="./../../dist/reveal.js"></script>

  <script src="./../../plugin/markdown/markdown.js"></script>
  <script src="./../../plugin/highlight/highlight.js"></script>
  <script src="./../../plugin/zoom/zoom.js"></script>
  <script src="./../../plugin/notes/notes.js"></script>
  <script src="./../../plugin/math/math.js"></script>
  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
