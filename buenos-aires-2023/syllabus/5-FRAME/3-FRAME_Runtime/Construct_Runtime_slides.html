<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Construct Runtime</title>
  <link rel="shortcut icon" href="./../../../assets/favicon.ico" />
  <link rel="stylesheet" href="./../../../dist/reset.css" />
  <link rel="stylesheet" href="./../../../dist/reveal.css" />
  <link rel="stylesheet" href="./../../../assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../../assets/img/0-Shared/logo/pba-logo-white.svg"
      alt="PBA Logo">
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# Runtime Construction

... And testing
</script></section><section ><section data-markdown><script type="text/template">
<image src="../../../assets/img/6-FRAME/frame1.svg" style="height: 600px">
</script></section><section data-markdown><script type="text/template">
### From a Pallet ..to the Runtime

- What is a runtime anyway? Anything that implements the aforementioned Runtime APIs.
- Most often fulfilled by the `Executive`.
</script></section></section><section ><section data-markdown><script type="text/template">
## `construct_runtime`

```rust
frame_support::construct_runtime!(
  pub struct Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic,
  {
    System: frame_system,
    Timestamp: pallet_timestamp,
    Balances: pallet_balances,
    Aura: pallet_aura,
    Dpos: pallet_dpos,
  }
);
```
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

```rust [2]
frame_support::construct_runtime!(
  pub struct Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic,
  {
    System: frame_system,
    Timestamp: pallet_timestamp,
    Balances: pallet_balances,
    Aura: pallet_aura,
    Dpos: pallet_dpos,
  }
);
```
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

- `struct Runtime` is autogenerated for you.
- It implements [A LOT OF STUFF](https://paritytech.github.io/substrate/master/kitchensink_runtime/struct.Runtime.html)!
- But most importantly, the `Config` trait of all of your pallets ü´µüèª.

```rust
impl frame_system::Config for Runtime { .. }
impl pallet_timestamp::Config for Runtime { .. }
impl pallet_dpos::Config for Runtime { .. }
```
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

```rust
// ‚úÖ
pallet_dpos::Pallet::<Runtime>::force_change_authorities(..);

// a normal pub function defined in
frame_system::Pallet::<Runtime>::block_number();
// a storage getter of a map.
frame_system::Pallet::<Runtime>::account(42u32);
frame_system::Account::<Runtime>::get(42u32);
```
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

- The old syntax of this line was `pub enum Runtime` ü§¶‚Äç‚ôÇÔ∏è.
- In many tests, the convention is to write it as `pub enum Test` ü§Æ.

```rust
// üëÄ
pallet_dpos::Pallet::<Test>::force_change_authorities(..);

```
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

```rust [3-5]
frame_support::construct_runtime!(
  pub struct Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic,
  {
    System: frame_system,
    Timestamp: pallet_timestamp,
    Balances: pallet_balances,
    Aura: pallet_aura,
    Dpos: pallet_dpos,
  }
);
```
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

- Specify some types that are useful further down the road.
- `Block` vs `NodeBlock`?

<aside class="notes"><p><code>UncheckedExtrinsic</code> is the final extrinsic type. What we called <code>BasicExtrinsic</code> in the week 2 assignment.</p>
</aside></script></section><section data-markdown><script type="text/template">
### `construct_runtime`

```rust [7-11|7-12]
frame_support::construct_runtime!(
  pub struct Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic,
  {
    System: frame_system,
    Timestamp: pallet_timestamp,
    Balances: pallet_balances,
    Aura: pallet_aura,
    Dpos: pallet_dpos,
    <NameYouChoose>: path_to_crate,
  }
);
```
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

- Crucially, under the hood, this generates:

<div>

```rust
type System = frame_system::Pallet<Runtime>;
type Balances = pallet_balances::Pallet<Runtime>;
..
type DPos = pallet_dpos::Pallet<Runtime>;
```

- Recall that `Runtime` implements `<T: Config>` of all pallets.

</div>
<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

```rust
// we can now simplify this:
pallet_dpos::Pallet::<Runtime>::force_change_authorities(..);
// into:
Dpos::force_change_authorities(..);

// ‚úÖ Similarly:
System::block_number();
System::account(42u32);
```
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

- Next crucial piece of information that is generated is:

```rust
type AllPallets = (System, Balances, ..., Dpos);
```

- This is used in `Executive` to dispatch pallet hooks.

```rust
<AllPallets as OnInitialize>::on_initialize();
<AllPallets as OnInitialize>::on_finalize();
```

Question: What will be the order of `fn on_initialize()`?

<aside class="notes"><p>There&#39;s also <code>type AllPalletsWithoutSystem</code> and some other variants that are no longer</p>
</aside></script></section><section data-markdown><script type="text/template">
### `construct_runtime`

- Generates some outer types:

  - `RuntimeCall` (see calls lecture)
  - `RuntimeEvent`
  - `RuntimeOrigin`
  - `GenesisConfig` (see hooks lecture)

- More about these in the Friday deep dive lecture!
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

```rust
// somewhere in your pallet, called `my_pallet`
#[pallet::call]
impl<T: Config> Pallet<T> {
  fn transfer(origin: OriginFor<T>, from: T::AccountId, to: T::AccountId, amount: u128);
  fn update_runtime(origin: OriginFor<T>, new_code: Vec<u8>);
}
```

```rust
// expanded in your pallet
enum Call {
  transfer { from: T::AccountId, to: T::AccountId, amount: u128 },
  update_runtime { new_code: Vec<u8> },
}
```

<!-- .element: class="fragment" -->

```rust
// in your outer runtime
enum RuntimeCall {
  System(frame_system::Call),
  MyPallet(my_pallet::Call),
}
```

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

```rust [7-9]
frame_support::construct_runtime!(
  pub struct Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic,
  {
    System: frame_system::{Pallet, Call, Config, Storage, Event<T>},
    Balances: pallet_balances::{Pallet, Call, Storage, Config<T>, Event<T>},
    Dpos: pallet_dpos,
  }
);
```

- Pallet parts, optional by default, can be made explicit.
- Omitting them will exclude them from the metadata, or the "outer/runtime types"
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

```rust [7-9]
frame_support::construct_runtime!(
  pub struct Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic,
  {
    System: frame_system = 1,
    Balances: pallet_balances = 0,
    Dpos: pallet_dpos = 2,
  }
);
```
</script></section><section data-markdown><script type="text/template">
### `construct_runtime`

Final thoughts:

- Order in the `construct_runtime` matters!
- Recall `integrity_test()` is called upon `construct_runtime`.

```sh
test mock::__construct_runtime_integrity_test::runtime_integrity_tests ... ok
```
</script></section></section><section  data-markdown><script type="text/template">
# Part 2: Testing
</script></section><section ><section data-markdown><script type="text/template">
## Testing and Mocks

A test requires a mock runtime, so we need to do a full `construct_runtime`..

.. but luckily, most types can be mocked üòÆ‚Äçüí®.

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

- Let's look at the almighty system pallet to get some inspiration.
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

```rust
impl frame_system::Config for Runtime {
  // type SS58Prefix: Get<u16>;
  type SS58Prefix = ();

  // type BaseCallFilter: Contains<Self::RuntimeCall>;
  type BaseCallFilter = frame_support::traits::Everything;

  // type RuntimeOrigin: Into<Result<RawOrigin<Self::AccountId>, Self::RuntimeOrigin>>
  type RuntimeOrigin = RuntimeOrigin; // <-- comes from construct_runtime

  // type RuntimeCall: Dispatchable<RuntimeOrigin = Self::RuntimeOrigin>
  type RuntimeCall = RuntimeCall; // <-- comes from construct_runtime

  // type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
  type RuntimeEvent = RuntimeEvent; // <-- comes from construct_runtime

  // type Version: Get<RuntimeVersion>;
  type Version = ();

  // type OnNewAccount: OnNewAccount<Self::AccountId>;
  type OnNewAccount = ();

  // type OnSetCode: SetCode<Self>;
  type OnSetCode = ();

  // type BlockHashCount: Get<Self::BlockNumber>;
  type BlockHashCount = frame_support::traits::ConstU32<128>;

  type Hashing = sp_runtime::traits::BlakeTwo256;
  type Hash = sp_core::H256;
  type Lookup = sp_runtime::traits::IdentityLookup<Self::AccountId>;
  type Header = sp_runtime::testing::Header;
  // This is rather detailed, come ask us if you want to know more!
  type AccountData = pallet_balances::AccountData<Balance>;

  type Index = u32;
  type BlockNumber = u32;
  type AccountId = u32;

  type DbWeight = (); // Get<_>
  type BlockLength = (); // Get<_>
  type BlockWeights = (); // Get<_>
  type PalletInfo = PalletInfo;
  type OnKilledAccount = ();
  type SystemWeightInfo = ();
  type MaxConsumers = frame_support::traits::ConstU32<16>;
}
```
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

- Types can be mocked to something reasonable:

* `u32` account id.
* `u128` balance.
* `u32` block number.
* ...
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

- Next, we want to supply some value to those `Get<_>` associated types.
- Assume:

```rust
#[pallet::config]
pub trait Config: frame_system::Config + pallet_aura::Config {
  type Currency: ...
  type MinimumDelegation: Get<BalanceOf<Self>>;
}
```
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

```rust
impl pallet_balances::Config for Runtime {
  type Balance = u128;
  ...
}
```

```rust
parameter_types! {
  pub const MinimumDelegationValue: u128 = 100;
}
```

<!-- .element: class="fragment" -->

```rust
impl pallet_dpos::Config for Runtime {
  type MinimumDelegation = MinimumDelegationValue;
  ...
}
```

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

- Or, if your value is always constant:

```rust
impl pallet_dpos::Config for Runtime {
  type MinimumDelegation = frame_support::traits::ConstU128<100>;
  ...
}
```
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

- Or, if you want to torture yourself:

```rust
pub struct MinimumDelegationValue;
impl Get<u32> for MinimumDelegationValue {
  fn get() -> u32 {
    100
  }
}

impl pallet_dpos::Config for Runtime {
  type MinimumDelegation = MinimumDelegationValue;
  ...
}
```
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

- Next, if you want to feed some data into your pallet's genesis state, we must first setup the
  genesis config correctly.

```rust
#[pallet::genesis_config]
pub struct GenesisConfig<T: Config> {
  initial_validators: Vec<T::AccountId>
}

#[pallet::genesis_build]
impl<T: Config> GenesisBuild<T> for GenesisConfig<T> {
  fn build(&self) {
    for validator in self.initial_validator {
      // bond them, stuff, blah blah
    }
  }
}
```
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

- Then, we build a builder pattern to construct the genesis config.

```rust
// assuming:
type AccountId = u32;

#[derive(Default)]
pub struct Builder {
  initial_validators: Vec<AccountId>,
}
```

```rust
impl Builder {
  fn add_validator(mut self, v: AccountId) -> Self {
    self.initial_validators.push(v);
    self
  }
}
```

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

- Finally, we provide a `fn build(self) -> TestExternalities`.

```rust
impl Builder {
  fn build(self) -> sp_io::TestExternalities {
    let mut storage =
      frame_system::GenesisConfig::default().build_storage::<Runtime>().unwrap();

    let _ = pallet_dpos::GenesisConfig::<Runtime> {
      initial_validators: self.initial_validators,
    }
    .assimilate_storage(&mut storage);

    // assimilate_storage the genesis of other pallets if needed...

    let mut ext = sp_io::TestExternalities::from(storage);
  }
}
```
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

- Finally, this allows you to write a test like this:

```rust
#[test]
fn test_stuff() {
  let mut ext = Builder::default()
    .add_validator(1)
    .add_validator(2)
    .build();
  ext.execute_with(|| {
    // do stuff
  });
}
```
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

- What if you want to change that `MinimumDelegation`?

<div>

```rust
parameter_types! {
  pub static MinimumDelegation: u128 = 100;
}
```

- Gives us:

```rust
MinimumDelegation::set(200);
MinimumDelegation::get();
```

</div>
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

- With that in mind:

```rust
impl Builder {
  fn set_minimum_delegation(self, v: u128) -> Self {
    MinimumDelegation::set(v);
    self
  }
}
```
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

```rust
#[test]
fn test_stuff() {
  let mut ext = Builder::default()
    .add_validator(1)
    .set_minimum_delegation(200)
    .build();
  ext.execute_with(|| {
    // do stuff
  });
}
```
</script></section><section data-markdown><script type="text/template">
### Testing and Mocks

- If you want to run some code post-every test? no worries!

```rust
pub(crate) fn build_and_execute(self, test: impl FnOnce() -> ()) {
  self.build().execute_with(|| {
    test();
    // now check that your pallet's state is sane!
    assert!(true);
  })
}
```
</script></section></section><section ><section data-markdown><script type="text/template">
### Progressing Blocks

- Often times, in your test, you want mimic the progression of an empty block.
- De-nada!
  - Set the block number in system.
  - call into `on_finalize(now)` of any pallet in your mock runtime.
  - (and perhaps `on_idle` etc.)
  - call into `on_initialize`(now+1)` of any pallet in your mock runtime.
  - Now your pallet is in a state to call into its transactions.
</script></section><section data-markdown><script type="text/template">
### Progressing Blocks

```rust
#[test]
fn test() {
  let mut ext = Builder::default()
    .add_validator(1)
    .set_minimum_delegation(200)
    .build();
  ext.execute_with(|| {
    // initial stuff
    next_block();

    // dispatch some call
    assert!(some_condition);

    next_block();

    // repeat..
  });
}
```
</script></section><section data-markdown><script type="text/template">
### Progressing Blocks

```rust
pub fn next_block() {
  let now = System::block_number();
  Dpos::on_finalize(now);
  System::on_finalize(now);
  ...
  System::set_block_number(now + 1);
  System::on_initialize(now + 1)
  Dpos::on_initialize(now + 1);
}
```
</script></section><section data-markdown><script type="text/template">
### Progressing Blocks

```rust
pub fn next_block() {
  let now = System::block_number();
  AllPallets::on_finalize(now);
  System::set_block_number(now + 1);
  AllPallets::on_initialize(now + 1)
}
```
</script></section></section><section  data-markdown><script type="text/template">
## Additional Resources üòã

> Check speaker notes (click "s" üòâ)

<aside class="notes"><ul>
<li>This PR was actually an outcome Cambridge PBA: <a href="https://github.com/paritytech/substrate/pull/11932">https://github.com/paritytech/substrate/pull/11932</a></li>
<li><a href="https://github.com/paritytech/substrate/pull/11818">https://github.com/paritytech/substrate/pull/11818</a></li>
<li><a href="https://github.com/paritytech/substrate/pull/10043">https://github.com/paritytech/substrate/pull/10043</a></li>
<li>On usage of macros un Substrate: <a href="https://github.com/paritytech/substrate/issues/12331">https://github.com/paritytech/substrate/issues/12331</a></li>
<li>Disscussion on advance testing: <a href="https://forum.polkadot.network/t/testing-complex-frame-pallets-discussion-tools/356">https://forum.polkadot.network/t/testing-complex-frame-pallets-discussion-tools/356</a></li>
<li>Reserve topic: Reading events.</li>
<li>Reserve-topic: try-state.</li>
</ul>
<h3 id="original-lecture-script">Original Lecture Script</h3>
<p>this is your bridge from a pallet into a runtime.</p>
<p>a runtime amalgamator is composed of the following:</p>
<ol>
<li>all pallet&#39;s <code>Config</code> implemented by a <code>struct Runtime</code>;</li>
<li>construct <code>Executive</code> and use it to implement all the runtime APIs</li>
<li>Optionally, some boilerplate to setup benchmarking.</li>
<li>invoke <code>construct_runtime!</code>.</li>
<li>Alias for each pallet.</li>
</ol>
<p>The <code>construct_runtime!</code> itself does a few things under the hood:</p>
<ol>
<li>crate <code>struct Runtime</code>.</li>
<li>amalgamate <code>enum RuntimeCall</code>; // passed inwards to some pallets that want to store calls.</li>
<li>amalgamate <code>enum RuntimeEvent</code>; // passed inwards to all pallets.</li>
<li>amalgamate <code>enum RuntimeOrigin</code> (this is a fixed struct, not an amalgamation);</li>
<li>Create a very important type alias:</li>
</ol>
<ul>
<li><code>type AllPallets</code> / <code>type AllPalletsWithoutSystem</code></li>
</ul>
<ol>
<li>run <code>integrity_test()</code>.</li>
</ol>
<blockquote>
<p>Note that there is no such thing as <code>RuntimeError</code>. Errors are not amalgamated, they just are. This should be in the error lecture.</p>
</blockquote>
<ul>
<li>Ordering in <code>construct_runtime</code> matters.</li>
<li>Pallet parts can be optional in <code>construct_runtime!</code>.</li>
</ul>
</aside></script></section>
    </article>
  </main>

  <script src="./../../../dist/reveal.js"></script>

  <script src="./../../../plugin/markdown/markdown.js"></script>
  <script src="./../../../plugin/highlight/highlight.js"></script>
  <script src="./../../../plugin/zoom/zoom.js"></script>
  <script src="./../../../plugin/notes/notes.js"></script>
  <script src="./../../../plugin/math/math.js"></script>
  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
