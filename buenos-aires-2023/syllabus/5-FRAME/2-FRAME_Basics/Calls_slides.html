<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>FRAME Calls</title>
  <link rel="shortcut icon" href="./../../../assets/favicon.ico" />
  <link rel="stylesheet" href="./../../../dist/reset.css" />
  <link rel="stylesheet" href="./../../../dist/reveal.css" />
  <link rel="stylesheet" href="./../../../assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../../assets/img/0-Shared/logo/pba-logo-white.svg"
      alt="PBA Logo">
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# FRAME Calls
</script></section><section  data-markdown><script type="text/template">
## Overview

Calls allow users to interact with your state transition function.

In this lecture, you will learn how to create calls for your Pallet with FRAME.
</script></section><section  data-markdown><script type="text/template">
## Terminology

The term "call", "extrinsic", and "dispatchable" all get mixed together.

Here is a sentence which should help clarify their relationship, and why they are such similar terms:

> Users submit an **extrinsic** to the blockchain, which is **dispatched** to a Pallet **call**.
</script></section><section  data-markdown><script type="text/template">
## Call Definition

Here is a simple pallet call. Let's break it down.

```rust
#[pallet::call]
impl<T: Config> Pallet<T> {
	#[pallet::call_index(0)]
	#[pallet::weight(T::WeightInfo::transfer())]
	pub fn transfer(
		origin: OriginFor<T>,
		dest: AccountIdLookupOf<T>,
		#[pallet::compact] value: T::Balance,
	) -> DispatchResult {
		let transactor = ensure_signed(origin)?;
		let dest = T::Lookup::lookup(dest)?;
		<Self as Currency<_>>::transfer( &transactor, &dest, value, ExistenceRequirement::AllowDeath)?;
		Ok(())
	}
}
```
</script></section><section  data-markdown><script type="text/template">
## Call Implementation

Calls are just functions which are implemented on top of the `Pallet` struct.

You can do this with any kind of function, however, "FRAME magic" turns these into dispatchable calls through the `#[pallet::call]` macro.
</script></section><section  data-markdown><script type="text/template">
## Call Origin

Every pallet call must have an `origin` parameter, which uses the `OriginFor<T>` type, which comes from `frame_system`.

```rust
/// Type alias for the `Origin` associated type of system config.
pub type OriginFor<T> = <T as crate::Config>::RuntimeOrigin;
```
</script></section><section  data-markdown><script type="text/template">
## Origin

The basic origins available in frame are:

```rust
/// Origin for the System pallet.
#[derive(PartialEq, Eq, Clone, RuntimeDebug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum RawOrigin<AccountId> {
	/// The system itself ordained this dispatch to happen: this is the highest privilege level.
	Root,
	/// It is signed by some public key and we provide the `AccountId`.
	Signed(AccountId),
	/// It is signed by nobody, can be either:
	/// * included and agreed upon by the validators anyway,
	/// * or unsigned transaction validated by a pallet.
	None,
}
```

We will have another presentation diving deeper into Origins.
</script></section><section  data-markdown><script type="text/template">
## Origin Checking

Normally, the first thing you do in a call is check that the origin of the caller is what you expect.

Most often, this is checking that the extrinsic is `Signed`, which is a transaction from a user account.

```rust
let caller: T::AccountId = ensure_signed(origin)?;
```
</script></section><section  data-markdown><script type="text/template">
## Call Parameters

Pallet calls can have additional parameters beyond `origin` allowing you to submit relevant data about what the caller would like to do.

All call parameters need to satisfy the `Parameter` trait:

```rust
/// A type that can be used as a parameter in a dispatchable function.
pub trait Parameter: Codec + EncodeLike + Clone + Eq + fmt::Debug + scale_info::TypeInfo {}
impl<T> Parameter for T where T: Codec + EncodeLike + Clone + Eq + fmt::Debug + scale_info::TypeInfo {}
```
</script></section><section  data-markdown><script type="text/template">
## Parameter Limits

Most everything can be used as a call parameter, even a normal `Vec`, however, FRAME ensures that encoded block are smaller than a maximum block size, which inherently limits the extrinsic length.

In Polkadot this is currently 5 MB.
</script></section><section  data-markdown><script type="text/template">
## Compact Parameters

Parameters that are compact encoded can be used in calls.

```rust
pub fn transfer(
	origin: OriginFor<T>,
	dest: AccountIdLookupOf<T>,
	#[pallet::compact] value: T::Balance,
) -> DispatchResult { ... }
```

This can help save lots of bytes, especially in cases like balances as shown above.
</script></section><section  data-markdown><script type="text/template">
## Call Logic

The most relevant part of a call is the "call logic".

There is really nothing magical happening here, just normal Rust.

However, you must follow one important rule...
</script></section><section  data-markdown><script type="text/template">
## Calls MUST NOT Panic

Under no circumstances (save, perhaps, storage getting into an irreparably damaged state) must this function panic.

Allowing callers to trigger a panic from a call can allow users to attack your chain by bypassing fees or other costs associated with executing logic on the blockchain.
</script></section><section  data-markdown><script type="text/template">
## Call Return

Every call returns a `DispatchResult`:

```rust
pub type DispatchResult = Result<(), sp_runtime::DispatchError>;
```

This allows you to handle errors in your runtime, and NEVER PANIC!
</script></section><section  data-markdown><script type="text/template">
## Returning an Error

At any point in your call logic, you can return a `DispatchError`.

```rust
ensure!(new_balance >= min_balance, Error::<T, I>::LiquidityRestrictions);
```

When you do, thanks to transactional storage layers, all modified state will be reverted.
</script></section><section  data-markdown><script type="text/template">
## Returning Success

If everything in your pallet completed successfully, you simply return `Ok(())`, and all your state changes are committed, and the extrinsic is considered to have executed successfully.
</script></section><section  data-markdown><script type="text/template">
## Call Index

It is best practice to explicitly label your calls with a `call_index`.

```rust
#[pallet::call_index(0)]
```

This can help ensure that changes to your pallet do not lead to breaking changes to the transaction format.
</script></section><section  data-markdown><script type="text/template">
## Call Encoding

At a high level, a call is encoded as two bytes (plus any parameters):

1. The Pallet Index
1. The Call Index

Pallet Index comes from the order / explicit numbering of the `construct_runtime!`. If things change order, without explicit labeling, a transaction generated by a wallet (like a ledger) could be incorrect!

<aside class="notes"><p>Note that this also implies there can only be 256 calls per pallet due to the 1 byte encoding.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Weight

Each call must also include a `weight` attribute:

```rust
#[pallet::weight(T::WeightInfo::transfer())]
```

We have another lecture on Weights and Benchmarking, but the high level idea is that this weight function tells us how complex the call is, and the fees that should be charged to the user.
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#4A2439" -->

# Questions
</script></section>
    </article>
  </main>

  <script src="./../../../dist/reveal.js"></script>

  <script src="./../../../plugin/markdown/markdown.js"></script>
  <script src="./../../../plugin/highlight/highlight.js"></script>
  <script src="./../../../plugin/zoom/zoom.js"></script>
  <script src="./../../../plugin/notes/notes.js"></script>
  <script src="./../../../plugin/math/math.js"></script>
  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
