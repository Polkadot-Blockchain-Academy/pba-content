<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>FRAME Tips and Tricks</title>
  <link rel="shortcut icon" href="./../../../assets/favicon.ico" />
  <link rel="stylesheet" href="./../../../dist/reset.css" />
  <link rel="stylesheet" href="./../../../dist/reveal.css" />
  <link rel="stylesheet" href="./../../../assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../../assets/img/0-Shared/logo/pba-logo-white.svg"
      alt="PBA Logo">
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# FRAME Tips and Tricks

<aside class="notes"><ul>
<li>A random collection of things that you should probably know about.</li>
<li>These are relevant for coding in FRAME and Substrate.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Part 1 Substrate Stuff
</script></section><section ><section data-markdown><script type="text/template">
## Recap: Blocks, Headers, Extrinsics

- The traits defining what each are in `sp-runtime/traits`
- One, somewhat opinionated set of types that implement these can be found in `sp-runtime/generic`.
</script></section><section data-markdown><script type="text/template">
### `trait Block`, `Header`, `Extrinsic`

- you should be well versed in reading such type aliases:

```rust
use sp_runtime::traits::{Header as HeaderT};
/// Extract the number type for a block.
pub type NumberFor<B> = <<B as Block>::Header as HeaderT>::Number;
```

```rust
trait Block {
  type Header: sp_runtime::traits::Header;
}

trait Header {
  type Number
}
```

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### `trait Block`, `Header`, `Extrinsic`

- Or a common example from FRAME:

```rust
type BalanceOf<T> = <
  <T as Config>::Currency
  as
  Currency<<T as frame_system::Config>::AccountId>
>::Balance;
```
</script></section><section data-markdown><script type="text/template">
## Speaking of Traits..

- What is the difference between generics and associated types?

<div class="fragment">

- Anything that can be expressed with associated types can also be expressed with generics.
- Associated Types << Generics
- Associated types usually lead to less boilerplate.

</div>
</script></section><section data-markdown><script type="text/template">
## Speaking of Traits..

```rust
trait Engine {}
trait Brand {}

trait Car<E: Engine> {
  // brand is possibly the same among all, so make it associate!
  type Brand: Brand;
}

struct Car;
// Car<E1> and Car<E2> are not the same type!
// Car<E1> and Car<E2> could not have different brands.
// fn foo<E: Engine, C: Car<E, Brand = SomeBrand>>() { .. }
```

<aside class="notes"><p>In cambridge, I did this this. But since students should now know traits really well, I will drop it.</p>
<pre><code class="language-rust">trait Engine {
    fn start() {}
}

struct BMW;
impl Engine for BMW {}

trait Brand {
    fn name() -&gt; &amp;&#39;static str;
}

trait Car&lt;E: Engine&gt; {
    type Brand: Brand;
}

struct KianCarCo;
impl Brand for KianCarCo {
  fn name() -&gt; &amp;&#39;static str {
    &quot;KianCarCo!&quot;
    }
}

struct MyCar;
impl&lt;E: Engine&gt; Car&lt;E&gt; for MyCar {
    type Brand = MyBrand;
}

fn main() {
    // Car&lt;E1&gt;, Car&lt;E2&gt; are different traits!

    // Generics can be bounded, or constrained
    // impl&lt;E: Engine&gt; Car&lt;E&gt; {}
    // impl Car&lt;BMW&gt; {}

    // Associated types can:
    // only be bounded when being defined,
    // Can be constrained when being implemented, or when the trait is being used.
    fn some_fn&lt;E: Engine, C: Car&lt;E, Brand = MyBrand&gt;&gt;(car: C) {
      // and we are told associated types are more like output types, lets get the brand of car
      let name = &lt;&lt;C as Car&lt;E&gt;&gt;::Brand as Brand&gt;::name();
    }
    fn other_fn&lt;C: Car&lt;BMW, Brand = MyBrand&gt;&gt;(car: C) {

    }

    // now, check this out
}
</code></pre>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## The `std` Paradigm

- Recap:
  - `std` is the interface to the common OS-abstractions.
  - `core` is a subset of `std` that makes no assumption about the operating system.

> #![no_std] is a crate level attribute that indicates that the crate will link to the `core` crate
> instead of the `std` crate

- [source](https://docs.rust-embedded.org/embedonomicon/smallest-no-std.html)
</script></section><section data-markdown><script type="text/template">
### The `std` Paradigm

- All crates in substrate that eventually compile to Wasm are compiled in a dual mode:

1. with `std`
1. otherwise `no_std`

```rust
#![cfg_attr(not(feature = "std"), no_std)]
```

- The name "`std`" is just an idiom in the rust ecosystem.
- `no_std` does NOT mean Wasm!
- `std` does not mean native!

<aside class="notes"><p>But in substrate, it kinda means like that:</p>
<p>std =&gt; native
no_std =&gt; wasm</p>
</aside></script></section><section data-markdown><script type="text/template">
### The `std` Paradigm: Adding dependencies

```rust
[package]
name = "simple-runtime"
version = "0.1.0"
edition = "2021"

[dependencies]
codec = {
  package = "parity-scale-codec",
  version = "3.0.0",
  default-features = false
}
frame-support = {
  git = "https://github.com/paritytech/substrate",
  branch = "master",
  default-features = false
}

tokio = { git = "...", optional = true }

[dev-dependencies]
sp-io = { git = "https://github.com/paritytech/substrate", branch = "master" }

[features]
default = ["std"]
std = [
  "codec/std",
  "frame-support/std",
]
async-shenanigans = ["tokio"]
```
</script></section><section data-markdown><script type="text/template">
### The `std` Paradigm: Adding dependencies

```sh
error: duplicate lang item in crate sp_io (which frame_support depends on): panic_impl.
  |
  = Notes:
 the lang item is first defined in crate std (which serde depends on)

error: duplicate lang item in crate sp_io (which frame_support depends on): oom.
  |
  = Notes:
 the lang item is first defined in crate std (which serde depends on)
```
</script></section><section data-markdown><script type="text/template">
### The `std` Paradigm

A subset of the standard types in rust that also exist in rust `core` are re-exported from
[`sp_std`](https://paritytech.github.io/substrate/master/sp_std/index.html).

```rust
sp_std::prelude::*;
```

<aside class="notes"><p>Hashmap not exported due to non-deterministic concerns.
floats are usable, but also non-deterministic! (and I think they lack <code>encode</code>, <code>decode</code> impl)</p>
</aside></script></section><section data-markdown><script type="text/template">
### The `std` Paradigm

```rust [1-13|13-100]
#[cfg(feature = "std")]
#[macro_export]
macro_rules! if_std {
	( $( $code:tt )* ) => {
    $( $code )*
	}
}

#[cfg(not(feature = "std"))]
#[macro_export]
macro_rules! if_std {
  ( $( $code:tt )* ) => {};
}

// somewhere in your runtime code
fn foo() {
  sp_std::if_std! {
    // testing, debugging..
    println!("Debug test only printed in wasm and native");
    use std::*;

    // this bricks the chain..
    sp_io::storage::set(b"foo", b"bar");
  }
}
```
</script></section></section><section ><section data-markdown><script type="text/template">
## Logging And Prints In The Runtime.

- First, why bother? let's just add as many logs as we want into the runtime.

<!-- .element: class="fragment" -->

- Size of the wasm blob matters..

<!-- .element: class="fragment" -->

- Any logging increases the size of the Wasm blob. **String literals** are stored somewhere in your
  program!

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Logging And Prints In The Runtime.

- `wasm2wat polkadot_runtime.wasm > dump | rg stripped`

- Should get you the `.rodata` (read-only data) line of the wasm blob, which contains all the logging
  noise.

- This contains string literals form errors, logs, metadata, etc.
</script></section><section data-markdown><script type="text/template">
### Logging And Prints In The Runtime.

```rust
#[derive(RuntimeDebug)]
pub struct WithDebug {
    foo: u32,
}

impl ::core::fmt::Debug for WithDebug {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        #[cfg(feature = "std)]
        {
          fmt.debug_struct("WithRuntimeDebug")
            .field("foo", &self.foo)
            .finish()
        }
        #[cfg(not(feature = "std))]
        {
          fmt.write("<wasm:stripped>")
        }
    }
}
```
</script></section><section data-markdown><script type="text/template">
### Logging And Prints In The Runtime.

Once types implement `Debug` or `RuntimeDebug`, they can be printed. Various ways:

- If you only want something in tests, native builds etc

```rust
sp_std::if_std! {
  println!("hello world!");
  dbg!(foo);
}
```

- Or you can use the common frame-support logging (which is just the `log` crate re-exported):

```rust
frame_support::log::info!(target: "target", "hello world!");
frame_support::log::debug!(target: "target", "hello world! ({})", 10u32);
```
</script></section><section data-markdown><script type="text/template">
### Logging And Prints In The Runtime.

- Log statements are only evaluated if the corresponding level and target is met.

```rust
/// only executed if `RUST_LOG=KIAN=trace`
frame_support::log::trace!(target: "KIAN", "({:?})", (0..100000).into_iter().collect());
```

- `disable-logging` compilation flag blocks all sp-io calls to do any logging. This is used in
  official polkadot releases.

<aside class="notes"><p><code>log</code> in rust does not do anything -- it only tracks what needs to be logged. Then you need a logger
to actually export them. In rust this is often <code>env_logger</code> or <code>sp_tracing</code> in substrate tests.</p>
<p>In the runtime, the log messages are sent via the host functions to the client to be printed.</p>
<p>If the interface is built with <code>disable-logging</code>, it omits all log messages.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Arithmetic Helpers, and the `f32`, `f64` Story.

- Floating point numbers have different standards, and (**_slightly_**) different implementations on
  different architectures and vendors.

- If my balance is `10.000000000000001` DOT on one validator and `10.000000000000000` DOT on another validator, game over for your consensus 😮‍💨.
</script></section><section data-markdown><script type="text/template">
### PerThing.

```python
> .2 + .2 + .2 == .6
> false
```

```
> a = 10
> b = 0.1
> c = 0.2
> a*(b+c) == a*b + a*c
> false
```

- Google "weird float behavior" fro more entertainment around this.
</script></section><section data-markdown><script type="text/template">
### PerThing.

- We store ratios and such in the runtime with "Fixed-Point" arithmetic types.

```rust
struct Percent(u8);

impl Percent {
  fn new(x: u8) {
    Self(x.min(100));
  }
}

impl Mul<u32> for Percent {
  ...
}

```
</script></section><section data-markdown><script type="text/template">
### PerThing.

```rust
use sp_arithmetic::Perbill;

let p = Perbill::from_part_parts(1_000_000_000u32 / 4);
let p = Perbill::from_percent(25);
let p = Perbill::from_rational(1, 4);

> p * 100u32;
> 25u32;
```

- Some precision concerns exist, but that's a story for another day.
</script></section><section data-markdown><script type="text/template">
### Fixed Point Numbers

`Per-thing` is great for representing `[0, 1]` range.

What if we need more?

```
100 ~ 1
200 ~ 2
300 ~ 3
350 ~ 3.5
```
</script></section><section data-markdown><script type="text/template">
### Fixed Point Numbers

```rust
use sp_arithmetic::FixedU64;

let x = FixedU64::from_rational(5, 2);
let y = 10u32;
let z = x * y;
> 25
```
</script></section><section data-markdown><script type="text/template">
### Larger Types

- [`U256`](https://paritytech.github.io/substrate/master/sp_core/struct.U256.html), `U512`: battle-tested since the ethereum days.
- [substrate-fixed](https://github.com/encointer/substrate-fixed): community project. Supercharged `PerThing` and `Fixed`.
- [`big_uint.rs`](https://paritytech.github.io/substrate/master/sp_arithmetic/biguint/index.html) (unaudited)

```rust

pub struct BigUint {
	/// digits (limbs) of this number (sorted as msb -> lsb).
	pub(crate) digits: Vec<Single>,
}
```
</script></section><section data-markdown><script type="text/template">
### Arithmetic Types

- Everything said here can be found in
  [`sp-arithmetic`](https://paritytech.github.io/substrate/master/sp_arithmetic/index.html) and
  `sp-core`, and a lot of it is re-exported from `sp-runtime`
- Because they are used a LOT.
</script></section></section><section ><section data-markdown><script type="text/template">
### Fallibility: Math Operations

Things like **addition**, **multiplication**, **division** could all easily fail.

- Panic

  - `u32::MAX * 2 / 2` (in debug builds)
  - `100 / 0`

- Overflow
  - `u32::MAX * 2 / 2` (in release builds)
</script></section><section data-markdown><script type="text/template">
### Fallibility

- `Checked` -- prevention ✋🏻

  ```
  if let Some(outcome) = a.checked_mul(b) { ... } else { ... }
  ```

- `Saturating` -- silent recovery 🤫

  ```
  let certain_output = a.saturating_mul(b);
  ```

<aside class="notes"><p>Why would you ever want to saturate? only in cases where you know if the number is overflowing,
other aspects of the system is so fundamentally screwed that there is no point in doing any kind of
recovery.</p>
<p>There&#39;s also <code>wrapping_op</code> and <code>carrying_op</code> etc on all rust primitives, but not quite
relevant.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Fallibility: Conversion

- Luckily, rust is already pretty strict for the primitive types.
- `TryInto` / `TryFrom` / `From` / `Into`

- `struct Foo<T: From<u32>>`

T is u32 or larger.

<!-- .element: class="fragment" -->

- `struct Foo<T: Into<u32>>`

`T` is u32 or smaller.

<!-- .element: class="fragment" -->

- `struct Foo<T: TryInto<u32>>`

`T` can be any of numeric types.

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Fallibility: Conversion

- Substrate also provides a trait for infallible saturated conversion as well.
- [source](https://paritytech.github.io/substrate/master/sp_arithmetic/traits/trait.SaturatedConversion.html).

```rust
trait SaturatedConversion {
  fn saturated_into<T>(self) -> T
}

assert_eq!(u128::MAX.saturating_into::<u32>(), u32::MAX);
```
</script></section></section><section  data-markdown><script type="text/template">
# Part 2: FRAME Stuff
</script></section><section ><section data-markdown><script type="text/template">
## `trait Get`

A very basic, yet very substrate-idiomatic way to pass _values_ through _types_.

```rust
pub trait Get<T> {
  fn get() -> T;
}
```

```rust
// very basic blanket implementation, which you should be very versed in reading.
impl<T: Default> Get<T> for () {
  fn get() -> T {
    T::default()
  }
}
```

<!-- .element: class="fragment" -->

```rust
struct Foo<G: Get<u32> = ()>;
```

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### `trait Get`

```rust
parameter_types! {
  pub const Foo: u32 = 10;
}

// expands to:
pub struct Foo;
impl Get<u32> for Foo {
  fn get() -> u32 {
    10;
  }
}
```

- Helps convey **values** using **types**.
</script></section></section><section ><section data-markdown><script type="text/template">
## `bounded`

- `BoundedVec`, `BoundedSlice`, `BoundedBTreeMap`, `BoundedSlice`

```rust
#[derive(Encode, Decode)]
pub struct BoundedVec<T, S: Get<u32>>(
  pub(super) Vec<T>,
  PhantomData<S>,
);
```

- `PhantomData`?
</script></section><section data-markdown><script type="text/template">
### `bounded`

- Food for your thought.

```rust
#[cfg_attr(feature = "std", derive(Serialize))]
#[derive(Encode)]
pub struct BoundedVec<T>(
  pub(super) Vec<T>,
  u32,
);
```
</script></section></section><section ><section data-markdown><script type="text/template">
## `trait Convert`

```rust
pub trait Convert<A, B> {
	fn convert(a: A) -> B;
}
```

```rust
pub struct Identity;
// blanket implementation!
impl<T> Convert<T, T> for Identity {
	fn convert(a: T) -> T {
		a
	}
}
```

<!-- .element: class="fragment" -->

<aside class="notes"><p>this one&#39;s much simpler, but good excuse to teach them blanket implementations.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Example of `Get` and `Convert`

```rust
/// Some configuration for my module.
trait Config {
  /// Something that gives you a `u32`.
  type MaximumSize: Get<u32>;
  /// Something that is capable of converting `u64` to `u32`, which is pretty damn impossible.
  type Convertor: Convertor<u32, u32>;
}
```

```rust
// in your top level runtime.
struct Runtime;
impl Config for Runtime {
  type MaximumSize = (); // remember what this means?
  type Convertor = Identity // remember this guy?
}
```

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Example of `Get` and `Convert`

```rust
// in your pallet
impl<T: Config> Pallet<T> {
  fn foo() {
    let outcome: u32 = T::Convertor::convert(u32::max_value());
  }
}
```
</script></section></section><section ><section data-markdown><script type="text/template">
## Implementing Traits For Tuples

```rust
struct Module1;
struct Module2;
struct Module3;

trait OnInitialize {
  fn on_initialize();
}

impl OnInitialize for Module1 { fn on_initialize() {} }
impl OnInitialize for Module2 { fn on_initialize() {} }
impl OnInitialize for Module3 { fn on_initialize() {} }
```

How can I easily invoke `OnInitialize` on all 3 of `Module1, Module2, Module3`?

<aside class="notes"><p>take this to rust playground.</p>
<p>add:</p>
<p>trait OnInitializeDyn {
fn on_initialize(&amp;self);
}</p>
<p>impl OnInitializeDyn for Module1 { fn on_initialize(&amp;self) {} }
impl OnInitializeDyn for Module2 { fn on_initialize(&amp;self) {} }
impl OnInitializeDyn for Module3 { fn on_initialize(&amp;self) {} }</p>
<p>fn main() {
// let x = vec![Module1, Module1, Module1];
// let x: Vec&lt;Box<dyn OnInitialize>&gt; = vec![Box::new(Module1), Box::new(Module2)];
let x: Vec&lt;Box<dyn OnInitializeDyn>&gt; = vec![Box::new(Module1), Box::new(Module2)];
x.for_each(|i| i.on_initialize())
x.for_each(OnInitialize::on_initialize)
}</p>
</aside></script></section><section data-markdown><script type="text/template">
### Implementing Traits For Tuples

1. `on_initialize`, in its ideal form, does not have `&self`, it is defined on the **type**, not a **value**.

1. **Tuples** are the natural way to group **types** together (analogous to have a **vector** is the natural way to group **values** together..)

```rust
// fully-qualified syntax - turbo-fish.
<(Module1, Module2, Module3) as OnInitialize>::on_initialize();
```
</script></section><section data-markdown><script type="text/template">
### Implementing Traits For Tuples

Only problem: A lot of boilerplate. Macros!

Historically, we made this work with `macro_rules!`

<aside class="notes"><pre><code class="language-rust">macro_rules! impl_for_tuples {
    ( $( $elem:ident ),+ ) =&gt; {
        impl&lt;$( $elem: OnInitialize, )*&gt; OnInitialize for ($( $elem, )*) {
            fn on_initialize() {
                $( $elem::on_initialize(); )*
            }
        }
    }
}

impl_for_tuples!(A, B, C, D);
impl_for_tuples!(A, B, C, D, E);
impl_for_tuples!(A, B, C, D, E, F);
</code></pre>
</aside></script></section><section data-markdown><script type="text/template">
### Implementing Traits For Tuples

And then someone made `impl_for_tuples` crate.

```rust
// In the most basic form:
#[impl_for_tuples(30)]
pub trait OnTimestampSet<Moment> {
	fn on_timestamp_set(moment: Moment);
}
```
</script></section></section><section ><section data-markdown><script type="text/template">
## Defensive Programming

> Defensive programming is a form of defensive design intended to ensure the continuing function of
> a piece of software under unforeseen circumstances. Defensive programming practices are often
> used where **high availability**, **safety**, or **security** is needed.

- As you know, you should (almost) never panic in your runtime code.
</script></section><section data-markdown><script type="text/template">
### Defensive Programming

- First reminder: don't panic, unless if you want to punish someone!
- `.unwrap()`? no no

<br/>

- be careful with implicit unwraps in standard operations!
  - slice/vector indexing can panic if out of bound
  - `.insert`, `.remove`
  - division by zero.
</script></section><section data-markdown><script type="text/template">
### Defensive Programming

- When using operations that could panic, comment exactly above it why you are sure it won't panic.

```rust
let pos = announcements
  .binary_search(&announcement)
  .ok()
  .ok_or(Error::<T, I>::MissingAnnouncement)?;
// index coming from `binary_search`, therefore cannot be out of bound.
announcements.remove(pos);
```
</script></section><section data-markdown><script type="text/template">
### Defensive Programming: QED

Or when using options or results that need to be unwrapped but are known to be `Ok(_)`, `Some(_)`:

```rust
let maybe_value: Option<_> = ...
if maybe_value.is_none() {
  return "..."
}

let value = maybe_value.expect("value checked to be 'Some'; qed");
```

- Q.E.D. or QED is an initialism of the Latin phrase "quod erat demonstrandum", meaning "**which was to be demonstrated**".
</script></section><section data-markdown><script type="text/template">
### Defensive Programming

When writing APIs that could panic, explicitly document them, just like the core rust documentation.

```rust
/// Exactly the same semantics as [`Vec::insert`], but returns an `Err` (and is a noop) if the
/// new length of the vector exceeds `S`.
///
/// # Panics
///
/// Panics if `index > len`.
pub fn try_insert(&mut self, index: usize, element: T) -> Result<(), ()> {
  if self.len() < Self::bound() {
    self.0.insert(index, element);
    Ok(())
  } else {
    Err(())
  }
}
```
</script></section><section data-markdown><script type="text/template">
### Defensive Programming

- Speaking of documentation, [here's a very good guideline](https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html)!

````rust
/// Multiplies the given input by two.
///
/// Some further information about what this does, and where it could be used.
///
/// ```
/// fn main() {
///   let x = multiply_by_2(10);
///   assert_eq!(10, 20);
/// }
/// ```
///
/// ## Panics
///
/// Panics under such and such condition.
fn multiply_by_2(x: u32) -> u32 { .. }
````
</script></section><section data-markdown><script type="text/template">
### Defensive Programming

- Try and not be this guy:

```rust
/// This function works with module x and multiples the given input by two. If
/// we optimize the other variant of it, we would be able to achieve more
/// efficiency but I have to think about it. Probably can panic if the input
/// overflows u32.
fn multiply_by_2(x: u32) -> u32 { .. }
```
</script></section><section data-markdown><script type="text/template">
### Defensive Programming

- The overall ethos of defensive programming is along the lines of:

```rust
// we have good reasons to believe this is `Some`.
let y: Option<_> = ...

// I am really really sure about this
let x = y.expect("hard evidence; qed");

// either return a reasonable default..
let x = y.unwrap_or(reasonable_default);

// or return an error (in particular in dispatchables)
let x = y.ok_or(Error::DefensiveError)?;
```

- But, for example, you are absolutely sure that `Error::DefensiveError` will never happen, can we enforce it better?
</script></section><section data-markdown><script type="text/template">
### Defensive Programming

```rust
let x = y
  .map_err(|e| {
    #[cfg(test)]
    panic!("defensive error happened: {:?}", e);

    log::error!(target: "..", "defensive error happened: {:?}", e);
  })
  .ok_or(Error::DefensiveError)?;
```
</script></section><section data-markdown><script type="text/template">
### Defensive Programming

- Yes: [Defensive traits](https://paritytech.github.io/substrate/master/frame_support/traits/trait.Defensive.html):

```
// either return a reasonable default..
let x = y.defensive_unwrap_or(reasonable_default);

// or return an error (in particular in dispatchables)
let x = y.defensive_ok_or(Error::DefensiveError)?;
```

It adds some boilerplate to:

1. Panic when `debug_assertions` are enabled (tests).
1. append a `log::error!`.
</script></section></section><section  data-markdown><script type="text/template">
## Additional Resources! 😋

<img width="300px" rounded src="../../../assets/img/4-Substrate/thats_all_folks.png" />

> Check speaker notes (click "s" 😉)

> Good luck with FRAME!

<aside class="notes"><ul>
<li><p>Rust didn&#39;t have u128 until not too long ago! <a href="https://github.com/paritytech/substrate/pull/163/files">https://github.com/paritytech/substrate/pull/163/files</a></p>
</li>
<li><p><code>TryFrom</code>/<code>TryInto</code> are also not too old! <a href="https://github.com/paritytech/substrate/pull/163/files#r188938077">https://github.com/paritytech/substrate/pull/163/files#r188938077</a></p>
</li>
<li><p>Remove <code>As</code>, which tried to fill the lack of <code>TryFrom/TryInto</code> <a href="https://github.com/paritytech/substrate/pull/2602">https://github.com/paritytech/substrate/pull/2602</a></p>
</li>
<li><p>Runtime Logging PR: <a href="https://github.com/paritytech/substrate/pull/3821">https://github.com/paritytech/substrate/pull/3821</a></p>
</li>
<li><p>Impl trait for tuples:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/64332037/how-can-i-store-a-type-in-an-array">https://stackoverflow.com/questions/64332037/how-can-i-store-a-type-in-an-array</a></li>
<li><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch</a></li>
<li><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name</a></li>
<li><a href="https://turbo.fish/">https://turbo.fish/</a></li>
<li><a href="https://techblog.tonsser.com/posts/what-is-rusts-turbofish">https://techblog.tonsser.com/posts/what-is-rusts-turbofish</a></li>
<li><a href="https://docs.rs/impl-trait-for-tuples/latest/impl_trait_for_tuples/">https://docs.rs/impl-trait-for-tuples/latest/impl_trait_for_tuples/</a></li>
</ul>
</li>
<li><p>std/no_std</p>
<ul>
<li><a href="https://paritytech.github.io/substrate/master/sp_std/index.html">https://paritytech.github.io/substrate/master/sp_std/index.html</a></li>
<li><a href="https://doc.rust-lang.org/core/index.html">https://doc.rust-lang.org/core/index.html</a></li>
<li><a href="https://doc.rust-lang.org/std/index.html">https://doc.rust-lang.org/std/index.html</a></li>
<li><a href="https://rust-lang.github.io/api-guidelines/naming.html#feature-names-are-free-of-placeholder-words-c-feature">https://rust-lang.github.io/api-guidelines/naming.html#feature-names-are-free-of-placeholder-words-c-feature</a></li>
</ul>
</li>
</ul>
<h3 id="feedback-after-lecture">Feedback After Lecture:</h3>
<ul>
<li>Lecture is still kinda dense and long, try and trim</li>
<li>Update on defensive ops: <a href="https://github.com/paritytech/substrate/pull/12967">https://github.com/paritytech/substrate/pull/12967</a></li>
<li>Next time, talk about making a storage struct be <code>&lt;T: Config&gt;</code>.</li>
<li>Cargo format</li>
</ul>
</aside></script></section>
    </article>
  </main>

  <script src="./../../../dist/reveal.js"></script>

  <script src="./../../../plugin/markdown/markdown.js"></script>
  <script src="./../../../plugin/highlight/highlight.js"></script>
  <script src="./../../../plugin/zoom/zoom.js"></script>
  <script src="./../../../plugin/notes/notes.js"></script>
  <script src="./../../../plugin/math/math.js"></script>
  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
