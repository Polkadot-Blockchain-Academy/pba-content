# Hash based data structures

---

## Hash linked structures


---
### comparison to pointer based data structures
 - a hash is a commitment to what is in the linked part
 	- a pointer tells you where it is
 - we can't have cycles of hashes

---
### Hash chains

<!-- pretty picture goes here -->


---
### Merkle trees

A binary Merkle tree:

<!-- pretty picture goes here of small Merkle tree-->

---

### proofs

- the root or head hash is a commitment to the enite data struture

- generate a proof by expanding some but not all hashes

---

### proofs: Merkle copaths

<!-- pretty picture goes here of Merkle copath-->

Notes:

Given the children of a node, we can compute a node

Given the purple nodes and the white leaf, we can compute the white nodes bottom to top.

If we compute the correct root, this proves that the leaf wass in the tree

---

### security

- collision resistance
	- can give only-one preimage for each hash
	- so a binding commitment to the link
	
Notes: explain what could happen when this fails.

---

- proof of a leaf has size $O(\log n)$
- and so do proofs of updates of a leaf


## Key-value databases and tries

---

### Key-value database

The data structure stores a map 
`key -> value`

We should be able to 

1. add new `<key,value>` pairs

2. change the value associated with an existing key.

3. For any key, if `<key,value>` is in the database, we can prove it.

4. If no value is associated to a key, we need to be able to prove that as well

---
### Tries 

<!-- Trie picture. https://en.wikipedia.org/wiki/Trie#/media/File:Trie_example.svg is public domain -->

---

### Hash trie (maybe pointer based)

 - A trie where we use prefixes of the hash of the key
 - Improves balance
     - except under attack!

---

### basic radix trie

- each node splits on the next digit in base r

---
### Patricia Trie

- as radix, but if there is only one option for a sequence of digits, we can merge them.

<!-- maybe some code stuff with extension nodes etc. -->
<!-- could do with a picture here -->

---

### Computational and storage trade-offs

- What radix $r$ is best?

- proof size of a leaf is $r \log_r n$
	- $r=2$ gives the smallest proof for one leaf

- but
	- higher branching at high levels of the tree can give smaller batch proofs.
	- For storage, it is best to read consecutive data so high $r$ is better.
	



---
	
### Merkle Mountain Ranges

- append only data structure

- lookup elements by number

---

<!-- picture of an unbagged MMR of size 13-->
<widget-image src="/assets/img/1-Cryptography/u-mmr-n-13.svg"></widget-image>

Notes: 

we have several Merkle trees of sizes that are powers of two. 

The trees that are here correspond to the binary digits of 13 that are 1.

---

<!-- picture of an unbagged MMR of size 14-->

---

<!-- picture of an bagged MMR of size 13-->



---

- Not as balanced as a binary tree but close

- can update the peak nodes alone on-chain

---

### Succinct proving with cryptography?
- ZK friendly hashes
- Non-hased based data structures
	- RSA accumulators
	- Polynomial commitment based
		- Verkle trees