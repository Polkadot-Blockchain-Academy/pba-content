---
title: Introduction to Cryptography for Web3 Engineers
description: Cryptographic primitives for Web3 engineers
duration: 1 hour
instructors: ["Gavin Wood"]
teaching-assistants: ["Dan Shields"]
---

# Introduction to Cryptography

## For Web3 Engineers

### _Module 1, Lecture 1_

<widget-speaker small name="Gavin Wood" position="Founder Parity & Web3 Foundation" image="/assets/img/0-Shared/people/gav.png"></widget-speaker>

---

<widget-speaker name="Gavin Wood" position="Founder Parity & Web3 Foundation" image="/assets/img/0-Shared/people/gav.png" github="gavofyork" twitter="gavofyork" linkedin="gavin-wood-88843316" matrix="gav:matrix.parity.io"></widget-speaker>

<!--

## Outline

1. [Pre-requisites](#pre-requisites)
1. [Goals for this Lesson](#goals-for-this-lesson)
1. [Encryption](#encryption)
1. [Cryptographic Guarantees](#cryptographic-guarantees)
1. [Digital Signatures](#digital-signatures)
1. [Hash Functions](#hash-functions)
1. [Summary](#summary)

-->
<!-- TODO fix the internal links, there is some bug where they don't work -->

---

## Pre-requisites

No background in theoretical or applied cryptography is necessary.

College level mathematical maturity in algebra and probability is helpful.

---

## Goals for this Lesson

- Understand the goals of cryptography
- Understand some network and contextual assumptions
- Learn what expectations cryptography upholds
- Learn primitives specific to Substrate and Polkadot

---

## Encryption

---v

### Encryption - Operating Context

**The internet is a public space.**

People and organizations communicate over public channels.
There exist adversaries who may want to:

- Read messages not intended for them
- Impersonate others
- Tamper with messages

note:

ASK STUDENTS: participate with examples of application messages, not just person-to-person messages.

Some examples:

- An attacker may impersonate your boss, trying to get you to send them money
- An attacker may change instructions, e.g. 100 EUR transfer to 10000 EUR

---v

### Encryption - Operating Context

**Many resources are constrained**

- Network, storage, computation, etc.: We don't want to send, store, or operate on the same data, but we want guarantees about it, e.g. that we agree on a message's contents.
- Privacy: We must assume that all channels can be monitored, and thus closed channels are heavily constrained (i.e. assumed to not exist).

---v

### Encryption - Open vs. Closed Channels

**Cryptography based on public systems is more sound anyway.**

**Kerckhoff's Principle:** Security should not rely on secret _methods_, but rather on secret _information_.

- Methods can be reverse engineered.

- We always work with public, open protocols.

note:

After rev. eng., the communication channel is completely insecure.
For example, CSS protection for DVDs.

---

## Cryptographic Guarantees

---v

### Cryptographic Guarantees

**Cryptography provides methods for communicating securely in the open.**

**Encryption is just one use of cryptography;**
**It also provides other powerful guarantees:**

- Data accessibility (encryption)
- Message authenticity
- Data integrity
- Non-repudiation<sup>[\[1\]](https://en.wikipedia.org/wiki/Non-repudiation)</sup>

---v

### Data Accessibility

A party may gain access to some information (the "plaintext") if and only if they know some secret (a **key**).

```text
   Cryptographic
     Primitives
         /\
Symmetric  Asymmetric
```

<!-- TODO DESIGN: Diagram / table above-->

Symmetric: the secret _must_ be known to the originator.

Asymmetric: the secret _need not_ be known to the originator.

notes:
Symmetric: two parties may establish and share a single secret to encrypt and decrypt messages.
Asymmetric: Instead, the recipient can share some counterpart of the secret that does not reveal the secret itself.
That is, this counterpart (the public key) is secure to share publicly.

"The ability to decrypt some data and reveal its underlying information directly implies knowledge of some secret, potentially unknown to the originator of the information.
Supplying the original information (aka plain text message) can be used in a "challenge game" mechanism as one means of proving knowledge of the secret without compromising it." -Gav

---v

### Message Authenticity

Like physical signatures, cryptography may be used to give a reasonable expectation of a message's provenance (origin), in order to give the users the credible expectation that the stated origin is authentic.

- Digital signatures should be difficult (practically speaking: impossible) to forge.
- Digital signatures should verify that the signer knows some secret, without revealing the secret itself.

---v

### Data Integrity

Any change to a message should render its signature invalid.

Physical signatures provide weak authenticity guarantees (i.e. they are quite easy to forge), and no integrity guarantees.
For example, if you change the year on your university diploma, the dean's signature is still valid.
Digital signatures provide a guarantee that the signed information has not been tampered with.

<!-- TODO DESIGN: Diagram -->

---v

### Symmetric Cryptography

```text
Alice -> [encrypt] -> {the internet} -> [decrypt] -> Bob
^ ^
k k
```

<!-- TODO DESIGN: Diagram-->

Example: AES, XOR cipher

---v

### Symmetric Cryptography Example: XOR Cipher

Very simple cipher where the encryption and decryption functions are identical.

A plaintext can be converted to ciphertext, and vice versa, by applying a bitwise XOR operation with a key known to both parties.

```text
Plain: 1010  -->Cipher: 0110
Key:   1100  |          1100
       ----  |          ----
       0110--^          1010
```

---v

### Symmetric Cryptography

We typically expect symmetric cryptography to preserve little about the original plaintext.
We caution however that constructing these protocols remains delicate, even given secure primitives, with two classical examples being unsalted passwords and the [ECB penguin](https://tonybox.net/posts/ecb-penguin/).

<!-- TODO DESIGN: picture of the poorly-encrypted penguin?-->

---v

### One-Way Functions

One-way functions form the basis of asymmetric cryptography.

- Functions for which we know fast algorithms to compute,
- But for which we believe to be hard to invert without the knowledge of some secret.

There are a lot of assumptions about why these functions are hard to invert, but we cannot rigorously prove it.
We often express inversion problems in terms of mathematical games or oracles.

---v

### Asymmetric Cryptography

In asymmetric cryptography, we pass secrets through functions that preserve algebraic properties of the secret, but yield a public counterpart to the secret.

This counterpart (the "public key") is strictly derivable from the other (the secret), without revealing any information about the secret.

Using only the public key, information can be encrypted such that only those with knowledge of the secret can access it.

---v

### Asymmetric Protocols

- Asymmetric cryptraphy includes RSA, Elgamal, Elliptic Curve (slowest to fastest)
- Elliptic Curves (ECC) used in Polkadot/Substrate:
  - secp256k1/ecdsa
  - sr25519
  - ed25519
- ECC requires double the bits to the symmetric AES for the same level of security.
  E.g. 128 bit security requires a 256 bit ECC key.

notes:
Discuss misuse resistance and motivation for support here.
Or could be in more runtime focused lesson?

- ECDSA: Lots of foot guns, but we support for legacy Ethereum compatibility
- Ed25519: Some misuse / insecure libraries, e.g. [this tweet](https://twitter.com/kostascrypto/status/1537245592019054593)
- Sr25519: Reduces misuse risks, but mainly has adoption in Substrate ecosystem

---v

### Practical Considerations

Symmetric cryptography is much faster, but requires more setup (key establishment) and trust (someone else knows the secret).

Asymmetric cryptography is slow, but typically preserves specific algebraic relationships, which then permits more diverse if fragile protocols.

---v

### Hybrid Cryptography

Hybrid cryptography mixes symmetric and asymmetric cryptography.

- Symmetric encryption can provide speed, and often confidentiality,
- And asymmetric can dictate relations among the participants.

---v

### Commutative En-/Decryption

In a commutative structure, a message may be encrypted/decrypted multiple times with potentially multiple keys.

The output does not depend on the order of operations.

<!-- TODO CONTENT:
Mixing paint example https://upload.wikimedia.org/wikipedia/commons/4/46/Diffie-Hellman_Key_Exchange.svg
-->

---v

### Commutative En-/Decryption

Encrypting a message with key $A$, and then encrypting the ciphertext with key $B$, would result in the same ciphertext had one encrypted with $B$ and then $A$.

\begin{align}
M &=> E_A(E_B(M)) == E_B(E_A(M)) => C \\\\
C &=> D_A(D_B(C)) == D_B(D_A(C)) \ => M
\end{align}

Elliptic curve cryptography is based on [commutative algebraic](https://en.wikipedia.org/wiki/Commutative_algebra) structures.

---

## Digital Signatures

---v

### Digital Signatures

**Digital signatures provide message authenticity and integrity guarantees.**

The next two lectures are dedicated to digital signatures, this is strictly an introduction.

---v

### Digital Signatures

<!-- TODO CONTENT: make this into a slide, not a paragraph to read. -->

A _signing function_ is a pure function which operates on some _message_ data (which may or may not be small, depending on the function) and some _secret_ (a small piece of information known only to the operator).
The result of this function is a small piece of data called a _signature_.
It has a special property: it proves (beyond reasonable doubt) that the signer (i.e. operator of the signing function) had knowledge of the secret and utilized this knowledge with the specific _message_ data, yet it does not reveal the secret itself, nor can knowledge of the signature be used to create other signatures (e.g. for alternative message data).

In this model, secrets are identified not by their actual data (which we assume only the signer knows) but rather a derivative counterpart (known as the _public key_) which maps 1:1 with the secret (and so can be used to identify it), yet does not compromise it.

---v

### Digital Signatures on Plaintext

Digital signatures are not limited to encryption.
Some information you even want to share publicly.

Example: Instructions to transfer 10 tokens to another account.

Digital signatures still guarantee that the message is authentic and has not been modified (e.g. to 100 tokens).

---v

### Digital Signatures & Non-repudiation

Only those with knowledge of some secret information could have produced a valid signature.

The signer cannot claim that the signature was forged, unless they can defend a claim that the secret was compromised prior to signing.

Symmetric cryptography does not provide this guarantee: someone else knows the secret.

---v

### Digital Signatures in Practice

In Substrate and Polkadot, we use ECDSA, ed25519, and sr25519.

Of course a valid signature is a valid signature, and there are lots of libraries.
Some specific to Polkadot/Substrate:

- Subkey<sup>[\[2\]](https://docs.substrate.io/reference/command-line-tools/subkey/)</sup> (CLI)
- Substrate Primitives<sup>[\[3\]](https://github.com/paritytech/substrate/tree/master/primitives)</sup> (runtime)
- Polkadot JS Crypto<sup>[\[4\]](https://github.com/polkadot-js/api)</sup> (applications)

---v

### Digital Signatures & Certifications

Certifications are used to make attestations about public key relationships.

Typically in the form of a _signature_ on:

- One or more cryptographically strong identifiers (e.g. public keys, hashes).
- Information about its ownership, its use and any other properties that the signer is capable of attesting/authorizing/witnessing.
- _(Meta-)information_ about this information itself, such as how long it is valid for and external considerations which would invalidate it.

---v

### Certifications in Substrate

Practically speaking, in Substrate we will use certifications to:

- Associate physical hardware with on-chain accounts (called session keys)
- Link disparate and potentially keyless on-chain accounts in certain contexts (proxies)

---

## Hash Functions

---v

### Hash Functions

**Motivation: We often want a succinct representation of some data with the expectation that we are referring to the same data.**
**A "fingerprint".**

Again, just an introduction.
There are lectures dedicated to hashes and hash-based data structures.

---v

### Hash Function Applications

Hashes can be useful for many applications. Examples:

- Representation of larger data object (history, commitment, file)
- Keys in a database
- Digital signatures
- Key derivation
- Pseudorandom functions

---v

### Hash Function Properties

Hashes need to:

1. Accept unbounded size input
1. Map to a bounded output
1. Be fast to compute
1. Be computable strictly one-way (difficult to find a pre-image for a hash)
1. Resist pre-image attacks (attacker controls one input)
1. Resist\* collisions (attacker controls both inputs)

\*Based on the first two properties, _there must exist_ infinite collisions.
A.k.a. Dirichlet's Drawer Principle, a.k.a. pigeonhole principle.

<!-- TODO DESIGN: Diagram-->

---v

### Hash Function Input Sensitivity

Changes to a hash are not related to the magnitude of change in the input.
Example:

<!-- TODO DESIGN: made this into a nice diagram-->

The Economist: “My bicycle”, she assured him, “awaits me.”
Blake2 Hash: `0x160d9d90cf984ad64ab36b2de20292ddd1b8b30f9246f1baa1b117321db2d491`

AP Style: “My bicycle,” she assured him, “awaits me.”
Blake2 Hash: `0x29804282a827a3c1b02b600e36ea8cd0fe8b69213cb6e18da651150101016155`

---v

### Cryptographic vs. Non-Cryptographic Hash Functions

Cryptographic hash functions provide stronger guarantees on the last three properties.

But non-cryptographic hash functions are much faster.

Substrate uses both (more on that later).

---v

### Hash Functions & Signatures

Signing large amounts of data is inefficient.
But hashing large amounts of data _is_.

Based on pre-image resistance, a signature on the hash of some data implies a signature on the data itself.
That is, we assume that attackers are unable to find or construct some data that would generate the same output hash.

Requires that the verifier also compute the hash.

<!--
TODO: new content

Useful class exercise: discuss some reasons why the 6 listed hash properties are so important now:
- If an attacker can find a colliding pre-image, they can "authorize" something unintended.
- Or if they can find a collision on their own, attempt to trick you into signing one.

-->

<!-- TODO DESIGN: Diagram-->

---v

### Hash Functions in Substrate

**Sr25519 Signatures**

Sr25519 hashes the message as part of its signing process.

**Transactions**

In transactions in Substrate, key holders sign a _hash of the instructions_ when the instructions are longer than 256 bytes.

---v

### Hash Functions in Substrate

Substrate primarily uses two hashing algorithms:

- Blake2b (cryptographic)
- TwoX64 (non-cryptographic)

TwoX64 is about 20x faster.

<!-- TODO CONTENT: insert truncated table https://github.com/Cyan4973/xxHash#benchmarks -->
<!-- TODO DESIGN? ^^ -->

---v

### Hash Functions & Database Keys

TwoX64 is safe to use when users (read: attackers) cannot control the input, e.g. when the database key is a system-assigned index.

Blake2b should be used for everything else.

There is a whole lecture on hash-based data structures.

---v

### Hash Functions - Other Uses in Substrate

Hashes are also used for:

- Generating multisig accounts
- Generating system-controlled accounts
- Generating proxy-controlled accounts
- Representing proposals
- Representing claims (e.g. the asset trap)

---

## Summary

Cryptography is much more than encryption
It's a toolkit that allows us to:

- Communicate on public networks, in the open
- Access information
- Have expectations about a message's authenticity and integrity
- Prove knowledge of some secret information
- Represent large amounts of data succinctly

---

## References

\[1\] - <https://en.wikipedia.org/wiki/Non-repudiation>
\[2\] - <https://docs.substrate.io/reference/command-line-tools/subkey/>
\[3\] - <https://github.com/paritytech/substrate/tree/master/primitives>
\[4\] - <https://github.com/polkadot-js/api>
