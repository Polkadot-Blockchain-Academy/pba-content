---
title: Introduction to Cryptography for Web3 Engineers
description: Cryptographic primitives for Web3 engineers
duration: 1 hour
instructors: ["TBA", "Pratyush Ranjan Tiwari"]
teaching-assistants: ["Dan Shields"]
---

# Introduction to Cryptography

---

<!-- Some working notes for me (Joe), probably to be removed from final draft

### Outline / Notes

#### Contextual Assumtions

- People, systems, etc. communicate in the open. That is, we should assume that anyone, not only our intended recipient, may:
  - Read our messages
  - Try to tamper with them
  - Try to impersonate us
  - & c.
- _Why_ do people communicate in the open?
  - Kerckhoffs's Principle: If security depends on secret _methods_, they can easily be reverse engineered (e.g. CSS for DVDs).
  - Security should depend on possession of secret _information_, with open methods.
- Therefore, we'd like some guarantees:
  - Data authenticity (origin, provinence): If you receive a message from me, you know it's from me.
  - Data integrity: You know that it has not been tampered with.
  - (Optional) Data accessibility: We share an expectation that only those who possess some secret information can access the data in a meaningful way. (Let's not get too carried away here, e.g. analyzing what one can glean from ciphertext exchange (e.g. "these two parties exchange frequent long messages").)
  - Nonrepudiation: (Asymmetric only), the signer of a message cannot deny signing it. E.g. "I didn't authorize that transfer" is not a legitimate claim in a cryptographic system.

#### Working with constrained resources

- Several resources are constrained in practice:
  - Network, storage, etc. are limited
  - It's wasteful to send the same data again and again
  - But we want to know that we're talking about the same data
  - If we have a "fingerprint" of the data, it'd be useful as a reference to it as well
- Hash functions
  - Succinct representation of some pre-image with the expectation that we are referring to the same pre-image (larger data set, history, commitment).
  - Map an infinite domain to a finite domain, but we assume collission resistance
  - Cryptographic vs. Non-cryptographic:
    - Cryptographic is slower, but provides stronger guarantees on collission resistance

#### Practice

- Symmetric vs. Asymmetric crypto
  - Examples of each
  - Tradeoffs: key exchange, speed
  - Gav: "There are two separate pieces of data in asymmetric crypto, but one is strictly implied and derivable from the other so the use of the word "needs" is a bit weird. It needs one: the secret. From this secret you can get the other. Asymmetric encryption makes use of a derivable counterpart datum (aka the public key) to the secret, knowledge of which does not imply knowledge of the secret, but may be used to transform data in such a way that it cannot be recovered without the secret."
  - Asymmetric:
    - RSA, Elgamal, ECC (slowest to fastest for given security level)
    - We're mostly concerned with secp256k1/ecdsa, ed25519, sr25519 (specifics later)
    - EC requires 2x bits to AES (symmetric) for same bit security. E.g. 128 bit security requires 256 bit EC key. Of course this makes it a bit slower to operate on than symmetric systems, but comes with the asymmetric advantage of keeping the private key private.
- Encrypting Data
  - Stream vs. block ciphers
  - Encryption is only one use of cryptography.
  - Also Gav: "The ability to decrypt some data and reveal its underlying information directly implies knowledge of some secret, potentially unknown to the originator of the information. Supplying the original information (aka plain text message) can be used in a "challenge game" mechanism as one means of proving knowledge of the secret without compromising it. Typically though, this is done through digital signatures (coming next)."
- Digital signatures
  - Function on some data, using some secret information, that provides a "signature" such that a third party can reasonably verify possession of some secret information by the signer, without the signer revealing it, i.e. using only the data, the signature, and some public information.
  - This provides provenance guarantees: nobody is impersonating the signer.
  - Further, this provides integrity guarantees: even if the signed data is in plaintext, the verifier knows that the information has not been tampered with by any intermediate party.
  - Symmetric vs. Asymmetric
    - Problem with symmetric (shared key): If two parties don't trust each other, they can blame the other for signing a message for them.
    - Asymmetric cryptography provides nonrepudiation: Only the possessor of some information presumed to be known to one party can produce a valid signature on some data. In asymmetric crypto, only one party possesses the secret.
  - Types used in Substrate: sr25519, ed25519, ecdsa
- Hash functions
  - Used for key derivation, digital signatures, PRNGs
    - Typically only sign 256 B of data. If a message is longer than that, we sign the hash.
    - "PRNG" => In Substrate, we use for things like generating keyless accounts
  - Secure vs. insecure => when an attacker can mine hashes to lopside a data structure
  - Substrate uses Blake2b (cryptographic) and TwoX64Concat (non-cryptographic)
    - TwoX is about 20x faster (source: https://github.com/Cyan4973/xxHash#benchmarks)
    - TwoX is safe when a user (read: attacker) cannot control keys, e.g. a system-assigned index.
    - Blake2b should be used for everything else.
  - Serve as keys in a database
  - Many data structures based on hashing (state trie, blockchain itself, some accounts)
- Erasure Coding
  - Need to introduce in this lecture? Or too early?
- Don't roll your own => it can probably be broken
- Attackers will always go for the weakest link => large key space does not equal security

#### Ideas for exercises:

- List modern applications of cryptography (https, bank cards, medical implants, etc.)
- List historical cryptography (substitution cipher) and weaknesses
- List attacks (brute force, probabilistic, social, implementation, etc.)
- Exercises with subkey or Polkadot JS
  - Generate keypairs on different curves
  - Sign/verify some messages
  - No need to get into addresses/extrinsics at this point
  - Just to get familiarity with Substrate tooling

-->

---

### Introduction to Cryptography

Goals for this lesson:

- Understand the goals of cryptography
- Understand some network and contextual assumptions
- Learn what expectations cryptography upholds
- Learn primitives specific to Substrate and Polkadot

---

### Operating Context

**The internet is a public space.**

People and organizations communicate over public channels. There exist adversaries who may want to:

- Read messages not intended for them
- Impersonate others
- Tamper with messages

<!-- Some examples:

- An attacker may impersonate your boss, trying to get you to send them money
- An attacker may change instructions, e.g. 100 EUR transfer to 10000 EUR

Probably best for the teacher to ask students to participate with examples of application messages,
not just person-to-person messages.

-->

---

### Open vs. Closed Channels

Why communicate in public space in the first place?

**Kerckhoff's Principle:** Security should not rely on secret _methods_, but rather on secret _information_.

- Methods can be reverse engineered. After that, the communication channel is completely insecure. For example, CSS protection for DVDs.
- We always work with public, open protocols.

---

### Cryptographic Guarantees

**Cryptography provides methods for communicating securely in the open.**

**Encryption is just one use of cryptography. It also provides other powerful guarantees.**

- Data accessibility (encryption)
- Data authenticity
- Data integrity
- Nonrepudiation (later)

---

### One-Way Functions

- Functions for which we know fast algorithms to compute,
- But for which we believe to be hard to invert without the possession of some secret.
- Broadly, these functions divide into symmetric and asymmetric cryptography.

<!--Speaker notes:
There are a lot of assumptions about why these functions are hard to invert, but we cannot rigorously prove it. We often express inversion problems in terms of mathematical games or oracles.
-->

---

### Data Accessibility

A party may gain access to some information (the "plaintext") if and only if they possess some secret (a key).

<!-- Diagram / table-->
    Cryptographic
      Primitives
          /\
Symmetric    Asymmetric

In symmetric encryption, the secret must be known to the originator. E.g. two parties may establish and share a single secret to encrypt and decrypt messages.

In asymmetric encryption, the secret need not be known to the originator. Instead, the recipient can share some counterpart of the secret that does not reveal the secret itself. That is, this counterpart (the public key) is secure to share publicly.

<!--Speaker notes:
"The ability to decrypt some data and reveal its underlying information directly implies knowledge of some secret, potentially unknown to the originator of the information. Supplying the original information (aka plain text message) can be used in a "challenge game" mechanism as one means of proving knowledge of the secret without compromising it." -Gav
-->

---

### Data Authenticity

Like physical signatures, cryptography should give a reasonable expectation of a message's provenance (origin).

- Digital signatures should be difficult (practically speaking: impossible) to forge.
- Digital signatures should verify that the signer possesses some secret, without revealing the secret itself.

---

### Data Integrity

Any change to a message should render its signature invalid.

Physical signatures provide weak authenticity guarantees (i.e. they are quite easy to forge), and no integrity guarantees. For example, if you change the year on your university diploma, the dean's signature is still valid. Digital signatures provide a guarantee that the signed information has not been tampered with.

<!-- Diagram -->

---

### Symmetric Cryptography

<!--Diagram-->

A -> [e] -> {the internet} -> [d] -> B
      ^                        ^
      k                        k

Example: AES, XOR cipher

---
### Asymmetric Cryptography

In asymmetric cryptography, we use two pieces of information instead of one.

One of these pieces (the public key) is strictly derivable from the other (the secret), without revealing any information about the secret.

Using only the public key, information can be encrypted such that only the possessor of the secret can access it.

---

### Asymmetric Protocols

- Asymmetric cryptraphy includes RSA, Elgamal, Elliptic Curve (slowest to fastest)
- Elliptic Curves (ECC) used in Polkadot/Substrate:
  - secp256k1/ecdsa
  - sr25519
  - ed25519
- ECC requires double the bits to the symmetric AES for the same level of security. E.g. 128 bit security requires a 256 bit ECC key.

---

### Practical Considerations

Symmetric cryptography is much faster, but requires more setup (key establishment) and trust (someone else possesses the secret).

Asymmetric cryptography is slow, but typically preserves specific algebraic relationships, which then permits more diverse if fragile protocols.

---

### Hybrid Cryptography 

Hybrid cryptography mixes symmetric and asymmetric cryptography. 

- Symmetric encryption can provide speed, and often confidentiality,
- And asymmetric can dictate relations among the participants.

---

### Digital Signatures

**Digital signatures provide data authenticity and integrity guarantees.**

The next two lectures are dedicated to digital signatures, this is strictly an intro.

---

### Digital Signatures

A signature is a function on some data, using some secret information, that provides a "signature" such that a third party can reasonably verify possession of some secret information by the signer, without the signer revealing it, i.e. using only the data, the signature, and some public information.

---

### Digital Signatures on Plaintext

Digital signatures are not limited to encryption. Some information you even want to share publicly.

Example: Instructions to transfer 10 tokens to another account.

Digital signatures still guarantee that the message is authentic and has not been modified (e.g. to 100 tokens).

---

### Nonrepudiation

Only the possessor of some secret information could have produced a valid signature.

The signer cannot claim that the signature was forged.

Symmetric cryptography does not provide this guarantee: someone else possesses the secret.

---

### Polkadot in Practice

In Substrate and Polkadot, we use ECDSA, ed25519, and sr25519.

Of course a valid signature is a valid signature, and there are lots of libraries. Some specific to Polkadot/Substrate:

- Subkey (CLI)
- Substrate Primitives (runtime)
- Polkadot JS Crypto (applications)

---

### Certificates

Certificates are used to make attestations about public key relationships.

Typically in the form of a _signature_ on:

- A public key (not necessarily the signer's)
- Information about its owner
- Information about its use

---

### Certificates in Substrate

Practically speaking, in Substrate we will use certificates to:

- Associate physical hardware with on-chain accounts (called session keys)
- Link disparate and potentially keyless on-chain accounts in certain contexts (proxies)

---

### Hash Functions

**Motivation: We often want a succinct representation of some data with the expectation that we are referring to the same data. A "fingerprint".**

Again, just an intro. There are lectures dedicated to hashes and hash-based data structures.

---

### Hash Function Applications

Hashes can be useful for many applications. Examples:

- Representation of larger data object (history, commitment, file)
- Keys in a database
- Digital signatures
- Key derivation
- Pseudorandomness <!--namely, including some data that an attacker can't control-->

---

### Hash Function Properties

Hashes need to:

1. Accept unbounded size input
1. Map to a bounded output
1. Be fast to compute
1. Be computable strictly one-way (impossible to find a pre-image for a hash)
1. Resist pre-image attacks (attacker controls one input)
1. Resist\* collissions (attacker controls both inputs)

\*Based on the first two properties, _there must exist_ infinite collisions. A.k.a. Dirichlet's Drawer Principle, a.k.a. pigeonhole principle.

<!--diagram-->

---

### Input Sensitivity

Changes to a hash are not related to the magnitude of change in the input. Example:

<!--TODO: made this into a nice diagram-->

The Economist: “My bicycle”, she assured him, “awaits me.”
Blake2 Hash: `0x160d9d90cf984ad64ab36b2de20292ddd1b8b30f9246f1baa1b117321db2d491`

AP Style: “My bicycle,” she assured him, “awaits me.”
Blake2 Hash: `0x29804282a827a3c1b02b600e36ea8cd0fe8b69213cb6e18da651150101016155`

---

### Cryptographic vs. Non-Cryptographic

Cryptographic hash functions provide stronger guarantees on the last three properties.

But non-cryptographic hash functions are much faster.

Substrate uses both (more on that later).

---

### Digital Signatures (Again)

Signing large amounts of data is inefficient. But hashing large amounts of data _is_.

A signature on the hash of some data implies a signature on the data itself. Requires that the verifier also compute the hash.

<!--
Useful class exercise: discuss some reasons why the 6 listed hash properties are so important now:
- If an attacker can find a colliding pre-image, they can "authorize" something unintended.
- Or if they can find a collision on their own, attempt to trick you into signing one.
-->

<!--diagram-->

In transactions in Substrate, key holders sign the instructions themselves iff they are fewer than 256 bits. If the instructions are longer, they sign their hash.

---

### Hashers in Substrate

Substrate primarily uses two hashing algorithms:

- Blake2b (cryptographic)
- TwoX64 (non-cryptographic)

TwoX64 is about 20x faster.
<!-- insert truncated table https://github.com/Cyan4973/xxHash#benchmarks -->

---

### Database Keys

TwoX64 is safe to use when users (read: attackers) cannot control the input, e.g. when the database key is a system-assigned index.

Blake2b should be used for everything else.

There is a whole lecture on hash-based data structures.

---

### Other Uses of Hashes in Substrate

Hashes are also used for:

- Generating multisig accounts
- Generating system-controlled accounts
- Generating proxy-controlled accounts
- Representing proposals
- Representing claims (e.g. the asset trap)

---

### Summary

Cryptography is much more than encryption. It's a toolkit that allows us to:

- Communicate on public networks, in the open
- Access information
- Have expectations about authenticity and integrity
- Prove knowledge of some secret information
- Represent large amounts of data succinctly

---
