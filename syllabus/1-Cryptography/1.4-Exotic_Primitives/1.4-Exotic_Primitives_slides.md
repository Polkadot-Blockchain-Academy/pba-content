---
title: Exotic primitives
description: More cutting edge cryptography used in blockchain
duration: 1 hour
instructors: ["Alistair Stewart"]
teaching-assistants: ["?"]
---

# Outline

- VRFs
- Erasure coding
- ZK Proofs

---

## Verfiable Random Functions (VRFs) 

---

### Verfiable Random Functions (VRFs)

- Used to obtain private randomness, that is publically verifiable 

- a variation on a signature scheme
    - still have private/public key pairs, input as message
    - in addition to signature, we get an output

---

### VRF Interface 

`sign(sk, input) -> signature`
`verify(pk, signature) -> output`
`eval(sk,input) -> output`


---

### VRF Output properties

- output is a deterministic function of key and input 
   - i.e. eval should be deterministic
   
- it should be pseudo-random
- but until the VRF is revealed, only the holder of the secret key knows the output

---

### VRF Usage

- choose input after key, then the keyholder cannot influence the output
- The output then is effectively a random number known only to the keyholder
- But they can later reveal it, by publishing the VRF proof

Notes: the signature which proves that this is the output associated to their input and public key

---

### Example

- Playing a card game in a distributed and trustless way
- For player A to draw a card, the players agree on a new random number x
- A's card is determined by 
	`eval(sk_A,x) mod 52`
- To play the card, A publishes the signature.

---

### Extensions

- Threshold VRFs / Common coin
	- generate the same random number if t out of n people particpate

- RingVRFs
	- the VRF output could be from any one of a group of public keys.

Notes: Common coins were used in consensus before blockchains were a thing. Dfinity based their consensus on this. But this needs a DKG, and it's unclear if a decentralised protocol can do those easily.

---

## Erasure coding

---

### Erasure coding 

- Turn data into pieces (with some redundancy) so it can be reconstructed even if some pieces are missing.

- a message of k symbols is turned into a coded message of n symbols and can be recovered from any k of these n symbols

---

### Classical use

- Used for noisy channels
- If a few bits of the coded data are randomly flipped, we can still recover the original data.
- typically n is not much bigger than k

---

### Use in decentralised systems
- We have data we want to keep publically available
    - but not have everyone store
    - but we don't trust everyone who is storing pieces

- typically we use n much bigger than k

---

## ZK proofs



- How do we do private operations on a public blockchain and have everyone know that they were done correctly?

Notes: (we are working on substrate support for these and will use them for protocols)


---

### What is a ZK Proof?

- A prover wants to convince a verifier that something is true without revealing why it is true.

- They can be interactive protocols, but mostly we'll be dealing with the non-interactive variety.

---

### What can we show?

- NP relation:
`function(stament, witness) -> bool`

- prover knows a witness for a statement
 
   - wants to show that they know it (a proof of knowldege)

  - without revealing anything about the witness (ZK)

---

Example: Schnorr signatures are ZK Proofs

- they show that the prover knows the private key (the discrete log of the  public key) without revealing anything about it. 
- the statement is the public key and the witness the private key


---


- **Proof of knowldege** - if you can compute correct proofs of a statement, you should be able to compute a witness for it.

- **Zero knowledge** - the proof reveals nothing about the witness that was not revealed by the statement itself

---

- NP relation:
`function(stament, witness) -> bool`

- prover wants to show that they know a witness to a particular statement (a proof of knowldege)

- without revealing anything about the witness (ZK)

- with a small proof even if the witness is large (succinctness)


---

### Scaling

- A small amount of data, a ZK proof, and execution time can be used to show properties of a much larger dataset which the verifier doesn't need to know. 

---

### Scaling via ZK proofs in blockchain

- Large amount of data - a blockchain 
- verifier is e.g. an app on a mobile phone

Notes: e.g. Mina  do a blockain with a constant size proof (of correctness of execution and consensus) using recursive SNARKs

---

### Scaling via ZK proofs in blockchain 2

- the verifier is a blockchain, with very expensive data and computation costs

- Layer 2s using ZK rollups

Notes: of which Ethereum has many, ZKsync, ZKEVM etc. Polkadot already scales better!



---

### Privacy

- A user has private data, but we can show publicly that this private data is correctly used.

- Private cryptocurrency  
	- keep amounts secret 
	    - but show they are positive!
	- keep who pays who secret

Notes: You can do some of keeping amounts secret without ZK-SNARKs, but the positivie part is difficult. To do everything well, ZK-SNARKs are needed in e.g. ZCash and its many derivatives e.g. Manta)

---

### Practical considerations

- Very powerful primitive

- Useful for both scaling and privacy

- One can design many protocols with ZK Proofs that wouldn't otherwise be possible.

---

### Downside

- slow prover time for genral computaion
- to be fast, need to hand optimise
- very weird computation model: Non-deterministic arithmetic circuits


---

### Downsides conclusion?

- so if you want to use this for a component, expect a team of skilled people to work for at least a year on it...
- but if you are watching this 5 years later, people have built tools to make it less painful.

---

## Summary

- VRF: Private randomness that is later publicly verifiable
- Erasure Coding: Making data robust against losses with redundancy
- ZK Proofs: Just magic, but expensive magic