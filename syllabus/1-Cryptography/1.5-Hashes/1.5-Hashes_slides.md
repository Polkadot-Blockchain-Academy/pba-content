---
title: Hash Functions
description: Hash functions in Substrate
duration: 1 hour
instructors: ["Gavin Wood"]
teaching-assistants: ["Dan Shields"]
---

# Hash Functions

---

### Introduction

As mentioned in the intro,

We often want a succinct representation of some data with the expectation that we are referring to the same data. A "fingerprint".

---

### Hash Function Properties

1. Accept unbounded size input
1. Map to a bounded output
1. Be fast to compute
1. Be computable strictly one-way (difficult to find a pre-image for a hash)
1. Resist pre-image attacks (attacker controls one input)
1. Resist collissions (attacker controls both inputs)

---

### Hash Function API

A hash function should accept an unbounded input size (`[u8]` byte array) and return a fixed-length output (here, a 32 byte array).

```rust
fn hash(s: &[u8]) -> [u8; 32];
```

---

### Example

**Short input (5 bytes):**

```text
hash('hello') =
	0x324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf
```

**Large input (1.2 MB):**

```text
hash(polkadot_runtime-v9190.compact.compressed.wasm) =
	0xc4d194054f03dc7155ccb080f1e6d8519d9d6a83e916960de973c93231aca8f4
```

---

### Speed

Some hash functions are designed to be slow. These have applications like password hashing, which would slow down brute-force attackers.

For our purposes, we generally want them to be fast.

---

### Non-Cryptographic Hash Functions

Non-cryptographic hash functions provide weaker guarantees in exchange for performance.

They are OK to use when you know that the input is not malicious. But if in doubt, use a cryptographic hash function.

---

### One Way

Given a hash, it should be difficult to find an input value (pre-image) that would produce the given hash.

That is, given `H(x)`, it should be difficult to find `x`.

We sometimes add random bytes to pre-images to prevent guesses based on context (e.g., if you are hashing "rock, paper, scissors", then finding a pre-image is trivial without some added randomness.)

---

### Second Pre-Image Attacks

Given a hash and a pre-image, it should be difficult to find _another_ pre-image that would produce the same hash.

That is, given `H(x)`, it should be difficult to find any `x'` such that `H(x) == H(x')`.

Since most signature schemes perform some internal hashing, this second pre-image would also pass signature verification.

---

### Collision Resistance

It should be difficult for someone to find two messages that hash to the same value.

That is, it should be difficult to find an `x` and `y` such that `H(x) == H(y)`.

---

### Collision Resistance

**Difference from second pre-image attack:**

In a second pre-image attack, the attacker only controls one input (presumably the other has already been signed).

In a collision, the attacker controls both inputs but may attempt to trick someone into signing one message, with the intention to impersonate the signer with the other.

---

### Birthday Paradox

_With 23 people, there is a 50% chance that two of them will have the same birthday._

Need to compare each output with every other, not with a single one.

Result: Hash function security is only half of the bit space (e.g., a 256 bit hash output yields 2^128 security).

---

### Hash Functions Available in Substrate

Hash functions are available in Substrate as part of the runtime primitives.

- Blake2 (cryptographic)
- XX
- Keccak (cryptographic)

Substrate also implements traits that provide 160, 256, and 512 bit outputs for each hasher.

Exercise: Write your own benchmarking script that compares the performance of these algorithms with various input sizes.

---

### Hash Function Selection

When users have control of the input, system designers should use cryptographic hash functions (in Substrate, Blake2).

Otherwise, non-cryptographic (TwoX) is faster, but only safe when the users cannot select the pre-image, e.g. a system-assigned index.

Keccak is available for Ethereum compatibility.

---

## Applications

---

### Database Keys

To easily find the location of data in a database, we can use the properties of hash functions to generate deterministic and unique lookup keys.

Given some fixed property, like an ID and other metadata the user knows beforehand, they can always find the database entry with all of the content they are looking for.

---

### Account Abstractions

Actors external to a system are often represented by a public key, which can be used to store some data that the user can authorise use of by signing instructions.

But the properties of hash functions allow other kinds of representations.

---

### Public Key Representation

Because hashes serve as unique representations of other data, that other data could include public keys. A system can map a plurality of key sizes to a fixed length (e.g. as a database key).

For example, the ECDSA public key is 33 bytes:

```text
Public key (hex):  0x02d82cdc83a966aaabf660c4496021918466e61455d2bc403c34bde8148b227d7a
Hash of pub key:   0x8fea32b38ed87b4739378aa48f73ea5d0333b973ee72c5cb7578b143f82cf7e9
                                                                                     ^^
```

---

### Multi-Signatures

By hashing a concatenation of several public keys, a system can create new IDs that require signature thresholds to authorise activity.

<!--
	diagram?
	`hash([key1: [u8; 32], key2: [u8; 32], key3: [u8; 32]], 2) => [u8; 32];`
-->

---

### Internal System IDs

Modules within a system can have their own information stored in other parts of the system, that they authorise use of by the module's internal logic.

The hash of some input (e.g. a byte-string representing the module) can be used to identify a particular module within a system.

---

### Commitment Schemes

It is often useful to commit to some information without storing or revealing it. For example,

- A prediction market would want to reveal predictions only after the confirming/refuting event occured. However, participants should not be able to modify their predictions.
- Users of a system may want to discuss proposals without storing the proposal on the system. Likewise, participants want guarantees that the proposal has not changed.

---

### Commit-Reveal

By hashing a message, a user can show the hash output as a commitment, and reveal the message later. It is normal to add some randomness to the message to expand the input set size.

`hash(message + randomness) => commitment`

Commitment: `0x97c9b8d5019e51b227b7a13cd2c753cae2df9d3b435e4122787aff968e666b0b`

---

### Reveal

Message with some added randomness:

"I predict Boris Johnson will resign on 7 July 2022. facc8d3303c61ec1808f00ba612c680f"

---

### Data Identifiers

Sometimes people want to store information in one place and reference it in another. For reference, they need some "fingerprint" or digest. As an example, they may vote on executing some privileged instructions within the system.

The hash of the information can succinctly represent the information and commit its creator to not altering it.

---

### Data Structures

This is the focus of the next lecture. For now, just a brief introduction.

---

### Pointer-Based Linked Lists

Pointer-based linked lists are a foundation of programming.

But pointers are independent from the data they reference, so the data can be modified while maintining the list.

That is, pointer-based linked lists are not tamper evident.

---

### Hash-Based Linked Lists

Hash-based lists make the reference related to the data they are referencing. The properties of hash functions make them a good choice for this application.

Any change at any point in the list would create downstream changes to all hashes.

---

### Merkle Trees

A Merkle tree is a data structure where each leaf is the hash of some data object and each node is the hash of its children.

<!--diagram, obviously-->

---

### Proofs

Merkle trees allow many proofs relevant to the rest of this course, e.g. that some data object is a member of the tree without passing the entire tree.

More info in the next lecture.

---
