---
title: Hash Functions # Also update the h1 header on the first slide to the same name
description: Describe your slides here
duration: 1 hour
instructors: ["some one", "Pratyush Ranjan Tiwari"]
teaching-assistants: ["some one", "another gal"]
---

# Cryptographic Hash Functions

### _Module 1, Lecture 5_

---

### Outline

<!--
You can reference slides within this presentation like [this other slide](#at-the-end-of-this-lecture-you-will-be-able-to) by use of the header title.

Please make your lecture precise.

- Limit the main points in a lecture to five or fewer.
- Create effective visuals, analogies, demonstrations, and examples to reinforce the main points.
  {TAs and the Parity design team can assist! Please let us know marking an item here as `TODO`}
- Emphasize your objectives and key points in the beginning, as you get to them, and as a summary at the end.

-->

1. [Introduction](#intro)
1. [Security Properties](#sec)
1. [Collision Resistance](#coll)
1. [Birthday Paradox](#bday)
1. [Collision Exercise](#col)
1. [Pre-image Resistance](#pre)
1. [Various instantiations](#inst)


---


## Introduction

A hash function does the following:

- Takes as input a string of arbitrary length
- The hash function output is a fixed-length string
- So a hash function can massively compress an input
- As we will see hash functions are very versatile, hence they should be efficiently computable
- Lets look into what makes a secure "cryptographic" hash function 
---

## Security Properties

Collision Resistance:

- A collision is when for some hash function $H(\cdot)$, $H(x) = H(y)$ but $x\neq y$
- This doesn't mean that collisions do not exist
- Its just that no efficient, real-world adversary should be able to find them 

Pre-image resistance:

- For a given $y = H(x)$, a real-world adversary should not be able to find $x$, when just given $y$
- Hence, going from the hash output to the input should be almost impossible for a real-world adversary
---

## Collision Resistance

- Why do collisions exist? Hash functions map an arbitrarily large input space {$ 0, 1$}$^*$ to a set sized output space {$ 0, 1$}$^{256}$
- Therefore, collisions exist by simple pigeonhole principle
- If you put 1 pigeon in 1 nest/hole then you will run out of nests pretty fast if you have more pigeons than nests, hence causing collisions (more than 1 pigeon in 1 nest)
- But as we said, no efficient, real-world adversary should be able to find the collisions
- Let's look at a simple collision finding exercise

---

## Birthday Paradox

- Lets try to find a collision for a hash function with a 256-bit output 
- Lets try $2^{130}$ randomly chosen inputs
- What's the probability that 2 of the inputs have same output?
- The answer is similar to another problem called the Birthday Paradox
- The birthday paradox says that in a room of 23 people, the odds that at least two people share a birthday is 50%
- Simple probability calculation if you take $n$ random inputs and the function range is $ D = 2^{256}$ different inputs, the expected number of solutions is:
$$ n - D + D(\frac{D-1}{D})^n$$ 
- [Link](https://matt.might.net/articles/counting-hash-collisions/) to derivation for interested folks
---

## Collision Exercise

- Going back to our problem: what's a the probability that out of $2^{130}$ randomly chosen inputs, 2 of them have the same hash output for a 256-bit hash function
- It's roughly $99.8$%
- Works no matter what Hash function you use in practice
- Not efficient, if a computer calculates 10k hashes/sec it takes $10^{27}$ years to compute $2^{130}$ hashes
- If a hash function was an ideal random function (no relation between input and output) finding collisions is hard!
- However, sometimes there are slightly faster methods as the hash functions we use only "mimic" a random function

---

## Pre-image Resistance

- Given $y = H(x)$ no efficient adversary can find x, except with very small probability
- Simple attack needs to prevented: an adversary should not be able to enumerate $H(x)$ in a table, for all $x$
- Hence, input space is arbitrarily large, prevents such enumeration based attacks to a certain degree
- We know that if we the hash function is sufficiently compressing (arbitrarily large input to fixed size output) then collision resistance implies pre-image resistance

---

## Various Instantiations

- Hash functions are usually decided by multi-year competitions
- Standards are fixed and then academics and engineers across the world propose constructions accounting for hardware, software efficiency and security
- Secure Hash Algorithms (SHA) are a family of cryptographic hash functions published by the National Institute of Standards and Technology (NIST) as a U.S. Federal Information Processing Standard (FIPS)
- SHA-1 (earlier MD5 hashes), broken since 2010
- SHA-2 (SHA-256, SHA-512) two similar hash functions, different output/block sizes, used in TLS, SSL, SSH, Bitcoin etc
- SHA-3 (Keccak family) first proposed in 2012 after a public competition
- Blake2 is another popular hash function due to its efficiency 

<!--
Add comparison graphic from https://www.blake2.net/

-->
---
