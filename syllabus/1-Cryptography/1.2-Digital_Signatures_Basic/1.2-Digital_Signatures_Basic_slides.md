---
title: Digital Signatures Basics # Also update the h1 header on the first slide to the same name
description: Describe your slides here
duration: 1 hour
instructors: ["some one", "Pratyush Ranjan Tiwari"]
teaching-assistants: ["some one", "another gal"]
---

# Digital Signatures

### _Module 1, Lecture 2_

---

### Outline

<!--
You can reference slides within this presentation like [this other slide](#at-the-end-of-this-lecture-you-will-be-able-to) by use of the header title.

Please make your lecture precise.

- Limit the main points in a lecture to five or fewer.
- Create effective visuals, analogies, demonstrations, and examples to reinforce the main points.
  {TAs and the Parity design team can assist! Please let us know marking an item here as `TODO`}
- Emphasize your objectives and key points in the beginning, as you get to them, and as a summary at the end.

-->

1. [Why do we need signatures?](#usecases)
1. [Properties of Digital Signatures](#properties)
1. [What does a Digital Signature scheme look like?](#algorithms)
1. Different types of Signatures
1. [Example](#example)


---


## Why do we need signatures?

What problems do digital signatures solve:

- Attestation: you attest to a message and signed it
- Authentication: you own your digital identity (via your private key), only you can sign
- Verification: Anyone can verify that you indeed signed the message/document

---

## Properties of digital  signatures:

- Unforgeability: Even given your signature on one message, can not be forged for another message
- Public verfiability: Given your public information (public key), anyone can verify
- Correctness: If you produce a signature, verification should always succeed

---

## What does a signature scheme look like?

What problems do digital signatures solve:

- $(sk, pk) \leftarrow KeyGen(r)$: Takes as input some random (unpredictable) string, outputs secret/private key and public key
- $ sig \leftarrow Sign(sk, msg)$: Takes as input the secret key and the message, outputs a signature on that message 
- $isValid \leftarrow Verify(pk, msg, sig)$: Takes as input a public key, a message and a signature, outputs whether the signature is valid on that message and public key
- The $Sign()$ algorithm is usually a randomized algorithm, i.e., produces different signatures on the same message to prevent replay-attacks
- In practice, $Sign(sk, H(msg)), Verify(pk, H(msg), sig)$: for efficiency the message is hashed (using Blake2) before signing as the hash digest is the same size regardless of message length

<!--

Replay attacks are when I grab someone's signature on a message and pretend to be them, such an attempt is caught if the attacker can not produce a fresh signature on the same message

Blake2 hash function is used as it is faster than MD5, SHA-1, SHA-2, and SHA-3, yet is at least as secure as the latest standard SHA-3.
-->
---

## Different types of digital signatures

- Elliptic Curve Based: Use elliptic-curve mathematics like ECDSA (Elliptic Curve Digital Signature Algorithm)
- Pairing-based: Use pairings which allow computing on secrets in the exponent ex: BLS signatures
- Hash-based: Use hash functions
- Others
---

## Example

- Now we will demonstrate the signing process from key generation, all the way to verification
---
