---
title: Digital Signature Basics
description: Hands-on application of digital signature
duration: 1 hour
instructors: ["Gavin Wood"]
teaching-assistants: ["Dan Shields"]
---

# Digital Signatures: Basics

---

### Signature API

Signature libraries should generally all expose some basic functions:

- `fn generate_key(r) -> (sk, pk);`: Generate a secret key `sk` from some input `r`. The input could be anything, for example the movement pattern of a mouse.
	- A public key `pk` is derivable from `sk`, but is often returned for convenience.
- `fn sign(sk, msg) -> signature;`: Takes as input the secret key and the message; returns a digital signature.
- `fn verify(pk, msg, signature) -> bool;`: Takes as input a public key, a message, and a signature; returns whether the signature is valid on the given inputs.

---

### Generate a Key

Subkey is a CLI that provides a key generation and signature API.

```
> subkey generate
Secret phrase:       thank liberty fame metal illegal project behind join armed afraid welcome act
  Secret seed:       0xa959ae8546c355d25e7dacdffac94d6f5d2ee8c28a0b5b0511a60f0d2aa5c595
  Public key (hex):  0x7498c845882ffa046a994d3f4d0e6422fbc6ff85aa61f294ab293158e7e6381d
```

---

### Sign a Message

```
> echo -n 'Hello Polkadot Blockchain Academy, Cambridge 2022' | subkey sign \
    --suri 'master ostrich insect boost sword cigar balance agent crater assist cheese play'
58dd5fafab68b27bf7019f10610438be7bab34309d418ce8ceff4c12c262a0598d98c9c4c412c57dff78cb7bd1fd4dfd0445ad8c3aa1192893db815e21f92b84
```

---

### Verify a Signature

```
> echo -n 'Hello Polkadot Blockchain Academy, Cambridge 2022' | subkey verify \
          '0x58dd5fafab68b27bf7019f10610438be7bab34309d418ce8ceff4c12c262a0598d98c9c4c412c57dff78cb7bd1fd4dfd0445ad8c3aa1192893db815e21f92b84' \
          '0x846ef3e2cdb5afc57c718762b1bdd761a3e85e8b4bc37c755d663b5c0e805b39'
Signature verifies correctly.
```

---

### Alter the Message

Let's alter the message (as if you were here a year earlier):

```
> echo -n 'Hello Polkadot Blockchain Academy, Cambridge 2021' | subkey verify \
          '0x58dd5fafab68b27bf7019f10610438be7bab34309d418ce8ceff4c12c262a0598d98c9c4c412c57dff78cb7bd1fd4dfd0445ad8c3aa1192893db815e21f92b84' \
          '0x846ef3e2cdb5afc57c718762b1bdd761a3e85e8b4bc37c755d663b5c0e805b39'
Error: SignatureInvalid
```

---

### Rust / Substrate

Demo: Use Substrate's `sp_core::sr25519` to repeat the above example.

<!--need gav's ok on this-->

---

### Hash Functions

There are two lectures dedicated to hash functions. But they are used as part of all signing processes.

For now, we only concern ourselves with using Blake2.

---

### Rust / Substrate

Demo: Use `sp_core::Hasher` to hash a larger message for fixed length output.

<!--need gav's ok on this-->

---

### Hashed Messages

As mentioned in the introduction, it's often more practical to sign the hash of a message. Therefore, the sign/verify API may be _used_ like:

- `fn sign(sk, H(msg)) -> signature;`
- `fn verify(pk, H(msg), signature) -> bool;`

Where `H` is a hash function (for our purposes, Blake2).

---

### Signing Payloads

Signing payloads are an important part of system design. Users should have credible expectations about how their messages are used.

For example, when a user authorises a transfer, they almost always mean just one time.

---

### Replay Attacks

Replay attacks occur when someone intercepts and resends a valid message. The receiver will carry out the instructions since the message contains a valid signature.

- Since we assume that channels are insecure, all messages should be considered intercepted.
- The "receiver", for blockchain purposes, is actually an automated system.

---

### Replay Attack Prevention

Signing payloads should be designed so that they can only be used one time and in one context.

- Monotonically increasing account nonces
- Timestamps (or previous blocks)
- Context identifiers like genesis hash and spec versions

---

## Signature Schemes

---

### ECDSA

- Uses Secp256k1 elliptic curve
- ECDSA (used initially in Bitcoin/Ethereum) was developed to work around the patent on Schnorr signatures.
- ECDSA complicates more advanced cryptographic techniques, like threshold signatures

---

### Ed25519

- Schnorr signature designed to reduce mistakes in implementation and usage in classical applications, like TLS certificates.
- Signing is 20-30x faster than ECDSA signatures

---

### Sr25519

Sr25519 addresses several small risk factors that emerged from Ed25519 usage by blockchains

---

### Use in Substrate

- Sr25519 is the default key type in most Substrate-based applications
- Its public key is 32 bytes and generally used as account IDs in state
- Secp256k1 public keys are _33_ bytes, so their _hash_ is used to represent their account IDs

---

### HDKD

Hierarchical Deterministic Key Derivation

<!--diagram something like https://cryptochamp.com/wp-content/uploads/2019/01/HD-Deterministic-Wallet.jpg -->

---

### Hard vs. Soft

Key derivation allows one to derive (virtually limitless) child keys from one "parent".

Derivations can either be "hard" or "soft".

---

### Hard Derivation

Hard derivation requires the secret key and derives new children secret keys.

Typical "operational security" usages should favor hard derivation over soft derivation because hard derivations avoid leaking the sibling keys, unless the original secret is compromized.

---

### Hard Derivation in Wallets

Wallets can derive keys for use in different consensus systems while only needing to back up one secret plus a pattern for child derivation.

<!--diagram here for example. one key with paths to //bitcoin, //ethereum, //polkadot, ...-->

---

### Hard Derivation Example

Let's imagine we want to use this key on multiple networks, but we don't want the public keys to be connected to each other.

Let's use Subkey hard derive (represented by `//`) keys for use in multiple networks, here Polkadot and Kusama. Note that these derivations create entirely new secret seeds.

```
> subkey inspect 'master ostrich insect boost sword cigar balance agent crater assist cheese play//polkadot'
Secret Key URI `master ostrich insect boost sword cigar balance agent crater assist cheese play//polkadot` is account:
  Secret seed:       0xae84d8131fc9639013c16927a9c97f0fb25f1ec110ec239705a84fbe51694d12
  Public key (hex):  0xfa8e9bae4f80275a1bf6a0b582461d949bbd64a06f82c817d236ba1f4193b502
  Account ID:        0xfa8e9bae4f80275a1bf6a0b582461d949bbd64a06f82c817d236ba1f4193b502
  SS58 Address:      5HjEC5U39iEJ71TDHLS7Tmzjsb412jNRkk4QPSz5DX18UQBu
  
> subkey inspect 'master ostrich insect boost sword cigar balance agent crater assist cheese play//kusama'
Secret Key URI `master ostrich insect boost sword cigar balance agent crater assist cheese play//kusama` is account:
  Secret seed:       0xf800549f4f3f0910e05476e30647411ef380642a4794b0c25efcaa1e60c97900
  Public key (hex):  0x12211e2cba7a01b5b1c086e7e40e56578843127109431848e129942555113957
  Account ID:        0x12211e2cba7a01b5b1c086e7e40e56578843127109431848e129942555113957
  SS58 Address:      5CUUZGVoWGY9LeFAJSBpDBVrZetTGiHfCMF4hsWK5JxMbK2Q
  ```

---

### Quick Interruption

Note that the output also includes an Account ID and SS58 Address. In this case, the public key is used as the account ID in Substrate. SS58 is an encoding format for the public key.

We can see that with ECDSA, the public key is one byte longer and the account ID is its hash:

```
> subkey generate --scheme Ecdsa
Secret phrase:       west verify high detect hen alley develop pizza process okay rack found
  Secret seed:       0x4988f8ae2e0267f780578a2dbaa2bd538765f3a2b3eb6b13d427f64d907e0395
  Public key (hex):  0x02d82cdc83a966aaabf660c4496021918466e61455d2bc403c34bde8148b227d7a
  Account ID:        0x8fea32b38ed87b4739378aa48f73ea5d0333b973ee72c5cb7578b143f82cf7e9
  SS58 Address:      5FKQGxokqiFujp5uw7LD6aUCtyKG4dQDE8RL8jzDxgn73ZZ1
```

---

### Soft Derivation

Soft derivation allows one to create derived addresses from only the public key. However, contrary to hard derivation, they all have related or effectively the same private key.

Note: Soft derivations can break some niche advanced protocols, but our sr25519 crate avoids supporting protocols that conflict with soft derivations.

---

### Soft Derivation in Wallets

Wallets can use soft derivation to link all payments controlled by a single private key, without the need to expose the private key for the address derivation.

Use case: A business wants to generate a new address for each payment, but should be able to automatically give customers an address without the secret key owner deriving a new child.

---

### Soft Derivation Example

We can soft derive (`/` in Subkey) more children. Note that these generate new addresses, but use the same secret seed (Account ID removed for space).

```
> subkey inspect 'master ostrich insect boost sword cigar balance agent crater assist cheese play//polkadot/0'
Secret Key URI `master ostrich insect boost sword cigar balance agent crater assist cheese play//polkadot/0` is account:
  Secret seed:       n/a
  Public key (hex):  0xa68af0a0883030efb2d4eb7e7adb9a8de684508de90dc4b4a4f84232ff83ff3a
  SS58 Address:      5Fq55aj4dfriNvF8wmVoCJo5NiTx8xpN4XkpDEaZQKTgP5mc

> subkey inspect 'master ostrich insect boost sword cigar balance agent crater assist cheese play//polkadot/1'
Secret Key URI `master ostrich insect boost sword cigar balance agent crater assist cheese play//polkadot/1` is account:
  Secret seed:       n/a
  Public key (hex):  0x1e901acf62f90c32e10518063b30600a1bdf010d399ce6fb06350042b1b6af3c
  SS58 Address:      5Ckn6rXjTmsYABZSLcHQLEyfzegscFfZT9qyARN1jw7WrcXZ
```

---

### Soft Derivation Example

Now let's do the same paths (`/0` and `/1`), but only using the Account ID from `//polkadot`. It generates the same addresses!

```
> subkey inspect 5HjEC5U39iEJ71TDHLS7Tmzjsb412jNRkk4QPSz5DX18UQBu/0
Public Key URI `5HjEC5U39iEJ71TDHLS7Tmzjsb412jNRkk4QPSz5DX18UQBu/0` is account:
  Network ID/version: substrate
  Public key (hex):   0xa68af0a0883030efb2d4eb7e7adb9a8de684508de90dc4b4a4f84232ff83ff3a
  SS58 Address:       5Fq55aj4dfriNvF8wmVoCJo5NiTx8xpN4XkpDEaZQKTgP5mc

> subkey inspect 5HjEC5U39iEJ71TDHLS7Tmzjsb412jNRkk4QPSz5DX18UQBu/1
Public Key URI `5HjEC5U39iEJ71TDHLS7Tmzjsb412jNRkk4QPSz5DX18UQBu/1` is account:
  Network ID/version: substrate
  Public key (hex):   0x1e901acf62f90c32e10518063b30600a1bdf010d399ce6fb06350042b1b6af3c
  SS58 Address:       5Ckn6rXjTmsYABZSLcHQLEyfzegscFfZT9qyARN1jw7WrcXZ
```

---

## Mnemonics and Seed Creation

---

### Mnemonics

Many wallets use a dictionary of words and give people phrases, often 12 or 24 words, as these are easier to back up/recover than byte arrays.

Some people create their own phrases. This is usually stupid.

---

### Dictionaries

There are some standard dictionaries to define which words (and character sets) are included in generation. Substrate uses the dictionary from BIP39.

---

### Mnemonic to Secret Key

Of course, the secret key is a point on an elliptic curve, not a phrase.

BIP39 applies 2,048 rounds of the SHA-512 hash function to the mnemonic to derive a 64 byte key.

Substrate uses the entropy byte array from the mnemonic.

---

### Portability

Different key derivation functions affect the ability to use the same mnemonic in multiple wallets.

---

### Next Lesson

- Certificates
- Multi-signature schemes

---
