---
title: pallet-revive architecture
description: Architecture of the pallet-revive smart contract module
duration: 30min
url: http://localhost:1948/syllabus/3-PVM-Polkadot-Architecture-and-Smart-Contracts/6.2-pallet-revive-runtime-slides.md
---

<style>
    code {
        overflow: hidden!important;
    }
</style>

## Architecture overview

<img style="height: 90%; " src="img/pallet-revive/node-architecture.png" />

---

## ETH-RPC compatibility layer

<img style="height: 90%; " src="img/pallet-revive/eth-rpc-architecture.png" />

Notes:
There are a few things we want to enable with this compatibility layer

- Make it easy to onboard EVM users by supporting EVM wallets such as MetaMask.
- Easy on ramp for existing project and developers, existing projects can start working with minimal efforts, take
  existing contracts or Dapps, rebuild them and deploy them to Polkadot and they will work right away.
  Developers can use the tools that have been buily over the years by the EVM community.

To get there, we need to speak the language of Ethereum, both on chain by running a compatible VM,
but also by implementing Ethereum JSON-RPC specs, as all interactions with the chains are done through the RPC.

As we covered previously, there has been a few attempts, to bring EVM compatibility to Substrate.

- frontier opted to collocate the Eth compatibility in the Node
- We opted to build it as a separate binary, as a proxy layer to the Substrate node.

This present a few benefits:

- We can use the Omninode or any Substrate node implementation, if a Node operator decide to use a different Node
  implementation they can do so as this approach require no modification to the Node.
- We can iterate quickly on the compatibility layer, without having to wait for the Node to be updated.

---

## EVM flow

<img style="height: 90%; " src="img/pallet-revive/eth-rpc-flow.png" />

---

# pallet-revive

Notes:

- pallet-revive is the runtime module, that handle smart contracts transactions, and manage the storage used by these contracts.

---

## pallet-revive Config

```rust[0|2-8|10-19|21-24]
impl pallet_revive::Config for Runtime {
  type Time = Timestamp;
  type Currency = Balances;
  type RuntimeEvent = RuntimeEvent;
  type RuntimeCall = RuntimeCall;
  type FindAuthor = <Runtime as pallet_authorship::Config>::FindAuthor;
  type WeightPrice = TransactionPayment;
  type RuntimeHoldReason = RuntimeHoldReason;

  type CallFilter = Nothing;
  type DepositPerItem = DepositPerItem;
  type DepositPerByte = DepositPerByte;
  type CodeHashLockupDepositPercent = CodeHashLockupDepositPercent;
  type WeightInfo = pallet_revive::weights::SubstrateWeight<Self>;
  type RuntimeMemory = ConstU32<{ 128 * 1024 * 1024 }>;
  type PVFMemory = ConstU32<{ 512 * 1024 * 1024 }>;
  type UnsafeUnstableInterface = ConstBool<false>;
  type UploadOrigin = EnsureSigned<Self::AccountId>;
  type InstantiateOrigin = EnsureSigned<Self::AccountId>;

  type ChainId = ConstU64<420_420_420>;
  type AddressMapper = pallet_revive::AccountId32Mapper<Self>;
  type NativeToEthRatio = ConstU32<1_000_000>;
  type EthGasEncoder = ();

}
```

Notes:

Let's take a quick peek at the config of pallet-revive.
We won't go in depth about the config in this lecture, but let's look at a few interesting bits specific to pallet-revive

- As for any pallet, we depends on types from the runtime, like the `Time` type, the `Currency` type, the `FindAuthor` type, etc.
- Then we have some specific types for pallet-revive
- `DepositPerItem` and `DepositPerByte` are the cost of storing data in the contract storage.
- `CodeHashLockupDepositPercent` is the percentage of the deposit that is deposited when a contract with this hash is
  instantiated.
- `WeightInfo` is the trait that define the weights for all the functions of the pallet.
- `RuntimeMemory` and `PVFMemory` are constants that we use in our integrity tests to make sure that the memory has enough memory
- UnsafeUnstableInterface is used in development to enable unstable features
- UploadOrigin and InstantiateOrigin allow to constrain who can upload and instantiate a contract
- Finally we have Ethereum specific types, like the `ChainId`, the `AddressMapper`, the `NativeToEthRatio` and the `EthGasEncoder`, to work with Ethereum.

---

## Dispatch functions

```rust[0|3|4-11]
/// Makes a call to an account, optionally transferring some balance.
#[pallet::call_index(1)]
#[pallet::weight(T::WeightInfo::call().saturating_add(*gas_limit))]
pub fn call(
    origin: OriginFor<T>,
    dest: H160,
    #[pallet::compact] value: BalanceOf<T>,
    gas_limit: Weight,
    #[pallet::compact] storage_deposit_limit: BalanceOf<T>,
    data: Vec<u8>,
) -> DispatchResultWithPostInfo { /* ... */  }
```

Notes:
Like any pallet, pallet-revive define a set of dispatch functions, that can be called by the users to submit transactions to the chain.
Usually the weight of a dispatchable is fixed, but in pallet-revive, the weight is dynamic, and depend on the gas limit of the transaction.
Antother interesting fact is that we return `DispatchResultWithPostInfo`, instead of `DispatchResult` to return the excess weight of the transaction.

---v

## Dispatch functions

| pallet call                    | Description                                                                |
| ------------------------------ | -------------------------------------------------------------------------- |
| `call`                         | Makes a call to an account, optionally transferring some balance.          |
| `instantiate`                  | Instantiates a contract from a previously deployed binary.                 |
| `instantiate_with_code`        | Instantiates a new contract from the supplied code.                        |
| `upload_code`                  | Uploads new code without instantiating a contract from it.                 |
| `remove_code`                  | Removes the code stored under a hash and refunds the deposit to its owner. |
| `map_account`                  | Registers the caller's account ID for use in contract interactions.        |
| `unmap_account`                | Unregisters the caller's account ID and frees the deposit.                 |
| `dispatch_as_fallback_account` | Dispatches a call with the origin set to the caller's fallback account.    |

---

## VM API

<img style="height: 90%;" src="img/pallet-revive/vm-architecture.png" />

Notes:

- Discuss how the VM interacts with the runtime

---v

## define_env macro

```rust
#[define_env]
pub mod env {
  /// ...

	/// Set the value at the given key in the contract storage.
	#[stable]
	#[mutating]
	fn set_storage(
		&mut self,
		memory: &mut M,
		flags: u32,
		key_ptr: u32,
		key_len: u32,
		value_ptr: u32,
		value_len: u32,
	) -> Result<u32, TrapReason> {
		self.set_storage(memory, flags, key_ptr, key_len, value_ptr, value_len)
	}
```

Notes:

- The `define_env` macro, equivalent to the `construct_runtime` in Frame.
- It generates the syscall dispatching logic, handling input and output passing through registers.
- It defines the code to handle system calls pass in inputs and outputs, through registers and synchronize the gas
  meter of the vm with the gas meter of the runtime.
- It synchronizes the VM‚Äôs gas meter with the runtime‚Äôs gas meter, ensuring that execution cost is properly accounted for before and after each system call.

---v

## UAPI

```rust
#[polkavm_derive::polkavm_import(abi = self::abi)]
extern "C" {
  pub fn set_storage(
    flags: u32,
    key_ptr: *const u8,
    key_len: u32,
    value_ptr: *const u8,
    value_len: u32,
  ) -> ReturnCode;
```

Notes:

`#[define_env]` defines the list of system calls that the VM can make to the runtime.
In the same way, to define Rust guest polkavm contracts, we need to define the host functions that the runtime can call from the VM.

This is what the `pallet-revive-uapi` crate does: it exposes all the host functions that a contract can import.
It essentially defines a list of `extern` functions that the VM can call and **handles ABI translation** to correctly pass arguments and return values between Rust and the PolkaVM runtime.

---v

## Activity: Build and deploy a Rust contract

> Build the fibonacci contract using Rust and `pallet-revive-uapi`

---

## Differences with EVM

---v

## Balance Decimals

- In EVM, the smallest unit of value is 1 wei, which is 10^-18 ETH.
- In Substrate, the smallest unit of value is 1 Planck, which is 10^-12 KSM or 10^-10 DOT.

```rust
pub trait Config: frame_system::Config {
    //...
    #[pallet::constant]
    type NativeToEthRatio: Get<u32>;
}
```

Notes:
In theory, EVM wallets are configurable, and should let you define the number of decimals you want to use.
In practice, most wallets use 18 decimals, and we have to play nicely with them.
Also everything that is passed by the contract as argument to any opcode is assumed to use 18 decimals.
A transaction that attempt to use a value that can't be translated to a substrate value without a rounding error, will be rejected.

---v

### Address mapping

- Most Substrate chain, including Asset Hub, use a 32 byte (AccountId32) address usually encoded in SS58 format.
- EVM uses a 20 byte address (H160), usually encoded in hex format.

```rust
use sp_core::{crypto::AccountId32, H160};

fn main() {
    println!("Substrate: {}", AccountId32::new([1u8; 32]));
    // Substrate: 5C62Ck4UrFPiBtoCmeSrgF7x9yv9mn38446dhCpsi2mLHiFT

    println!("EVM: {:?}", H160([1u8; 20]));
    // EVM: 0x0101010101010101010101010101010101010101
}
```

Note:
Substrate uses 32 bytes address, while EVM uses 20 bytes address.
Everything that is executed in the VM expect a 20 bytes address, we need to map the 32 bytes address to a 20 bytes address.

---v

### Address mapping

```rust[0|4-9|16-20|11-12]

#[frame_support::pallet]
pub mod pallet {
  pub trait Config: frame_system::Config {
    /// Use either valid type is [`address::AccountId32Mapper`] or [`address::H160Mapper`].
    #[pallet::no_default]
    type AddressMapper: AddressMapper<Self>;
    // ...
  }

  #[pallet::storage]
  pub(crate) type OriginalAccount<T: Config> = StorageMap<_, Identity, H160, AccountId32>;
  // ...
}

pub trait AddressMapper<T: Config> {
	fn to_address(account_id: &T::AccountId) -> H160;
	fn to_account_id(address: &H160) -> T::AccountId;
	fn map(account_id: &T::AccountId) -> DispatchResult;
  // ...
}
```

---v

### Address mapping

```rust[1-10| 12-21 | 12-27]
// H160 -> AccountId32 -> H160

//  alice_eth: 0x0101010101010101010101010101010101010101
let alice_eth = H160([1u8; 20]);

// alice_sub: 0101010101010101010101010101010101010101eeeeeeeeeeeeeeeeeeeeeeee (5C62Ck4U...)
let alice_sub = <Runtime as Config>::AddressMapper::to_account_id(&alice_eth);

// üëç Convert back
assert_eq!(alice_eth, <Runtime as Config>::AddressMapper::to_address(&alice_sub));

// AccountId32 -> H160 -> AccountId32

// bob_sub: 0202020202020202020202020202020202020202020202020202020202020202 (5C7LYpP2 ...)
let bob_sub = AccountId32::from([2u8; 32]);

//  bob_eth: 0xaf32a8053c2d446446d7019359e210b82e53b8ba
let bob_eth = <Runtime as Config>::AddressMapper::to_address(&bob_sub);

// ‚ùó Original substrate accounts need a stateful mapping
assert_ne!(bob_sub, <Runtime as Config>::AddressMapper::to_account_id(&bob_eth));

// Map the account (this is a stateful operation)
<Runtime as Config>::AddressMapper::map(&bob_sub).unwrap();

// üëç Convert back
assert_eq!(bob_sub, <Runtime as Config>::AddressMapper::to_account_id(&bob_eth));
```

---v

## Gas Model

**Ethereum**:

- ‚õΩ Single dimensional `gas`
- üìú Gas costs are defined in the yellow paper and EIPs
- üìà Quadratic memory expansion cost

**Polkadot**

- üö¶ Multi dimensional: `ref_time`, `proof_size`, `storage_deposit`
- üìè Gas cost are measured in benchmarks, and updated frequently
- üìä Fixed memory expansion cost, with hard limits

Notes:
In Ethereum, there is one dimensional resource: `gas`. The yellow paper, and the EIPs define the cost of each opcode and
precompile in gas. The gas cost is a measure of the computational effort required to execute an operation or a contract.

in pallet-revive, we have a multi-dimensional gas model, that includes the `ref_time`, the `proof_size`, and the `storage_deposit`.

- `ref_time` measure the reference time of an operation
- `proof_size` measure the size of the proof required to execute the operation, every time we load a contract for
  example, we need to add this contract to the proof, so that validators that are stateless can verify the execution of
  the block.
- `storage_deposit`: To address state bloat, we charge a deposit from a transaction signer every time a contract it calls adds data to the blockchain's state. This deposit is transferred to the contract and held there. Otherwise, the contract cannot spend or use it. Whoever signs a transaction that removes storage will receive a refund proportional to the amount of storage removed.

In Ethereum the gas costs are defined in the yellow paper and EIPs, they are not updated frequently, and each change require a hard fork.
In pallet-revive, the gas costs are measured in benchmarks, they reflect the actual performance of the reference hardware. These benchmark are run and updated every time we make a new runtime.

Finally, to avoid an OOM attack, Ethereum uses a quadratic memory expansion cost. This is calculated so limit the
maximum amount of memory that can be allocated in a transaction given the block gas limit. This means that they are
overchariing for memory to make sure the memory consumption is bounded.

In pallet-revive, we have a fixed memory expansion cost, with hard limits. This is a more realistic model. The downside
is that these limits can be too constraining, but this is something that we will adjust over time.

---v

### Benchmarked weight in Substrate

```rust[0|10-13]
	#[benchmark(pov_mode = Measured)]
	fn bn128_add() {
		let input = hex!("089142debb13c46...");
		let expected = hex!("0a6678fd675a...");
		let mut call_setup = CallSetup::<T>::default();
		let (mut ext, _) = call_setup.ext();

		let result;

		#[block]
		{
			result = Bn128Add::execute(ext.gas_meter_mut(), &input);
		}

		assert_eq!(result.unwrap().data, expected);
	}
```

---v

### Current limits

| Limit                                      | Maximum           |
| ------------------------------------------ | ----------------- |
| Call stack depth                           | 5                 |
| Event topics                               | 4                 |
| Event data payload size (including topics) | 416 bytes         |
| Storage value size                         | 416 bytes         |
| Transient storage variables                | 128 `uint` values |
| Immutable variables                        | 16 `uint` values  |
| Contract code blob size                    | ~100 kilobytes    |

Notes:

Limits might be increased in the future. To guarantee existing contracts working as expected we will _never decrease_ the limits.

---

## Existential Deposit

Notes:
On Polkadot, an account must hold a minimum balance to exist. When it drops below this minimum amount, the account is deleted.
We call this minimum amount the "existential deposit" (`ed`). It exists to prevent unused accounts from bloating the state. This is not the case on Ethereum, where
accounts are never deleted once created, and there is no minimum balance an account must hold to retain its associated data structures (e.g., nonce) in state.
Since contracts are accounts (more precisely, code that controls an account), they are also affected by this.

This leads to a situation where every account on Polkadot has some portion of its currency that it cannot spend. This may confuse contracts and off-chain
tools (e.g., wallets) written for Ethereum.

Luckily, we can hide this fact from all participants so everything keeps working as expected. It's just something to be aware of:

- Every Ethereum RPC that returns a balance will subtract the existential deposit. This means that all returned balance is actually spendable, just as on Ethereum.
- Every EVM opcode that returns the balance of an account will do the same.
- When sending balance `x` to a new account, we actually send `x + ed`. This ensures that balance transfers of any amount will succeed and the receiver has `x` as available
  balance. The downside is that it might be unexpected for the sender to send more than `x`. To prevent confusion, we add the `ed` to the transaction fee if it needs to
  be paid. This way, the user is always aware of the total cost of a transaction. \* This is also true when a contract sends balance to another contract. In this case, we always take the `ed` from the signer of the transaction and not the sending contract.
  This makes the additional send balance transparent to contracts. This is important since contract code is free to assume that exactly `x` is sent.
  If a call to a contract funds multiple new accounts, this will be reflected in the transaction fee, just like any other deposit made to cover storage costs
  (see `storage_deposit_limit` above).

---v

### Gas estimation and encoding in lower digits

- When sending tokens, wallets automatically retrieves the correct gas parameters by calling `eth_estimateGas`
- The estimate encodes the gas limit, the gas price, and the storage deposit in a single value.

Notes:

On a Substrate chain, the gas estimation is 2 dimensional (ref_time, pov), this is not a single value like in EVM.
In pallet-revive, we also use a deposit for the storage used, to make sure that the chain isn't bloated with unused storage.

To be compatible with EVM though, we need to fit these 3 numbers in a single value, the `gas_limit` of the transaction.
To achieve that, we compress the ref_time, pv and storage deposit on the lowest digits of the gas_limit, using the
binary square root of these values, and storing on the lowest 6 digits.
