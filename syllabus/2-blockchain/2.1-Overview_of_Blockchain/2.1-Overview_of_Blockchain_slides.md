# Lesson 1: 
# Overview of Blockchains

---

# Speaker

Gav Wood, Founder and CEO, Parity Technnologies

<!-- Insert Gav Wood Headshot here -->
---

## What is a Blockchain?

- A data structure
- Typically stores a chain of events 
- Incorporates a sense of time and causality

<!-- By causality, we mean that an event happens after another event. For something to happen, something else had to be triggered- a cause and effect. In a blockchain, someone issues a transaction, which "triggers" an event. The blockchain is a ledger of all previous events.

Blockchains existed before bitcoin; NYT created a time and data pointer to the next block (MITOCW example) 

Blocks in the form of a chain. New ones are being made, but they're all tied together; and they're timestamped, so every block has a clear record of the time it was created. The transactions are ordered in time; the blockchain data structure has found its use case in storing 'events' on a timeline with causality. A causes B (which is later than A) causes C (which is later than C)-->

<!-- Simple time stamp inside of a block, every six minutes we'll build a block. Each block has a hash of the timestamp from the last block. Infographic which summarizes the activity which will happen later. The hash is the summary of the previous data. The hash pointer points to the next block. -->

---

# What Kind of Data makes sense to be on a Blockchain?

- Data that is chronological in time
- Data that is causal- in which one event causes the next to happen
- Creates a sequential thread of execution
## Examples:

- Financial transactions
- Smart contracts on Ethereum (a contract triggers the next events to happen)

---
## Key Attributes of a Blockchain

- Immutability
- Verifiability
- Decentralized?

---
# Blockchains are Immutable

- Blockchains cannot be modified... because that would change the hash of that block, which would break the blockchain
- The past blocks are fixed and can never be changed- and every new block depends on the past blocks.

## Therefore:

- Once a transaction is recorded, it can never be changed: this is what makes the blockchain record secure.

---

# Blockchains are Verifiable

- Hash review: A digital string of any length can be hashed into a fixed length (e.g., 256 bits)
- Each transaction can be 'verified' by an actor who knows what hashing algorithm was used and can run the same hashing algorithm on the data to verify that the hash matches.

## Therefore:

- No forgery is possible on a blockchain; forging anything in the string breaks the hash.
- Broken hashes won't match and won't be verified.

---

# Blockchains are Decentralized (?)

- Decentralization: An open, accessible network that cannot be fully controlled by a single entity
- The Blockchain community usually sees decentralization as a core principle- anyone can become a *node* in the network.
- The pioneers of Blockchain technology always wanted Blockchain to be fully open and decentralized

---
# Blockchains are Decentralized (?)

- Contrary to popular belief, Blockchains are not by definition decentralized
- For example, the Hyperledger Blockchain can be fully controlled by one enterprise
- Blockchain purists don't even consider these to be real blockchains

---
# Decentralization Often Happens Through Distributed Systems

- Distributed systems use many different nodes to deliver a better service than a single central source
- The nodes do the same thing, which builds enormous redundancy and stability

---
# How do we make a blockchain decentralized?

- Distributed systems have been around since the 1970s
- By using distributed systems research, we can build a decentralized network that is entirely peer to peer with no central authority
- Other famous peer-to-peer systems included BitTorrent and Napster

---
## Principles From Distributed Systems 

1. Fault Tolerance 
2. Consensus Systems to Protect Against Malicious Actors

---
## Fault Tolerance in Distributed Systems

- Provide the desired service despite the presence of certain failures by exploiting redundancy 
- Services run on distributed servers to ensure that no one failure or attack on a server can bring down the entire system.
- The same data is replicated on multiple servers

---
## Protection Against Malicious Actors

- When you open the network for universal use, you no longer have control, and you will have malicious nodes.
- *Consensus* is the way we can fight bad actors.

---
## Less Trust, More Truth

Blockchains can automate trust by being:

- immutable
- verifiable
- distributed and decentralized
- secured by consensus systems

<!-- Gav's talk from  https://www.youtube.com/watch?v=w7Z9AqhbpFs-->

---
### What Problems Does a Blockchain Solve?

- Situations where trust is traditionally held in a central entity

| Application   | Old Solution | Blockchain Solution
| ----------- | ----------- |
| Transferring Money | Banks | Frictionless P2P
| Contracts | Lawyers  | Smart Contracts
| Identity | State Agencies | Decentralized Identity

And many more...

---
## Blockchains as Finite State Machines

- The state of data in a block remains the same until a change occurs
- To change, there must be a trigger
- Triggers might be external or internal
- The *state transition function* is the core logic by which the blockchain data changes

---
## Deterministic State Transition Functions

- Same trigger will always lead to the same change
- All based on the rules of the state transition function

---
## What is a Distributed State Machine?

- Replicated and redundant across several machines
- Fault tolerant

---
## How Distributed State Machines Advance

- The state transition function determines how changes occur 
- But *who* gets to change the state of the state machine?

---
## Who can add a Block to the Blockchain?

- This question can be solved with different rules:

- Round robin method
- Select a participant at random
- Selecting a participant that wins a contest or solves a puzzle (PoW)
- Selecting a participant that puts something at stake for the opportunity (PoS)
- Selecting a participant from an pre-approved list (PoA)

---
## Proposals: The Village

Imagine a village that needs to decide what structure to build next. One person will propose what to build, and then the rest must come to consensus about it.

Who gets to propose what to build?
- The mayor of the village (Central authority)
- One villager chosen at random (Random selection)
- A different villager each season (Round Robin)
- One of the town elders (Proof of Authority)
- The villager that wins a race (Proof of Work)
- The villager that puts up the most collateral if the idea fails (Proof of Stake)
- Whoever the most people vote for (Delegation)

<!-- Insert village image here -->

---

#  What if the participant is malicious?

<!-- RADHA- Here are some notes about what else could be done in the next slides:

1) The concept of a Blockchain as "a service that has certain guarantess" was important to Gav. 

Let's make sure to introduce that directly; in fact, a lot of his notes were about the 'service guarantees' of different Blockchains, including Polkadot. 

I think that this is a really unique way to look at Blockchains- basically, as a systems designer; Blockchains are a trust system that promises all users certain things (Service will not be interrupted, service will not be censored, there will be no systemic discrimination that goes against the rules of the protocol, liveness, shared history). Your job as a developer creating a Blockchain system is to ensure these services actually work as expected. 

2) Let's make sure to inlucde the idea of "disintermediation" 
    - Without intermediaries
    - Permissionless
    - Credible expectations of privacy and authenticity

3) Gav defined 'transactions' as "Packets of information with zero or more signatures attached.' That seems like an interesting definition, especially right after the crypto unit where they discussed signatures at length.

4)- Gav had this as notes on Consensus Algorithms: They define (1) "How to add blocks" and 2) "How to decide whether a block has been irrevertibly added?". I think that's a good framing, too, and it perhaps helps us combine the 'proposal' piece above (how the state transition function works to add blocks and what the rules are for who can add them) with the upcoming 'verification' step (How to decide whether a block has been irrevertibly added)

5) We should definitely define the exercises and activities for this lesson tomorrow. They can be conceptual or technical, but I think it's important

6) Of course, we will need diagrams throughout. I wonder if maybe we could use the classic basic diagram like this (https://i.insider.com/615619bfb414c10018633305?width=1000&format=jpeg&auto=webp) Ideally, a graphic like this can start simple and be put up front, and then be broken down, revisited and expanded throughout the lesson until it is comprehensive and really clear. For example,the 'computers approve of the change' step in that diagram is actually a huge topic involving all the consensus systems.

7) The design team's Icon Library that you had mentioned is ALMOST DONE and lives here: https://www.figma.com/file/FFvZ0jUWJ7G4SwrLGalpQn/Koto-Web3-Icons?node-id=0%3A1. Could be great to use in this lesson.

-->

---
# Proposal and Verification

- Validators

---

## Problem of Consensus

- Malicious actors
- Byzantine Generals Problem

---

## Byzantine Fault Tolerance

- Consensus algorithm allows a distributed system to reach a consensus even when a small amount of nodes demonstrate malicious behavior


---

## Proof of Work

- Conceived initially to deter Denial of Service (DoS) Attacks
- Proof of Waste?

---

## Open, distributed State Machines

  - How to select participants
  - How to advance state
  - How to agree on conflicting state


--- 
# For Bitcoin to emerge, we needed:

- Cryptography
- Distributed Systems
- The Blockchain data structure
---
## Bitcoin

- Peer to Peer money
- PoW
- The problem with Bitcoin: Not programmable


---

## Ethereum

- A computer at the center of the world
- PoW
- The problem with Ethereum: the queue

<!-- Gav's talk from https://www.youtube.com/watch?v=cLiTUNJV8eI -->

---

## Who secures the Blockchain?

- Breaking consensus
- Can honest behaviour be rewarded?
- Can malicious behaviour be punished?

---

## Proof of Stake

- Not exactly a consensus algorithm, but an incentive mechanism
- Rewards and Slashing
- Proof of distributed and staked Authority 

---

## Polkadot NPoS

- Nominated Proof of Staking
- Phragmen election
- Nominators and Validators
- Multiple objectives, arrive at optimal solution graph

---

## What is a State Machine?

- Simple state machines and redundancy
- Fault tolerance in distributed systems
- How distributed state machines advance

---

## Framework of Blockchain

- What does a blockchain provide? What is a blockchain solving?
- Neat overview of what problem blockchains solve?
- Cryptography Don't have to trust the conduit to have a reasonable expectation of privacy or of the origin of a message.
- Blockchain provides a service: don't need to trust a party to have guarantees.

---
 
## What service does Blockchain provide?

 - What is the service? What are the guarantees
    - Service
        - Shared computational resource
        - State machine
        - Many different parties who don't trust each other can interact
        - Logic is executed correctly
        - After some point, there is a very real expectation that it will not revert that state transition (append-only?)
        - Regardless of who you are, you have access to this machine- open access
    - Without intermediaries
        - Permissionless
        - Decentralized
        - Credible expectations of privacy and authenticity

---

# How Do We Solve These Needs?

- What are the nature of the solutions to these needs? 

- Anatomy of a Blockchain 
- Cryptographic Linked List (AKA Chained Blocks) - Each block has info coming in from external environment - Packets of information with zero or more signatures attached: we call these "Transactions" - **Axis 1:** Consensus Algorithms (How to 1) add blocks and 2) decide whether a block has been irrevertibly added?) - Consensus algorithm - 1 and 2 are combined in some algos and not in others - **Axis 2:** State Transition Funcion - Bitcoin: Spent output means that the output can no longer be spent again - Ethereum and Polkadot: State at the beginning of the block, at the end there is a deterministic alteration to a new state. - Polkadot:
  How do we come to a consensus about what a chain actually is? What are our 'service' guarantees - Whatever the accepted rules are for participation, they will be respected by the system. - Service will not be interrupted. - Respect the business logic - No systemic discrimination against the rules of the protocol - There could be rules that are necessary to provide the elements of service - Censorship-resistant - Two aspects of the service: - Liveness- always adding more transactions - When will a transaction be 'locked in' (and never reverted) - Bunch of participants in this multi-agent system who must determine what happens - Agreement on what's already been decided: Shared history - Two people will never have conflicting information and disagree. One might have MORE information, but the other will never believe that a different scenario is true. - Bitcoin - Smart Contract - Namecoin
- How does it actually work- trust without intermediaries?
  - Consensus Algorithms
    - Bitcoin (Nakomoto consensus/PoW)
      - PoW = Proof of Waste!
    - Proof of Authority (PoA)
      - Byzantine Agreement
      - Trust specific authorities to make the decisions
      - We want authorities that have stake in the system
      - Who gets to participate
        - PoW says everyone (weighted by hash power)
        - Requires special equipment, which is expensive
        - PoA says some finite set of authorities make decisions
    - Proof of Stake (PoS)
      - Longest chain PoS
      - PoS is an overloaded term; it might better be described as "Proof of Tokens"
      - Common security model; it continues
    - _Point of Confusion_: BABE, Tendermint, GRANDPA could also known as 'consensus algorithms'; - Which people are involved, how we get them involved.
      (history in academia and how it's used in Blockchain)
    - Individual consensus mechanisms that have PoS in their name
    - NPoS:
      - Staking
      - Rewarding
      - Balance Retention
      - Underlying Block Production
      - Finality Gadget
      - Nakomoto Consensus
      - Derivative Consensus (Parachain). derivative of a relay chain's finality system
  - State machine
- Consensus history

  - Proof of Work
  - Byzantine Agreement

- Timeline of Blockchain Innovations
  - Bitcoin/Nakomoto
    - Consensus: PoW
    - State Transition Function:
      - Crack shar-256 hashing
  - Namecoin
    - Consensus:
    - State Transition Function:
  - NXT?
    - Consensus: Proof of Stake (but terrible)
    - State Transition Function:
  - Ethereum
    - Consensus:
    - State Transition Function:
  - Polkadot
    - Consensus: BABE and GRANDPA (BABE is based on Proas)
    - State Transition Function:
  - Solana
    - Consensus: AURA
    - State Transition Function:
  - Cosmos
    - Consensus: Tendermint
    - State Transition Function:
  - Avalanche {[reference to blog comparison](https://medium.com/@arikan/a-comparison-of-heterogeneous-blockchain-networks-4bf7ff2fe279) to Polkadot and Cosmos}
    - Consensus:
    - State Transition Function:
  - ETH 2
    - Consensus: Casper/LMD/F50
    - State Transition Function:
  - DAGs...? (Hedera Hashgrpah, IOTA, ...)
    - Consensus: Casper/LMD/F50
    - State Transition Function:
  - Cardano
    - Consensus: Ouroboros PFT/AURA
    - State Transition Function:

**Substrate was created to solve the problem of every blockchain being isolated from one another**

- Open, distributed state machines
  - How to select participants
  - How to advance state
  - How to agree on conflicting state
- Security
  - Breaking consensus
  - Various forms of punishment
  - Security dilution
- Polkadot
  - NPoS
  - Aura, BABE, SASSAFRASS
  - GRANDPA
  - Slashing
- Parachains
  - Block authorship
  - Finality

## Activities and Exercises

These activities can be done in the language of the student's choice:

- Write a blockchain that advances. It does not need an interface (e.g. to submit transactions), but it should maintain some state (e.g. a timestamp) and should produce new blocks (they can be empty, but the headers would of course be unique).
- Write a fork choice rule.

## References

- [Alternativen zum Krypto-Mining: Warum Polkadot auf Proof-of-Stake setzt](https://www.heise.de/hintergrund/Alternativen-zum-Krypto-Mining-Warum-Polkadot-auf-Proof-of-Stake-setzt-6199450.html?seite=all) ([English version](https://drive.google.com/file/d/171hN-f3GINL2r3Yv-78XXKfSd6Sg68Nj/view?usp=sharing))
- Consensus Series: Parts [1](https://polkadot.network/polkadot-consensus-part-1-introduction/), [2](https://polkadot.network/polkadot-consensus-part-2-grandpa/), [3](https://polkadot.network/blog/polkadot-consensus-part-3-babe/), and [4](https://polkadot.network/blog/polkadot-consensus-part-4-security/)
- [Consensus in Polkadot (Presentation)](https://docs.google.com/presentation/d/1pTUFqdkyRa1C5mfzL-isyYGKqaFWdUAZraODO_WkSHs/edit#slide=id.g58f1ea59d2_0_6)
