# Lesson 1: 
# Overview of Blockchains

---

# Speaker

Gav Wood, Founder and CEO, Parity Technnologies

<!-- Insert Gav Wood Headshot here -->
---

## What is a Blockchain?

- A data structure
- Typically an ordered, back-linked list of blocks with data.
- Each block is identified by a hash
- The hashes protect the integrity of the data

<!--

Often visualized as a vertical stack

Terms such as “height” to refer to the distance from the first block, and “top” or “tip” to refer to the most recently added block.

Blockchains existed before bitcoin; NYT created a time and data pointer to the next block (MITOCW example) 
Surety - Oldest blockchain http://www.surety.com/digital-copyright-protection/prove-ownership
https://www.vice.com/en/article/j5nzx4/what-was-the-first-blockchain (1995)

Create a visual for the activity - The data in the blocks could be a timestamp and the price of some asset/temperature of a city in real time sampled at the timestamp.

<!-- Simple time stamp inside of a block, every six seconds we'll build a block. Each block has a hash of the data from the last block. Infographic which summarizes the activity which will happen later. The hash is the summary of the previous data. The hash pointer points to the next block. -->

---

# What Kind of Data makes sense to be on a Blockchain?

Typically, the blocks in a blockchain contain blockheaders and a payload

Although the payload could be any arbitrary data, it is mainly used for

- Record keeping - who, what, when, and why (ex: ledgers)
- Self-executing code (ex: smart contracts)
- Hashes of arbitrary data (ex: hashes of Images, videos as NFTs)

Q: Why not store the images and videos on the Blockchain?

<!--  This question will be revisited later on -->

---

# Blockchains are Immutable

- Blockchains cannot be modified... because that would change the hash of that block, which would break the blockchain
- The past blocks are fixed and can never be changed- and every new block depends on the past blocks.

## Therefore:

- Once a transaction is recorded, it can never be changed: this is what makes the blockchain record secure.

---

# Blockchains are Verifiable

Anyone can verify the authenticity of a Blockchain

- Hash review: A digital string of any length can be hashed into a fixed length (e.g., 256 bits)
- Each transaction can be 'verified' by an actor who knows what hashing algorithm was used and can run the same hashing algorithm on the data to verify that the hash matches.

## Therefore:

- Integrity of Data on Blockchains can be validated by anyone who knows the hashing algorithm used.

---


## Key Attributes of a Blockchain

What words come to your mind when you think of Blockchain Technology?

- Immutable
- Verifiable
- Distributed?
- Open?
- Transaprent?
- Anonymous?

---

# Blockchains are Decentralized (?)

Distributed vs Decentralized

- Decentralization: An open, accessible network that cannot be fully controlled by a single entity
- The Blockchain community usually sees decentralization as a core principle
- The pioneers of Blockchain technology always wanted Blockchain to be fully open and decentralized

---
# Blockchains are Decentralized (?)

- Contrary to popular belief, Blockchains are not by definition decentralized
- For example, the Hyperledger Blockchain can be fully controlled by one enterprise
- Blockchain purists don't even consider these to be real blockchains

---
# Decentralization Often Happens Through Distributed Systems

- Distributed systems use many different nodes to deliver a better service than a single central source
- The nodes do the same thing, which builds enormous redundancy and stability

---
# How do we make a blockchain decentralized?

- Distributed systems research dates back to the 1970s
- peer-to-peer distributed systems (like BitTorrent and Napster) showed up in early 2000s
- Free-riding problem!
- Distributed systems research + Incentive mechanisms, we can build a decentralized blockchain network that is entirely peer to peer with no central authority 


---
## Principles From Distributed Systems 

CAP Theorem

1. Consistency
2. Availability
3. Partition Tolerance

<!-- https://en.wikipedia.org/wiki/CAP_theorem -->


---
## Fault Tolerance in Distributed Systems

- Provide the desired service despite the presence of certain failures by exploiting redundancy (Hardware and Software)
- Services run on distributed servers to ensure that no one failure or attack on a server can bring down the entire system.
- The same data is replicated on multiple servers

<!-- 
Fault tolerance is the dynamic method that’s used to keep the interconnected systems together, sustain reliability, and availability in distributed systems. The hardware and software redundancy methods are the known techniques of fault tolerance in distributed system.  -->


---
## Protection Against Malicious Actors

- When you open the network for universal use, you no longer have control, and you will have malicious or faulty nodes.
- *Consensus* is the way we can fight bad actors and be resilient to faults.
- Byzantine generals problem

---
## Less Trust, More Truth

Blockchains can automate trust by being:

- immutable
- verifiable
- distributed and decentralized
- secured by consensus systems

<!-- Gav's talk from  https://www.youtube.com/watch?v=w7Z9AqhbpFs-->

---

## Disintermediation

    - Without intermediaries
    - Permissionless
    - Credible expectations of privacy and authenticity

---
### What Problems Does a Blockchain Solve?

- Situations where trust is traditionally held in a central entity

| Application   | Old Solution | Blockchain Solution
| ----------- | ----------- |
| Transferring Money | Banks | Frictionless P2P
| Contracts | Lawyers  | Smart Contracts
| Identity | State Agencies | Decentralized Identity

And many more...

---
## Blockchains as Finite State Machines

State Machines are deterministic

- The state of data in a block remains the same until a change occurs
- To change, there must be a trigger
- Triggers might be external or internal
- The *state transition function* is the core logic by which the blockchain data changes

---
## Deterministic State Transition Functions

Core logic of the state machine

- Same trigger will always lead to the same change
- All based on the rules of the state transition function

---
## What is a Distributed State Machine?

 Multiple copies of the same State Machine begin in the Start state, and receiving the same Inputs in the same order will arrive at the same State having generated the same Outputs.

- Replicated and redundant across several machines
- Fault tolerant

---
## How Distributed State Machines Advance

- The state transition function determines how changes occur 
- But *who* gets to change the state of the state machine?

---
## Who can add a Block to the Blockchain?

- This question can be solved with different rules:

- Round robin method
- Select a participant at random
- Selecting a participant that wins a contest or solves a puzzle (PoW)
- Selecting a participant that puts something at stake for the opportunity (PoS)
- Selecting a participant from an pre-approved list (PoA)

---
## Proposals: The Village

Imagine a village that needs to decide what structure to build next. One person will propose what to build, and then the rest must come to consensus about it.

Who gets to propose what to build?
- The mayor of the village (Central authority)
- One villager chosen at random (Random selection)
- A different villager each season (Round Robin)
- One of the town elders (Proof of Authority)
- The villager that wins a race (Proof of Work)
- The villager that puts up the most collateral if the idea fails (Proof of Stake)
- Whoever the most people vote for (Delegation)

<!-- Insert village image here -->

---

#  What if the participant is malicious?

<!-- RADHA- Here are some notes about what else could be done in the next slides:

1) The concept of a Blockchain as "a service that has certain guarantess" was important to Gav. 

Let's make sure to introduce that directly; in fact, a lot of his notes were about the 'service guarantees' of different Blockchains, including Polkadot. 

I think that this is a really unique way to look at Blockchains- basically, as a systems designer; Blockchains are a trust system that promises all users certain things (Service will not be interrupted, service will not be censored, there will be no systemic discrimination that goes against the rules of the protocol, liveness, shared history). Your job as a developer creating a Blockchain system is to ensure these services actually work as expected. 

2) Let's make sure to inlucde the idea of "disintermediation" 
    - Without intermediaries
    - Permissionless
    - Credible expectations of privacy and authenticity

3) Gav defined 'transactions' as "Packets of information with zero or more signatures attached.' That seems like an interesting definition, especially right after the crypto unit where they discussed signatures at length.

4)- Gav had this as notes on Consensus Algorithms: They define (1) "How to add blocks" and 2) "How to decide whether a block has been irrevertibly added?". I think that's a good framing, too, and it perhaps helps us combine the 'proposal' piece above (how the state transition function works to add blocks and what the rules are for who can add them) with the upcoming 'verification' step (How to decide whether a block has been irrevertibly added)

5) We should definitely define the exercises and activities for this lesson tomorrow. They can be conceptual or technical, but I think it's important

https://www.geeksforgeeks.org/create-simple-blockchain-using-python/
https://levelup.gitconnected.com/learn-blockchain-by-building-it-f2f8ccc54892
https://medium.com/coinmonks/python-tutorial-build-a-blockchain-713c706f6531

PoW example implementation

https://blog.gameoflife.co/implementing-a-simple-proof-of-work-algorithm-for-the-blockchain-bdcd50faac18



6) Of course, we will need diagrams throughout. I wonder if maybe we could use the classic basic diagram like this (https://i.insider.com/615619bfb414c10018633305?width=1000&format=jpeg&auto=webp) Ideally, a graphic like this can start simple and be put up front, and then be broken down, revisited and expanded throughout the lesson until it is comprehensive and really clear. For example,the 'computers approve of the change' step in that diagram is actually a huge topic involving all the consensus systems.

7) The design team's Icon Library that you had mentioned is ALMOST DONE and lives here: https://www.figma.com/file/FFvZ0jUWJ7G4SwrLGalpQn/Koto-Web3-Icons?node-id=0%3A1. Could be great to use in this lesson.

-->

---
# Proposal and Verification

- Validators

---

## Problem of Consensus

- Malicious actors
- Byzantine Generals Problem

---

## Byzantine Fault Tolerance

- Consensus algorithm allows a distributed system to reach a consensus even when a small amount of nodes demonstrate malicious behavior


---

## Proof of Work

- Conceived initially to deter Denial of Service (DoS) Attacks
- Proof of Waste?

---

## Open, distributed State Machines

  - How to select participants
  - How to advance state
  - How to agree on conflicting state


--- 
# For Bitcoin to emerge, we needed:

- Cryptography
- Distributed Systems
- The Blockchain data structure
---
## Bitcoin

- Peer to Peer money
- PoW
- The problem with Bitcoin: Not programmable


---

## Ethereum

- A computer at the center of the world
- PoW
- The problem with Ethereum: the queue

<!-- Gav's talk from https://www.youtube.com/watch?v=cLiTUNJV8eI -->

---

## Who secures the Blockchain?

- Breaking consensus
- Can honest behaviour be rewarded?
- Can malicious behaviour be punished?

---

## Proof of Stake

- Not exactly a consensus algorithm, but an incentive mechanism
- Rewards and Slashing
- Proof of distributed and staked Authority 

---

## Polkadot NPoS

- Nominated Proof of Staking
- Phragmen election
- Nominators and Validators
- Multiple objectives, arrive at optimal solution graph

---

## What is a State Machine?

- Simple state machines and redundancy
- Fault tolerance in distributed systems
- How distributed state machines advance

---

## Framework of Blockchain

- What does a blockchain provide? What is a blockchain solving?
- Neat overview of what problem blockchains solve?
- Cryptography Don't have to trust the conduit to have a reasonable expectation of privacy or of the origin of a message.
- Blockchain provides a service: don't need to trust a party to have guarantees.

---
 
## What service does Blockchain provide?

 - What is the service? What are the guarantees
    - Service
        - Shared computational resource
        - State machine
        - Many different parties who don't trust each other can interact
        - Logic is executed correctly
        - After some point, there is a very real expectation that it will not revert that state transition (append-only?)
        - Regardless of who you are, you have access to this machine- open access
    - Without intermediaries
        - Permissionless
        - Decentralized
        - Credible expectations of privacy and authenticity

---

# How Do We Solve These Needs?

- What are the nature of the solutions to these needs? 

- Anatomy of a Blockchain 
- Cryptographic Linked List (AKA Chained Blocks) - Each block has info coming in from external environment - Packets of information with zero or more signatures attached: we call these "Transactions" - **Axis 1:** Consensus Algorithms (How to 1) add blocks and 2) decide whether a block has been irrevertibly added?) - Consensus algorithm - 1 and 2 are combined in some algos and not in others - **Axis 2:** State Transition Funcion - Bitcoin: Spent output means that the output can no longer be spent again - Ethereum and Polkadot: State at the beginning of the block, at the end there is a deterministic alteration to a new state. - Polkadot:
  How do we come to a consensus about what a chain actually is? What are our 'service' guarantees - Whatever the accepted rules are for participation, they will be respected by the system. - Service will not be interrupted. - Respect the business logic - No systemic discrimination against the rules of the protocol - There could be rules that are necessary to provide the elements of service - Censorship-resistant - Two aspects of the service: - Liveness- always adding more transactions - When will a transaction be 'locked in' (and never reverted) - Bunch of participants in this multi-agent system who must determine what happens - Agreement on what's already been decided: Shared history - Two people will never have conflicting information and disagree. One might have MORE information, but the other will never believe that a different scenario is true. - Bitcoin - Smart Contract - Namecoin
- How does it actually work- trust without intermediaries?
  - Consensus Algorithms
    - Bitcoin (Nakomoto consensus/PoW)
      - PoW = Proof of Waste!
    - Proof of Authority (PoA)
      - Byzantine Agreement
      - Trust specific authorities to make the decisions
      - We want authorities that have stake in the system
      - Who gets to participate
        - PoW says everyone (weighted by hash power)
        - Requires special equipment, which is expensive
        - PoA says some finite set of authorities make decisions
    - Proof of Stake (PoS)
      - Longest chain PoS
      - PoS is an overloaded term; it might better be described as "Proof of Tokens"
      - Common security model; it continues
    - _Point of Confusion_: BABE, Tendermint, GRANDPA could also known as 'consensus algorithms'; - Which people are involved, how we get them involved.
      (history in academia and how it's used in Blockchain)
    - Individual consensus mechanisms that have PoS in their name
    - NPoS:
      - Staking
      - Rewarding
      - Balance Retention
      - Underlying Block Production
      - Finality Gadget
      - Nakomoto Consensus
      - Derivative Consensus (Parachain). derivative of a relay chain's finality system
  - State machine
- Consensus history

  - Proof of Work
  - Byzantine Agreement

- Timeline of Blockchain Innovations
  - Bitcoin/Nakomoto
    - Consensus: PoW
    - State Transition Function:
      - Crack shar-256 hashing
  - Namecoin
    - Consensus:
    - State Transition Function:
  - NXT?
    - Consensus: Proof of Stake (but terrible)
    - State Transition Function:
  - Ethereum
    - Consensus:
    - State Transition Function:
  - Polkadot
    - Consensus: BABE and GRANDPA (BABE is based on Proas)
    - State Transition Function:
  - Solana
    - Consensus: AURA
    - State Transition Function:
  - Cosmos
    - Consensus: Tendermint
    - State Transition Function:
  - Avalanche {[reference to blog comparison](https://medium.com/@arikan/a-comparison-of-heterogeneous-blockchain-networks-4bf7ff2fe279) to Polkadot and Cosmos}
    - Consensus:
    - State Transition Function:
  - ETH 2
    - Consensus: Casper/LMD/F50
    - State Transition Function:
  - DAGs...? (Hedera Hashgrpah, IOTA, ...)
    - Consensus: Casper/LMD/F50
    - State Transition Function:
  - Cardano
    - Consensus: Ouroboros PFT/AURA
    - State Transition Function:

**Substrate was created to solve the problem of every blockchain being isolated from one another**

- Open, distributed state machines
  - How to select participants
  - How to advance state
  - How to agree on conflicting state
- Security
  - Breaking consensus
  - Various forms of punishment
  - Security dilution
- Polkadot
  - NPoS
  - Aura, BABE, SASSAFRASS
  - GRANDPA
  - Slashing
- Parachains
  - Block authorship
  - Finality

## Activities and Exercises

These activities can be done in the language of the student's choice:

- Write a blockchain that advances. It does not need an interface (e.g. to submit transactions), but it should maintain some state (e.g. a timestamp) and should produce new blocks (they can be empty, but the headers would of course be unique).
- Write a fork choice rule.

## References

- [Alternativen zum Krypto-Mining: Warum Polkadot auf Proof-of-Stake setzt](https://www.heise.de/hintergrund/Alternativen-zum-Krypto-Mining-Warum-Polkadot-auf-Proof-of-Stake-setzt-6199450.html?seite=all) ([English version](https://drive.google.com/file/d/171hN-f3GINL2r3Yv-78XXKfSd6Sg68Nj/view?usp=sharing))
- Consensus Series: Parts [1](https://polkadot.network/polkadot-consensus-part-1-introduction/), [2](https://polkadot.network/polkadot-consensus-part-2-grandpa/), [3](https://polkadot.network/blog/polkadot-consensus-part-3-babe/), and [4](https://polkadot.network/blog/polkadot-consensus-part-4-security/)
- [Consensus in Polkadot (Presentation)](https://docs.google.com/presentation/d/1pTUFqdkyRa1C5mfzL-isyYGKqaFWdUAZraODO_WkSHs/edit#slide=id.g58f1ea59d2_0_6)
