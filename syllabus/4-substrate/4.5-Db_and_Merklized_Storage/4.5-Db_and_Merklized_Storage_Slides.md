Lecture 5, Module 4

Instructor: Shawn Tabrizi

---- 
# Database and Merklized Storage

In this section, we will learn about how the underlying storage layers in Substrate work and their behavior.

---

# Why is this topic important?

* To understand the main components of Substrate's storage system and how it serves the runtime.
* To make correct decisions when designing new runtime modules.

---

# Storage layers

### High level overview

There are core layers to Substrate's storage system.
  ┌────────────────────┐
  │Runtime Storage API │
  ├────────────────────┤
  │Overlay Change Set  │
  ├────────────────────┤
  │Patricia-Merkle Trie│
  ├────────────────────┤
  │Key-Value Database  │
  └────────────────────┘

TODO: Add proper diagram of storage layers

---
## Runtime Storage API

* `sp-io` can write to storage with a given key + value
* Substrate has macros that generate APIs to create different storage items as well as read/write to them

---
## Overlay Change Set

<div class="left">

* Stages changes to the underlying DB.
* Overlay changes are committed once per block.

</div>

<div class="right">

Two kinds of changes:

* Prospective Changes - what may happen.
* Committed Changes - what will happen.

</div>

---

## Patricia-Merkle Trie

<div class="left">

* [paritytech/trie](https://github.com/paritytech/trie)
* Data structure on top of KVDB
* Arbitrary Key and Value length
* Nodes are Branches or Leaves

TODO: review this

</div>

<div class="right">

![Diagram of trie](http://placehold.jp/150x150.png)

</div>

---

## Key-Value Database (KVDB) Layer

<div class="left">

* Implemented with RocksDB and Parity DB
* Just KV mapping: `Blake2_256` Hash -> `Vec<u8>`

</div>

<div class="right">

| Key (Hash) | Value (`Vec<u8>`) |
| -----| --------| 
| 0x0fd923ca5e7 | [00] |
| 0x92cdf578c47 | [01] |
| 0x31237cdb79 | [02] |
| 0x581348337b | [03] |

Note: There could also be some in-memory KVDB layer for testing purposes.

---

### RocksDB

A Persistent Key-Value Store for Flash and RAM Storage.

* Keys and values are arbitrary byte arrays
* Fast
* Secure

Note:
See http://rocksdb.org/.

---

### ParityDB

An Embedded Persistent Key-Value Store Optimized for Blockchain Applications.

* Designed for efficiently storing blockchain state encoded into a Patricia-Merkle trie
* Optimized write performance: "transactions"

Note:
"Transactions" here refers to "writes done in batches". 
In blockchains, writes are typically performed in large batches, when the new block is imported and must be done atomically.
See: https://github.com/paritytech/parity-db

---

### Two Kinds of Keys

1. Trie key path 
2. KVDB key hash

---
## Cost to Read and Write

* Runtime -> overlay is cheap, etc.
* Where are the bottlenecks?
* Don’t have to pay the hashing or disk access

TODO: ???

---

## Database Backend

* Trie DB
* Trie Root 
* Storage Proofs

---

## Patricia-Merkle Trie

[Parity's Trie implementation](https://github.com/paritytech/trie) provides a generic implementation of the Base-16 Modified Merkle Tree datastructure.

<div class="left">

* Substrate uses a Base-16 Patricia Trie
* Merkle tree allows you to easily prove that some data exists within the tree with a “Merkle Proof”.

</div>

<div class="right">

![Merkle tree](/reveal-md/assets/4.5/merkle-tree-1.png)

TODO: update image design.

</div>

---
### Merkle tree 

<div class="left">

* Root node: can be used to verify two trees are the same.
* Branch nodes
* Leaf nodes

</div>

<div class="right">

![Merkle tree](/reveal-md/assets/4.5/merkle-tree-1.png)

TODO: update image design.

</div>

---

### Patricia trie 

<div class="left">

* Position in the tree defines the associated key.
* Space optimized for elements which share a prefix. 

</div>

<div class="right">

![Merkle tree](/reveal-md/assets/4.5/patricia-trie-1.png)

TODO: update image design.

</div>

---

* Patricia provides the trie path.
* Merkle provides the recursive hashing of children nodes into the parent.
* The Trie key path is set by you, for e.g. `:CODE`.
* A trie node has arbitrary length containing a header, key, possible children, possible value.
* KVDB key = Hash([Trie Node])

---

## Complexity

* Reading
* Writing 

---

## Reading

* O(log n) reads

![Merkle tree](/reveal-md/assets/4.5/complexity-storage-reads.png)

TODO: Update diagram with design.

---
## Writing

<div class="left">

* Very expensive for a database
* O(log n) reads, hashes and writes

1. Follow the trie path to the value.
    * O(log n) reads
2. Write the new value.
    * 1 write
3. Calculate new hash
    * 1 hash
4. Repeat (2) + (3) up the trie path
    * O(log n) times

</div>

<div class="right">

![Merkle tree](/reveal-md/assets/4.5/complexity-storage-reads.png)

</div>

TODO: Update diagram with design (modify accordingly)

---

## Merkle Proof

<div class="left">

* O(log n)
* Great for light clients!
* Low bandwidth, low computation

</div>

<div class="left">

1. Full Node: Follow the trie path to the value.
    * O(log n) reads
2. Full Node: Upload data of trie nodes.
3. Light Client: Download trie node data.
4. Light Client: Verify by hashing.
    * O(log n) hashes

</div>

---

![Merkle tree](/reveal-md/assets/4.5/complexity-storage-reads.png)

TODO: Update diagram with design (modify accordingly)

---
## Exercise: discuss performance optimizations 

TODO: ask questions that relate to the work done here: https://github.com/paritytech/trie/pull/157 and https://github.com/paritytech/trie/pull/142 for students and lecturer to engage about optimizing state reads. Then look over the PR's motive.

---

## Overlay Deep dive

The overlay stages changes to the underlying database.

---

### Optimizations

* Minimize backend writes
* Minimize calculating storage root
* Only store consensus critical data in your runtime storage

---

Substrate ships with additional ["transactional" overlays](https://github.com/paritytech/substrate/blob/master/frame/support/src/storage/transactional.rs).

This provides an API for developers to write logic with multiple storage writes in a single transaction, where:
* Either the entire changes to storage are committed..
* Or nothing is committed at all.

Note:
With this storage overlay, you don't need to verify each and every storage access before doing a modification.
In module 6, we can take a closer look at how this functionality is enforced for all FRAME extrinsics (see: https://github.com/paritytech/substrate/pull/11431).

---

## How does the Runtime sees state?

* `root()`, `get()`, `set()`
* runtime sees state as a Key-Value
* this Key-Value in the client is a Merkle tree

---

## Manual pruning exercise

Let's demonstrate what pruning looks like for retaining only the old Merkle Trie nodes.

---

## Workshop and Activity

* [Database and Merklized Storage Workshop](./4.5-Workshops_and_Activities/4.5-Db_and_Merklized_Storage_Workshop.md)
* [Database and Merklized Storage Activity](./4.5-Workshops_and_Activities/4.5-Db_and_Merklized_Storage_Activities.md)
