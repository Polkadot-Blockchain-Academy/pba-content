## Host/Runtime Interface

Lecture 4, Module 4

Instructor: Bastian KÃ¶cher 

---- 

In this lesson we'll learn about how the client / runtime division in Substrate is one of the most important decisions that Substrate has taken. 
Thus, understanding the communication interface between the two is equally important.

---
### What does the runtime interface look like?
<div class="left">
The client and runtime need a way to communicate with eachother:

* The runtime uses host functions to get data from the client
* The client uses runtime apis to get data from the runtime
</div>

  ![Diagram of Substrate Client](http://placehold.jp/150x150.png)

  _TODO: diagram of two way communication between the Runtime api and host functions._

---
## Example: Block Execution

To execute a block, we need both host functions and runtime apis:

* `execute_block` (runtime API) - The client provides a block to the runtime, and expects the runtime
  to execute that block.

* Host Function - for example `storage_get` - To execute the block, the runtime will probably need to read
  storage, which only the client has access to.

---

## Runtime APIs

Some [existing runtime APIs]((https://github.com/paritytech/substrate/blob/master/bin/node/runtime/src/lib.rs#L1618) in Substrate include:

* Core
* TxQueue
* BlockBuilder

---

## Host functions

See [some existing host functions](https://github.com/paritytech/substrate/blob/master/primitives/io/src/lib.rs) in Substrate:

* crypto and hashing
* io
    * storage
    * print
* allocating memory

---

## Speed

* Wasm interfaces are slow to access
* Analogy: when contacting host function from Wasm, its like your OS contacting IO buffer

TODO

---

## Common errors

What could go wrong?

* If you have a runtime which expects a host function which does not exist, or vice versa your code will panic.
* Not any Wasm can be a Substrate Runtime, so using `std` libraries to print to the console could compile but will cause the runtime to panic.

---
## Versioning and backwards compatibility

* Host functions are **FOREVER**: when finalizing a block that uses a specific host function, you always
  need to keep the same host functions
* Imagine syncing your chain from scratch, every version of your blockchain's runtime will be needed
  to sync and get to the latest block.
* Thus your client must be able to provide all the host functions expected in the past and for
  present/future blocks.

Note: Distinguish the implications of adding/removing host functions (and the lack of implications when adding runtime api).

--- 
## Exercise 1

Let's walkthrough the existing host functions / runtime interfaces.

What runtime interface is most commonly used when developing?

---
## Feature gated runtime APIs and host functions

There are ways to implement runtime interfaces for development purposes, such as:
* Testing and verification: `try_runtime`
* Benchmarking: `frame_benchmarking`

Basically anything which should be executed locally (or non-consensus code path), and not on the public network.

---
## Polkadot Standard Proposals

* How might we introduce a new host function into the Polkadot ecosystem?

TODO
---

## How to write a Runtime API

* Use the `impl_runtime_api!` macro.
* No matter the return type, client sees the outcome as `Vec<u8>`.
* Client can always provide extra `at: Option<BlockNumber>`.

---

<div class="left">

* conveniently a rust trait
* always generic over `Block`.

</div>

<div class="right">

For example: 

```rust
	/// The `Metadata` api trait that returns metadata for the runtime.
	pub trait Metadata {
		/// Returns the metadata of a runtime.
		fn metadata() -> OpaqueMetadata;
	}
```

```rust
impl_runtime_api! {
	impl sp_api::Metadata<Block> for Runtime {
		fn metadata() -> OpaqueMetadata {
			OpaqueMetadata::new(Runtime::metadata().into())
		}
	}
}
```

</div> 

---
## How to write a Host Function

<div class="left">

* use the `#[runtime_interface]` attribute
* just like an ordinary Rust trait

</div>

<div class="right>

For example:

```rust
  #[runtime_interface]
  pub trait Storage {
    /// Returns the data for `key` in the storage or `None` if the key can not be found.
    fn get(&self, key: &[u8]) -> Option<Vec<u8>> {
      self.storage(key).map(|s| s.to_vec())
    }
```
</div>

---

## Bonus

* Why the way smart contract functions work is unusual (two-way)
* Instantiating multiple wasm instances

(TODO: see where to fit this section / what to add)