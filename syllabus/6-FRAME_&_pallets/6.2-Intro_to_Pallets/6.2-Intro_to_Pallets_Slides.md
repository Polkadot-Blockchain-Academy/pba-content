# Intro to Pallets

Lecture 2, Module 6

Instructors: Shawn Tabrizi and Kian Paimani

<hr>

Prerequisites:
    - BTreeMaps understood vs. HashMaps understood, but cannot be used in pallets

At the end of this lecture, you will learn:
     - All of the syntax of the pallet macros and pallet files
     - Best practices for designing a pallet
     - Considerations for designing a pallet

---

## What is a Pallet?

A pallet is a independent piece of logic which can extend the functionality of your Runtime.

At a high level, a pallet has the ability to execute logic and make changes to the underlying blockchain storage.

---

## Examples of Pallets

We can look at a chain like Polkadot and break down all of the functions you see in it to the separate pallets which compose it:

* Balances
* Staking
* "Governance"
	* Council
	* Democracy
* Multisig
* Utility
* and more...

---

## Why Pallets?

---

Braindump from 17/06/22:

- Pallet Storage
    - Refresh on key storage knowledge and considerations
    - Different Storage structures available to users
        - Storage Value
        - Storage Map
        - Double Map
        - N Map
        - Counted Map
    - When to use which storage structures, tradeoffs, etc
    - Custom types and their traits
        -  max encoded length
        -  Encode / Decode
        -  Default
        -  TypeInfo
        -  Partial Eq
        -  There are more traits we can touch on too
            - Exercise which theoretical optimizes weight vs max-encoded len calcs
            - do more exercises on choosing storage structures
    - `BoundedVec`, `BoundedSlice`, `BoundedBTreeMap`
    - `BTreeMap`, `BTreeSet`
        - `BTreeSet`: Imagine you want a list of validators which every validator is unique
            - Versus a vector, where inserting multiple times will duplicate the entry. `BTreeSet` eliminates duplication
        - `BTreeMap`: you want the same list of unique validators but you also want their balance, which is mapped
    - All storage macros do ultimately is generate unique keys for storage
        - Mimic a `BTreeSet` or `BTreeMap` with our storage
            - Storage whose value is `()` (true or false type things, using our maps as a set, or a storage value as true false)
            - consider why you would use a storage value with a btreeset/map vs a storage map
        - There are even special hacks for manually manipulating the storage key
        - You can always access sp-io directly
        - All pallets therefore can touch any storage in the whole blockchain, unlike contracts
    - Practical examples of key generation and how things like counted map work under the covers
    - Reading values when the database doesn't have it returns NONE
        - Explain the magic of `ValueQuery` and default
            - Writing the default value vs empty
    - Special Storage patterns
        - contains key
        - `decode_len` for vectors
        - append for vectors
        - sorted vectors with binary insert
            - Save one byte if you need a value
        - when decoding fails, what happens to storage reads
            - Hint at migration stuff later
    - Storage overlay and transactional considerations
        - Transaction Outcome
        - Lifecycle of a storage read / write
        - Adding additional stoarge layers if you want

- Pallet Calls / Dispatchables / Extrinsics
    - Now that users have learned about storage, naturally they should learn about the logic which can be used to manipulate storage
    - Origin is the first param of every dispatchable
        - How to handle origin
        - Fancy multi-origin checks
        - Custom origin type
    - Parameters for a call and considerations
        - Tell the history of us finding that call is too huge
        - Using BOX on certain call params
    - DispatchResult vs DispatchResultWithPostInfo: https://paritytech.github.io/substrate/master/frame_support/dispatch/index.html#
        - Used to refund weight
        - Can also be used to refund the fee

    - Weight for calls (hint at future benchmarking)
        - Weight classes
    - Call index
        - Explicit or Implicit definition
    - Considerations for writing calls
        - Do not have wildly varying call execution complexity
        - Break extrinsics into small bite sized, one function calls, then use things like batch to make things complex
        - Bounded loops and execution only
        - Never can panic
            - Explain why this is a vulnerability
            - Always handle your errors, especially now with transactional storage
        - Nested dispatch
            - Manipulating origin
            - adding additional storage layers
        - 
    - Best practices for writing state machines
        - Using enums and storage
        - Giving users single paths through your state machine
    - Further best practices: https://forum.parity.io/t/runtime-debugging-on-streoids/678


- Hooks
    - The other places where users can write logic to manipulate storage
    - Hooks should be lightweight and predictable
    - MUST HAVE Bounded complexity
    - NEVER PANIC, BUT REALLY THIS IS A NEVER
        - Actually bricks your chain, go home
    - On Initialize
        - Much preferred over on_finalize
        - We can do "variable" execution and simply return the weight, versus on-finalize needs to be predicted ahead of time
        - less chance to cause an overweight block at the beginning when the block is empty
        - Most of our "automated" logic uses on initialize
            - Examples: Parachain auction, staking validator selection, etc...
        - So rather than thinking "at the end of block N", consider writing code "at the beginning of block N+1"
    - On Finalize
        - Must know at the beginning of the block how much execution it would take
        - Give an example where each call to an extrinsic increases on finalize weight, and we include that weight into the weight of the extrinsic
        - Example of using this for "transient" storage items
    - BIG WARNING
        - Hooks are obviously very powerful, but MUST execute to transition from block to block
        - You cannot mess up here, you cannot return an error, this is really the most likely place to brick your chain

- Really light section on events and errors
    - Really we just need to cover syntax here
    - Nested errors
    - When to emit an event

- Pallet Struct itself
    - Other trait impls
    - generic impls
        - Access to T
    - What are all the things that are built on top of Pallet Struct
        - How calls are mapped to the struct
        - Outer runtime applies many traits to the pallet struct
        - Storage getters (kian can teach this)