# Intro to FRAME

Lecture 1, Module 6

Instructors: Shawn Tabrizi and Kian Paimani

<hr>

At the end of this lecture, you will be able to:

- Understand the facts and concepts about FRAME
- 


---

## What is FRAME?

Framework for Runtime Aggregation of Modularized Entities

Notes: we're going to be looking at what FRAME does and why it includes the macros it does, why its useful and why it's needed / created.

---

## What is FRAME?

    - Executive "Coordinator"
    - System Pallet
    - FRAME Support
        - Primitives
        - Macros

Notes: Recap from module 4 that the runtime is broken into two pieces (logic and storage).

---

- executive coordinator (think of a better word than coordinator)
    - Entry points for a developer
        - At beginning of block
            - runtime upgrade
            - on initialize
        - At the beginning of a extrinsic
            - Signed extension (pre dispatch)
            - Verify Unsigned
        - The extrinsic itself
            - Dispatch
            - Filtering
        - At the end of an extrinsic
            - Signed extension (post dispatch)
        - At the end of a block
            - on finalize

    - Touch again on the sync vs block production modes of the client, the runtime api, and ultimately the executive coordinator which does that.

    - Executive has the only assumption that all pallets implement certain traits.
        - And this ultimately ensured by FRAME macros that all of these traits are implemented. It is impossible to compile a FRAME pallet without having satisfied all the assumptions of FRAME Executive.

- FRAME System is MORE THAN a "Pallet"
    - Whereas all Pallets must abide by the assumptions of executive, [FRAME system](https://paritytech.github.io/substrate/master/frame_system/) is hardcoded into executive, and can have its own assumptions and logic.
        - Header type
        - Block number and block hash
        - Block weight
        - runtime version
        - etc...
    - So FRAME system holds many of the assumptions needed for any blockchain, and attempts to be low opinionated
        - You will notice there are no assumptions of a cryptocurrency
        - And FRAME system is hyper generic, we dont assume anything about:
            - Hash functions
            - block number type
            - account type
            - etc...
        - Probably we could even refactor accounts out of system
    - Even its pallet dispatchables are pretty low level:
        - set storage directly
        - remarks
        - (leave to sacha to fill in other features)

- FRAME Support
    - Primitives
        - A bunch of traits and types which are used everywhere
        - This is a bit of a implementation detail since rust does not allow for cyclic dependencies, so this is a nice home for some types which are used across multiple places
        - You might also note sp_runtime has some of these too, the ones in FRAME Support are the ones which are specifically applicable to pallets, versus the greater runtime.

- Patterns of FRAME
    - Outer/Inner Enums
        - Pallets can generate enums for various things
            - Call
            - Event
            - Error
        - At the runtime level, we wrap all of these enums into an "outer enum", which additionally wraps the pallet
        - NOTE: the calls do not include origin!
    - `<T: Config>` and generic types in general
        - https://github.com/shawntabrizi/substrate-trait-tutorial
        - Combine multiple configurable parameters in one trait instead of having multiple generics all over the place. 
        - `pallet::Pallet::<Account, Balance, Hash, Hasher, >`
        - `pallet::Pallet::<T: Config>`
    - Glue trait to not make pallets depends on one another. (prob. too early to mention this)
    - (kian to provide diagram of relationship between different parts)

Note TODO: double check accuracy of code against macro expansion for `Call`

```rust
enum OuterCall {
    Balances(BalancesCall)
    System(SystemCall)
}

enum BalancesCall { transfer(from, to, amount) }
enum SystemCall { remark (bytes) } 

impl Dispatchable for OuterCall { 
    fn dispatch(origin) -> {
        // show how dispatchable is basically a giant match statement. 
        match extrinsic {
            OutCall::Balances(inner) => inner.dispatch(origin),
        }
    }
}

impl Dispatchable for BalancesCall {
    fn dispatch(origin) -> {
        match balance_extrinsic {
            BalanceCall::transfer
        }
}
```

- Deep dive into Extrinsics, Dispatchables, Calls
        - `#[pallet::call]`
        - This macro implements the trait Dispatchable / Unfiltered Dispatchable
    - How dispatch happens
        - Executive has the apply function
        - Apply fucntion / trait is implemented on a "checked extrinsic"
        - This contains the logic for actually dispatching a call
        - dispatch function is litterally just like a match statement
            - Each pallet and extrinsic is mapped into a enum
            - routing some encoded bytes into the appropriate of a call is just l

- Deep dive into Origins
    - `#[pallet::origin]`
        - Only needed for pallets that want to **define** a new origin
            - frame-system defines some origins 
            - example from collective: https://paritytech.github.io/substrate/master/pallet_collective/enum.RawOrigin.html
    - Also has nested enums
    - utility in frame-system
    - ORIGIN !====== ACCOUNT
        - ensure_signed != signature verification
    - examples
        - signed 
        - unsigned
        - root
        - parachain
        - council
        - multisig
    - in class exercise: see macro expansion for outer enum (see: https://crates.parity.io/node_runtime/enum.OriginCaller.html)
    - Pattern: Input Origin for customizable priviliged operations.  
        - trait `EnsureOrigin`
        - Different from `#[pallet::origin]`
        - more like `trait Config { type SuperUserOrigin: EnsureOrigin }`

        
- Deep dive into Events
    - `#[pallet::Events]`
    - Events are managed by FRAME system
    - Also an outer enum thing
    - frame system defines a function called `deposit_event`
    - each pallet can use this function to deposit an event into frame system
    - explain this trait `type Event: From<Event<Self, I>> + IsType<<Self as frame_system::Config>::Event>;`
    - Events in system are just a long vec
    - YOU CANNOT READ THIS ITEM ON CHAIN, IT WILL FUCK UP YOUR POV
    - They persist at the end of the block, and then are immediately cleaned up at the beginning of the next block
    - events can have arbitrary data inside of it
    - should be considered low cost to include, but technically not zero
    - we should have a few slides and discussion on when events are and are not appropriate, and also what data inside of it
        - New validators, we obv do not include the list of valdiators (you can just look that up on chain)
        - Balance changes, we def want to make events, since generally changes of balances are opaque
        - Transaction payment was nice to add because there was a bunch of math happening in the background (weight to fee, and refund) and to know the fee amount was not trivial
        - etc...

- Deep dive into Errors
    - `#[pallet::Error]`
    - in sp_runtime: https://paritytech.github.io/substrate/master/sp_runtime/enum.DispatchError.html
    - all errors eventually become a "dispatch error", this is the thing that we expect all dispatchables to return if there is an error.
    - (Dispatch error is ALSO kind of like an outer enum)
        - DispatchError::BadOrigin
        - DisatpchError::Arithmetic(...)
    - `impl From<PalletError> for DispatchError { /* maps it to DispatchError::Module(...) */ }`
        - generated by the macro
        - Show impl 
    - Strings can also map to `DispatchError`
        - `impl From<&'static st> for DispatchError { /* maps it to DispatchError::Other(...) */ }`
    - Pallet Error must be less than 4 bytes
        - https://github.com/paritytech/substrate/pull/10242
    - Error enum cannot have inner values
    - 

- Deep dive into block resources
    - Length, Weight, ... 
    - `#[pallet::weight]`

- Deep dive into accounts
    - Account data, where it is stored,
    - Consumers, Refs,
    - Existential Deposit, account existence requirements. 