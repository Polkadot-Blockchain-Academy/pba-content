---
title: EVM, Solidity, and Vyper
description: Overview and history of the EVM and languages that compile to it.
  Focus on architecting real-world smart contracts.
---

# EVM

Ethereum Virtual Machine

* A VM designed specifically for the constraints and features of Ethereum

---v

## EVM Properties

* Deterministic: execution outcome easy to agree upon
* Spam-resistant: Opcodes and other resources are metered at a very granular level
* Turing-complete (with a caveat)
* Stack-based design
* Ethereum-specific (EVM can query block hash, etc.)

Note:

It is critical that the EVM be 100% deterministic and that each implementation
produce the same outcome. Even the smallest discrepancy between two running
nodes would lead to different block hashes, violating consensus about the
results. (TODO: too much elaboration? I'm sure other course material covers this).

Charging appropriately for each opcode is also critical in order to prevent
abuse. Opcodes which are underpriced can allow spam, allowing attackers to
force the network to do more work than are paid for by fees, or even outright
DoS.

---v

## Turing completeness and the Halting Problem

* EVM: Turing-complete instruction set

* But what about the Halting Problem?
* Obviously cannot allow infinite loops
* Solution: Gasometer, a way to pre-pay for each opcode execution

Note:

The Halting Problem tells us that it's not possible to know that an arbitrary
program will properly stop. To prevent such abuse, we check that there is gas
remaining before every single opcode execution. Since gas is limited, this
ensures that no EVM execution will run forever and that all work performed is
properly paid for.

---v

## Gasometer

* TODO: diagram, show that execution halts for each opcode to check gas balance
* TODO: talk about disadvantages (perf)
* TODO: talk about other resource metering?

---

# History of EVM

ideas:
* Early concepts (IIRC, was attempted to be built on Bitcoin first)
* Shortcomings of Ethereum (storage bloat, ...?)
* DAO & hardfork
* Important updates, Eth 2.0

---v

## Ethereum as first smart contracting platform

ideas: talk about the real-world problems that we can reflect on
* performance
* frontrunning (etc)
* hacks
* problems with aggregating smart contract protocols together

---v

## Idiosyncrasies

- Everything is 256bits
- No floating point arithmetic
- Revert
- Reentrancy
- ABI
- Exponential memory expansion cost

---

# EVM Concepts

---v

## Contract accoutns vs EOAs

An account is designated by a 160-bit account ID. These accounts can be controlled in
one of two ways: An `Externally-owned Account` or a `Contract Account`.

### Externally-owned Account (EOA)

* Traditional user-controlled account
* Can only be controlled via transactions signed with corresponding private keys
* Account ID generated by hashing public key

### Contract Account

* Controlled by code
* Created with immutable contract bytecode
* May only ever do precisely what the code specifies
* Account ID generated deterministically when bytecode is deployed

---v

## Bytecode

Executable code is stored on-chain in the form of bytecode. Only `Contract
Account`s have bytecode, and this bytecode controls what these accounts do when
they are interacted with.

TODO: example bytecode, etc.

---v

## Sandboxed Contract State

`Contract Account`s contain a sandboxed state, which stores everything that the
contract writes to storage. Contracts may not write to storage outside of their
own sandbox, but they can call other contracts whose bytecode *might* write to
their respective storage.

---v

## Calling contracts

TODO: talk about different ways to call (may need more context first)

---

# Programming the EVM

---v

## EVM Assembly

show an example

---v

## High Level Languages

- Solidity
- Vyper

---

# Solidity

Inspired by java
Been around a long time
... FIXME TODO

---v

## Semantics

FIXME TODO: IDK if this is really necessary.
Up to the instructor.

---v

## Dev Environment

Make it clear that students should have these tools installed already or should be doing their absolute best to install them as you go. They will need these tools immanently.

- Remix
- Metamask?
- Polkadot js?

Notes:

FIXME TODO: @notlesh, I'll leave it largely up to you what the standard dev environment should be. It is good to be flexible and let students use the tools they like. But many students will have no prior preference or experience, and we need to be able to recommend a fully concrete stack for them.

---v

## Flipper Example

Code along and explain as you go

---v

## Deployment and interaction with Flipper

---v

## Adder or Multiplier

write, deploy, interact

---v

## Beware Public Information

Show a few bad things that could be done to help develop blockchain thinking models.

- A call that only executes if the proper hard-coded password is passed as a param (insecure, the code and therefore the password is onchain)
- An attempted improvement where the password is not hardcoded. It is passed to the constructor and stored in a private variable. (still insecure. All storage is publicly visible from off-chain.)
- If time permits and students are digging this, try storing a hash in storage and requiring the presage as a password. This is actually secure for only-call-once functions. But if you intend to call it multiple times, the first call leaks the password publicly.

---

# Vyper

TODO Continue analogously to Solidity lesson.
Explain pythonic nature
Explain focus on safety (at least compared to solidity)
Show similar coding examples

---

# Summary
