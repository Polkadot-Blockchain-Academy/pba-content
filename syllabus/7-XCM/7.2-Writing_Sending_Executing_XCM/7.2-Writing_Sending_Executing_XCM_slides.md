---
title: Writing, Sending, and Execution of XCM # Also update the h1 header on the first slide to the same name
description: Describe your slides here
duration: 1 hour
instructors: ["Gavin Wood", "Keith Yeung"]
teaching-assistants: ["Dan Shields"]
---

# Writing, Sending, and Execution of XCM

### _Module 7, Lecture 2_

---

<div class="flex-container">
<div class="left text-right"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

<!-- TODO: add a good circularly cropped headshot of ou to the `assets/profile` folder  -->
<img style="width: 550px; float:right; margin-right:30px" src="../../assets/img/Shared/profile.png"/>

</div>
<div style="margin-top:130px" class="right text-left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### Instructor Name

<!-- .element: style="margin-bottom: -30px;" -->

#### _Position or Title_

<!-- .element: style="margin-left: 20px;" -->

- I am a Subject matter in X
- A bit about me

_[Twitter](https://twitter.com) // [LinkedIn](https://linkedin.com) // [Email](mailto:)_

</div>
</div>

---

### Outline

<!--
You can reference slides within this presentation like [this other slide](#at-the-end-of-this-lecture-you-will-be-able-to) by use of the header title.

Please make your lecture precise.

- Limit the main points in a lecture to five or fewer.
- Create effective visuals, analogies, demonstrations, and examples to reinforce the main points.
  {TAs and the Parity design team can assist! Please let us know marking an item here as `TODO`}
- Emphasize your objectives and key points in the beginning, as you get to them, and as a summary at the end.

-->

1. [Pre-requisites](#pre-requisites)
1. [Major topic A](#major-topic-a)
1. Major topic B
1. [Exercise X](#exercise-title)
1. Major topic C
1. [Conclusion](#conclusion)
1. [Next Steps](#next-steps)
1. [References](#references)

---

## Pre-requisites

No background in X is necessary. However, the following are expected:

- Y
- Z
- \\(\alpha\\)

---

### _At the end of this lecture, you will be able to:_

<!-- TODO: fill this in  -->

- Construct XCMs via a combination of basic instructions
- Contribute to the discussions on upcoming changes to the XCM format
- Understand the basic structure and architecture behind cross-consensus asset transfers

---

## XCM Communication Model

XCM is designed around four 'A's:

- **Agnostic**: No assumptions about Consensus System messaged
- **Absolute**: Guaranteed delivery, interpretation, and ordering
- **Asynchronous**: No assumption of blocking for sender/receiver
- **Asymmetric**: No results or callbacks (separately communicated!)

<!-- TODO: see if we still need to include anything more from the XCM format spec section 1.1 https://github.com/paritytech/xcm-format/#11-xcm-communication-model -->

Notes:

- **Agnostic**: XCM makes no assumptions about the nature of the Consensus System between which messages are being passed.
- **Absolute**: XCM messages are guaranteed to be delivered and interpreted accurately, in order and in a timely fashion.
- **Asynchronous**: XCM messages in no way assume that the sender will be blocking on its completion.
- **Asymmetric**: XCM messages do not have results. Any results must be separately communicated to the sender with an additional message.

---

## Async vs Sync

<!-- todo SME to expand and check content -->

XCM crossing the barrier between a single consensus system cannot generally be asynchronous.

Notes:
Generally, Consensus systems are not designed to operate async with external systems.
They intrinsically need to have a uniform state to reason about and

---

## XCM is "fire and forget"

XCM has no results:

- No errors reported to sender
- No callbacks for sender

Similar to UDP

Notes:
The receiver side can and does handle errors, but the sender will not be notified in any fashion.

---

## Async XCM

We _could_ have XCM describe async behavior but do not because:

- Complexity, custom per sender/receiver pair
- Expense of operating in fee-based systems
-

<!-- TODO go into details around the challenges of async messages, no ability to get real time error messages or feedback -->

Notes:
expensive to get feedback, no callbacks
design considerations for async messages

---

# XCM is an evolving format!

We are presently in V2 with V3 on the way!

Notes:
XCM is a work-in-progress, versioned format!
A goal of this module is to make you capable of contributing to it.

<!-- TODO: activity to look at proposed but not finalized addition (something like a ZK instruction set) -->

---

## The XCM format

- TODO: Cover all of https://github.com/paritytech/xcm-format
<!-- Walk through of document....
maybe too verbose? Needs to be parsed into slides.
Likely V3 as we will deliver in July 2022.
-->

Notes:

<!-- TODO: add detail for speaker -->

---

# XCM Protocols

Notes:
The format needs to be implemented, we will start with the first

---

## XCMP has two _meanings_

<!-- TODO: out of place? we want to discuss this somewhere... -->

1. Generalized category of transport mechanisms (HRMP, DMP, UMP)
   - These are not all concretely defined, an incorrectly used interchangeably
2. Concretely the one transport protocol for parachains on the same relay chain.

---

<img style="height: 100vh;" src="../../../assets/img/7-XCM/xcm-stack.png" alt="XCM stack"/>

#### _XCM Protocol Stack_

Notes:
Polkadot systems for executing XCM: UMP, DMP and XCMP.
UMP (Upward Message Passing) allows parachains to send messages to their relay chain.
DMP (Downward Message Passing) allows the relay chain to pass messages down to one of their parachains.
XCMP, which is perhaps the best known of them, allows the parachains to send messages between themselves.
In addition to sending messages between chains, XCM is also useful in other contexts, for transacting with a chain whose transaction format you don’t necessarily know well in advance.
With chains whose business logic changes little (for example Bitcoin), the transaction format — or the format used by wallets to send instructions to the chain —tends to remain exactly the same, or at least compatible, indefinitely.

---

### `MultiAsset` deep dive (limitations & gotchas)

<!-- TODO: Things to add as slides, not that we have context on all the concepts needed : -->

- Limits to how many multiassets can exist in the holding registrar
- Only supports NFTs and Fungibles, and only supports "identifying" these assets, versus representing any kind of underlying behavior
  - for example, when transferring an NFT, you only know its unique GUID, if you do a bunch of other logic around NFTs, obviously that information is not transferred
  - The behavior of NFT is chain local, you can't really transfer that...
- Complexity of managing multiple assets
  - Represented as a vector over the message
    - There is a strict limit to number of items in the vector
    - We also expect users to provide a certain level of ordering to the assets (nfts then fungibles)
  - Represented as a hash-map in the registrar
    - There is complexity overhead to map items from the vector into the hashmap, and to access values
- Unsupported assets and behavior
- Asset ID is either a multilocation (Concrete assets) or a byte vector (Abstract assets)
- Describe the MultiAsset APIs, manipulations, common behaviors, etc...

Notes:

<!-- TODO: add detail for speaker -->

---

TODO: Break down `AssetId` and `Fungibility` objects (not in this lesson, put to the next)

---

### `MultiAsset` Associated types

- `MultiAssets` - a set of `MultiAsset`
- `WildMultiAsset` - match (`All` ; `Allof`) against one or more `MultiAsset`
- `MultiAssetFilter` - wildcard _or_ list of definite assets to be specified

Notes:

<!-- TODO vut these dow, HTML comments for extra detail -->

`MultiAssets` is one of them and really just means a set of `MultiAsset` items.
Then we have `WildMultiAsset`; this is a wildcard which can be used to match against one or more `MultiAsset` items.
There are actually only two kinds of wildcard that it supports:
`All` (which matches against all assets) and `AllOf` which matches against all assets of a particular identity (`AssetId`) and fungibility.
Notably, for the latter, the amount (in the case of fungibles) or instance(s) (for non-fungibles) does not need to be specified and all are matched.
Finally, there is `MultiAssetFilter`.
This is used most often and is really just a combination of `MultiAssets` and `WildMultiAsset` allowing either a wildcard or a list of definite (i.e. not wildcard) assets to be specified.

Notes:

## <!-- TODO: add detail for speaker -->

## XCM Instruction Set

<!-- TODO: Instructions Deep Dive, split into slides in this lesson -->

- What are all the different available instructions
- How / When are they used
- Instructions patterns
  - We always start with taking a fee, and converting it to weight
  - We always end with a weight refund
  - Registering available assets
- Handling errors (similar to handling Results)
  - End early, or continue to execute further instructions
  - Error handler
- Logic trees (if/else) (double check this)
  - Expect asset

Notes:

<!-- TODO: add detail for speaker -->

---

## Deep dive into a specific instruction

- Note that instructions are composed of some static logic, and some logical hooks which can be configured by the user

- show a few examples of these hooks

Notes:

<!-- TODO: add detail for speaker -->

---

## ⛓ Moving Assets between Chains in XCM

<!-- TODO: add slide details, migrated paragraph to notes ;) -->

Notes:
Sending an asset to another chain is probably the most common use-case for inter-chain messaging.
Allowing one chain to administer another chain’s native asset allows for all sorts of derivative use-cases (no pun intended), the simplest being a decentralized exchange but generally grouped together as decentralized finance or DeFi.

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### ✨ Teleporting

<!-- TODO: add slide details, migrate this paragraph to notes ;) -->

For chains that trust each other (such a homogeneous shards under the same overall consensus and security umbrella), we can use a framework that Polkadot calls teleporting, which basically just means destroying an asset on the sending side and minting it on the receiving side.
This is simple and efficient — it only requires the coordination of the two chains and only involves one action on either side.
Unfortunately, if the receiving chain cannot 100% trust the sending chain to actually destroy the asset which it is minting (and indeed not to mint assets outside of the agreed rules for the asset), then the sending chain really has no basis for minting the asset on the back of a message.

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust
// XCM teleported (most of) 1 DOT from the Polkadot Relay Chain to its sovereign account on Statemint.
// We’ll assume that the fees are already paid on the Polkadot side.

WithdrawAsset((Here, 10_000_000_000).into()),
InitiateTeleport {
    assets: All.into(),
    dest: Parachain(1000).into(),
    xcm: Xcm(vec![
        BuyExecution {
            fees: (Parent, 10_000_000_000).into(),
            weight: 3_000_000,
        },
        DepositAsset {
            assets: All.into(),
            max_assets: 1,
            beneficiary: Parent.into(),
        },
    ]),
}

// When Statemint eventually gets the message, it looks like this:

ReceiveTeleportedAsset((Parent, 10_000_000_000).into()),
BuyExecution {
    fees: (Parent, 10_000_000_000).into(),
    weight: 3_000_000,
},
DepositAsset {
    assets: All.into(),
    max_assets: 1,
    beneficiary: Parent.into(),
},

```

</div>
</div>

Notes:

<!-- TODO: add detail for speaker -->

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### 🏦 Reserves

- TODO

</div>

Notes:

<!-- TODO: cut this down into a few key sentences for the speaker, HTML comments for extra detail -->

The name comes from reserve banking, where assets are held “in reserve” to give credibility to the idea that some issued promise is valuable.
For example, if we can reasonably believe exactly 1 “real” (e.g. Statemint or Relay Chain) DOT is redeemable for each “derivative” DOT issued on an independent parachain, then we can treat the parachain’s DOT as being economically equivalent to real DOT.
(Most banks do something called fractional reserve banking, which means they keep less than the face-value in reserve.
This works fine until too many people wish to redeem, and then everything can go quite wrong quite fast.) So, the reserve is the place which stores the “real” assets and, for the purposes of transferral, whose logic and security is trusted by both sender and receiver.
Any corresponding assets on the sender and receiver side would then be derivatives, but they would be backed with the “real” reserve asset 100%.
Assuming that the parachain behaved well (i.e. that it was bug-free and its governance didn’t decide to run off with the reserve), this would make the derivative DOT more or less of the same value as the underlying reserve DOT.
The reserve assets are held in the sender/receiver’s sovereign account (i.e. the account controllable by the sender or receiver chain) on the reserve chain, so there’s good reason that unless something went wrong with the parachain, they’d be well guarded.

---

#### _Reserve Asset Example_

```rust [0|4-8|8-17|17-29]
// Sending 1 DOT from parachain 2000 to parachain 2001, which use reserve-backed DOT on parachain 1000
// We’ll assume the fees are already paid on the sender side.

WithdrawAsset((Parent, 10_000_000_000).into()),
InitiateReserveWithdraw {
    assets: All.into(),
    dest: ParentThen(Parachain(1000)).into(),
    xcm: Xcm(vec![
        BuyExecution {
            fees: (Parent, 10_000_000_000).into(),
            weight: 3_000_000,
        },
        DepositReserveAsset {
            assets: All.into(),
            max_assets: 1,
            dest: ParentThen(Parachain(2001)).into(),
            xcm: Xcm(vec![
                BuyExecution {
                    fees: (Parent, 10_000_000_000).into(),
                    weight: 3_000_000,
                },
                DepositAsset {
                    assets: All.into(),
                    max_assets: 1,
                    beneficiary: ParentThen(Parachain(2000)).into(),
                },
            ]),
        },
    ]),
},

```

</div>
</div>

Notes:

<!-- TODO: add detail for speaker -->

---

## Weight (in XCM)

<!-- - TODO: Add some content -->

Notes:

<!-- TODO: add detail for speaker -->

---

## Exotic Stuff:

- Genesis, Logs, Signed Extensions
<!-- - TODO: Add some content -->

Notes:

## <!-- TODO: add detail for speaker -->

# Exercise title

### _Describe it here_

<!-- TODO: exercise indicator https://github.com/paritytech/polkadot-blockchain-academy/issues/67 -->

---
