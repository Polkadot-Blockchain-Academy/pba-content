---
title: Writing, Sending, and Execution of XCM # Also update the h1 header on the first slide to the same name
description: Describe your slides here
duration: 1 hour
instructors: ["Gavin Wood", "Keith Yeung"]
teaching-assistants: ["Dan Shields"]
---

# Writing, Sending, and Execution of XCM

### _Module 7, Lecture 2_

---

<div class="flex-container">
<div class="left text-right"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

<!-- TODO: add a good circularly cropped headshot of ou to the `assets/profile` folder  -->
<img style="width: 550px; float:right; margin-right:30px" src="../../assets/img/Shared/profile.png"/>

</div>
<div style="margin-top:130px" class="right text-left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### Instructor Name

<!-- .element: style="margin-bottom: -30px;" -->

#### _Position or Title_

<!-- .element: style="margin-left: 20px;" -->

- I am a Subject matter in X
- A bit about me

_[Twitter](https://twitter.com) // [LinkedIn](https://linkedin.com) // [Email](mailto:)_

</div>
</div>

---

### Outline

<!--
You can reference slides within this presentation like [this other slide](#at-the-end-of-this-lecture-you-will-be-able-to) by use of the header title.

Please make your lecture precise.

- Limit the main points in a lecture to five or fewer.
- Create effective visuals, analogies, demonstrations, and examples to reinforce the main points.
  {TAs and the Parity design team can assist! Please let us know marking an item here as `TODO`}
- Emphasize your objectives and key points in the beginning, as you get to them, and as a summary at the end.

-->

1. [Pre-requisites](#pre-requisites)
1. [Major topic A](#major-topic-a)
1. Major topic B
1. [Exercise X](#exercise-title)
1. Major topic C
1. [Conclusion](#conclusion)
1. [Next Steps](#next-steps)
1. [References](#references)

---

## Pre-requisites

No background in X is necessary. However, the following are expected:

- Y
- Z
- \\(\alpha\\)

---

### _At the end of this lecture, you will be able to:_

<!-- TODO: fill this in  -->

- Describe ...
- Navigate ...
- Justify ...

---

## XCM Communication Model

XCM is designed around four 'A's:

- **Agnostic**: No assumptions about Consensus System messaged
- **Absolute**: Guaranteed delivery, interpretation, and ordering
- **Asynchronous**: No assumption of blocking for sender/receiver
- **Asymmetric**: No results or callbacks (separately communicated!)

<!-- TODO: see if we still need to include anything more from the XCM format spec section 1.1 https://github.com/paritytech/xcm-format/#11-xcm-communication-model -->

Notes:

- **Asynchronous**: XCM messages in no way assume that the sender will be blocking on its completion.
- **Absolute**: XCM messages are guaranteed to be delivered and interpreted accurately, in order and in a timely fashion.
- **Asymmetric**: XCM messages do not have results. Any results must be separately communicated to the sender with an additional message.
- **Agnostic**: XCM makes no assumptions about the nature of the Consensus System between which messages are being passed.

---

# XCM is an evolving format!

We are presently in V2 with V3 on the way!

Notes:
XCM is a work-in-progress, versioned format!
A goal of this module is to make you capable of contributing to it.

<!-- TODO: activity to look at proposed but not finalized addition (something like a ZK instruction set) -->

---

## Async vs Sync

<!-- todo SME to expand and check content -->

XCM crossing the barrier between a single consensus system cannot generally be asynchronous.

Notes:
Generally, Consensus systems are not designed to operate async with external systems.
They intrinsically need to have a uniform state to reason about and

---

## XCM is "fire and forget"

XCM has no results:

- No errors reported to sender
- No callbacks for sender

Similar to UDP

Notes:
The receiver side can and does handle errors, but the sender will not be notified in any fashion.

---

## Async XCM

We _could_ have XCM describe async behavior but do not because:

- Complexity, custom per sender/receiver pair
- Expense of operating in fee-based systems
-

<!-- TODO go into details around the challenges of async messages, no ability to get real time error messages or feedback -->

Notes:
expensive to get feedback, no callbacks
design considerations for async messages

---

# XCM Protocols

Notes:
The format needs to be implemented, we will start with the first

---

## XCMP has two _meanings_

<!-- TODO: out of place? we want to discuss this somewhere... -->

1. Generalized category of transport mechanisms (HRMP, DMP, UMP)
   - These are not all concretely defined, an incorrectly used interchangeably
2. Concretely the one transport protocol for parachains on the same relay chain.

---

<img style="height: 100vh;" src="../../../assets/img/7-XCM/xcm-stack.png" alt="XCM stack"/>

#### _XCM Protocol Stack_

Notes:
Polkadot systems for executing XCM: UMP, DMP and XCMP.
UMP (Upward Message Passing) allows parachains to send messages to their relay chain.
DMP (Downward Message Passing) allows the relay chain to pass messages down to one of their parachains.
XCMP, which is perhaps the best known of them, allows the parachains to send messages between themselves.
In addition to sending messages between chains, XCM is also useful in other contexts, for transacting with a chain whose transaction format you don’t necessarily know well in advance.
With chains whose business logic changes little (for example Bitcoin), the transaction format — or the format used by wallets to send instructions to the chain —tends to remain exactly the same, or at least compatible, indefinitely.

---

### `MultiAsset` deep dive (limitations & gotchas)

<!-- TODO: Things to add as slides, not that we have context on all the concepts needed : -->

- Limits to how many multiassets can exist in the holding registrar
- Only supports NFTs and Fungibles, and only supports "identifying" these assets, versus representing any kind of underlying behavior
  - for example, when transferring an NFT, you only know its unique GUID, if you do a bunch of other logic around NFTs, obviously that information is not transferred
  - The behavior of NFT is chain local, you can't really transfer that...
- Complexity of managing multiple assets
  - Represented as a vector over the message
    - There is a strict limit to number of items in the vector
    - We also expect users to provide a certain level of ordering to the assets (nfts then fungibles)
  - Represented as a hash-map in the registrar
    - There is complexity overhead to map items from the vector into the hashmap, and to access values
- Unsupported assets and behavior
- Asset ID is either a multilocation (Concrete assets) or a byte vector (Abstract assets)
- Describe the MultiAsset APIs, manipulations, common behaviors, etc...

Notes:

<!-- TODO: add detail for speaker -->

---

### `MultiAsset` Associated types

- `MultiAssets` - a set of `MultiAsset`
- `WildMultiAsset` - match (`All` ; `Allof`) against one or more `MultiAsset`
- `MultiAssetFilter` - wildcard _or_ list of definite assets to be specified

Notes:

<!-- TODO vut these dow, HTML comments for extra detail -->

`MultiAssets` is one of them and really just means a set of `MultiAsset` items.
Then we have `WildMultiAsset`; this is a wildcard which can be used to match against one or more `MultiAsset` items.
There are actually only two kinds of wildcard that it supports:
`All` (which matches against all assets) and `AllOf` which matches against all assets of a particular identity (`AssetId`) and fungibility.
Notably, for the latter, the amount (in the case of fungibles) or instance(s) (for non-fungibles) does not need to be specified and all are matched.
Finally, there is `MultiAssetFilter`.
This is used most often and is really just a combination of `MultiAssets` and `WildMultiAsset` allowing either a wildcard or a list of definite (i.e. not wildcard) assets to be specified.

Notes:

## <!-- TODO: add detail for speaker -->

## XCM Instruction Set

<!-- TODO: Instructions Deep Dive, split into slides in this lesson -->

- What are all the different available instructions
- How / When are they used
- Instructions patterns
  - We always start with taking a fee, and converting it to weight
  - We always end with a weight refund
  - Registering available assets
- Handling errors (similar to handling Results)
  - End early, or continue to execute further instructions
  - Error handler
- Logic trees (if/else) (double check this)
  - Expect asset

Notes:

<!-- TODO: add detail for speaker -->

---

## Deep dive into a specific instruction

- Note that instructions are composed of some static logic, and some logical hooks which can be configured by the user

- show a few examples of these hooks

Notes:

<!-- TODO: add detail for speaker -->

---
