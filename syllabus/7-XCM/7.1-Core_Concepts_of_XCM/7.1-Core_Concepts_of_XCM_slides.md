---
title: Core Concepts, Terms, and Logic of XCM # Also update the h1 header on the first slide to the same name
description: Describe your slides here
duration: 1 hour
instructors: ["Gavin Wood", "Keith Yeung"]
teaching-assistants: ["Dan Shields"]
---

<!--
# Dan & Keith - Notes & TODO

## https://medium.com/polkadot-network/xcm-the-cross-consensus-message-format-3b77b1373392
- use Gav's blog -> slides for most content in this mod, and likely mod 2.

- [Moonbuilders Workshop: A Technical Introduction to XCM on Moonbeam](https://www.youtube.com/watch?v=5HD5rFBqvQ4)
    - [their docs on xcm](https://docs.moonbeam.network/builders/xcm/overview/)
    - Great overall intro, [slides are great](https://docs.google.com/presentation/d/1dKZiP1LUltfjJ4cHiB1XtJAGla3sngXSc7sFj84zRKk/)... might want to ask to use? Copy content perhaps
    - 39:20 demo code w/ xTokens (XC-20)
        - It's possible to have different versions for specific fields/xcm programs{?} (destination, beneficiary) in a single XCM? Why?
- Use examples from Shawn's workshop https://github.com/shawntabrizi/xcm-workshop
- MORE CONTENT: XCM testing and troubleshooting with Nacho & DS team

### [moonbeam slides](https://docs.google.com/presentation/d/1dKZiP1LUltfjJ4cHiB1XtJAGla3sngXSc7sFj84zRKk/edit#slide=id.g112909de4e6_0_92)

- slide 10:
  - sov account vs. a reserve ~~account~~ chain: These are not the same.
    - Have a reserve chain that could have
- slide 12:
  - might have the over-constricted/missing nuance/detail model vs this answer: Stack Exchange example: https://substrate.stackexchange.com/questions/37/how-can-i-transfer-assets-using-xcm/38#38
-->

# Core Concepts, Terms, and Logic of XCM

### _Module 7, Lecture 1_

---

<div class="flex-container">
<div class="left text-right"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

<!-- TODO: add a good circularly cropped headshot of ou to the `assets/profile` folder  -->
<img style="width: 550px; float:right; margin-right:30px" src="../../../assets/img/Shared/profile.png"/>
</div>
<div style="margin-top:130px" class="right text-left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### Instructor Name

<!-- .element: style="margin-bottom: -30px;" -->

#### _Position or Title_

<!-- .element: style="margin-left: 20px;" -->

- I am a Subject matter in X
- A bit about me

_[Twitter](https://twitter.com) // [LinkedIn](https://linkedin.com) // [Email](mailto:)_

</div>
</div>

---

### Outline

<!--
You can reference slides within this presentation like [this other slide](#at-the-end-of-this-lecture-you-will-be-able-to) by use of the header title.

Please make your lecture precise.

- Limit the main points in a lecture to five or fewer.
- Create effective visuals, analogies, demonstrations, and examples to reinforce the main points.
  {TAs and the Parity design team can assist! Please let us know marking an item here as `TODO`}
- Emphasize your objectives and key points in the beginning, as you get to them, and as a summary at the end.

-->

1. [Pre-requisites](#pre-requisites)
1. [Major topic A](#major-topic-a)
1. Major topic B
1. [Exercise X](#exercise-title)
1. Major topic C
1. [Conclusion](#conclusion)
1. [Next Steps](#next-steps)
1. [References](#references)

---

## Pre-requisites

- FRAME (Storage Items, Dispatchables, Event, Errors, etc.)
- Polkadot & parachains conceptually
- Assets (NFTs and fungibles)

---

### _At the end of this lecture, you will be able to:_

- Define the concepts, syntax, and terms of XCM
- Navigate exiting resources that relate to XCM
- Differentiate between XCM and message-passing protocols like XCMP

---

## What cross-chain use cases exist?

Performing operations on different blockchains?

How might you go about designing a _system_ to facilitate them?

Notes:
EXERCISE: ask the class to raise hands and postulate on generally what one might do.

---

## üé¨ Some Concrete Use-cases

1. Cross-consensus asset transfers
2. Execute platform-specific actions (extrinsics) such as governance voting
3. Enables single use-case chains e.g. [Statemint/e](https://github.com/paritytech/cumulus/tree/master/parachains/runtimes/assets) as asset parachains

Notes:
While the goal of XCM is to be general, flexible and future-proof, there are of course practical needs which it must address, not least the transfer of tokens between chains.
We need a way to reason about, and pay for, any required fees on the receiving CS.
Platform-specific action; for example, within a Substrate chain, it can be desirable to dispatch a remote call into one of its pallets to access a niche feature.
XCM enables a single chain to direct the actions of many other chains, which hides the complexity of multi-chain messaging behind an understandable and declarative API.

---

## Enter Cross _Consensus_ Messaging (XCM)

### XCM aims to be a _language communicating ideas between consensus systems._

---

## Cross _Consensus_?

### Consensus systems

A chain, contract or other global, encapsulated, state machine singleton

- Can be any programmatic state-transition system that exists within consensus which can send/receive datagrams
- It does not even have to be a _distributed_ system, only that it can form _some_ kind of consensus.

Notes:
A consensus system does not necessarily have to be a blockchain or a smart contract, it can be something that already exists in the Web 2.0 world, such as an AWS server.

---

## ü§ü A Format, not a Protocol

XCM is a **_messaging format_**.

- It is akin to the post card from the post office

It is _not_ a messaging protocol!

- A post card doesn't send itself!

Notes:
It cannot be used to actually ‚Äúsend‚Äù any message between systems; its utility is only in expressing what should be done by the receiver.
like many aspects core to Substrate, this separation of concerns empowers us to be far more generic and enable much more.
A post card relies on the postal service to get itself sent towards its receivers, and that is what a messaging protocol does.

---

## üò¨ Why not _native_ messages?

Drawbacks of relying on native messaging or transaction format:

<br>

1. Lack of uniformity between consensus systems on message format
2. Common cross-consensus use-cases do not map one-to-one to a single transaction
3. Operations on consensus systems have different assumptions e.g. fee payment

Notes:

1. A system which intends to send messages to more than one destination would need to understand how to author a message for each.
   On that note, even a single destination may alter its native transaction/message format over time.
   Smart contracts might get upgrades, blockchains might introduce new features or alter existing ones and in doing so change their transaction format.
2. Special tricks may be required to withdraw funds, exchange them and then deposit the result all inside a single transaction.
   Onward notifications of transfers, needed for a coherent reserve-asset framework, do not exist in chains unaware of others.
3. Some systems assume that fee payment had already been negotiated, while some do not.

---

## XCM Versioning

Based on the upcoming XCMv3

Most XCM can be auto-converted to the next version, but some require manual involvement

Every release only supports 2 versions: previous and current

Notes:
This would mean that when XCMv3 gets released, version 0 and 1 support will be dropped completely.
Expect a cadence of a release every 6 months.

---

## üìç Locations in XCM

`MultiLocation` = a **_relative_** location in the consensus multiverse.

All entities are addressed as paths to them, _relative_ to the current consensus system.

```rust
pub struct MultiLocation {
    pub parents: u8,
    pub interior: Junctions,
}
```

<!-- TODO DESIGN: consensus multiverse graphic, could use the ring w/ parachains and bridges (Dan) -->
<!-- use this: https://thefutureisnow.community/wp-content/uploads/polkadot-creator-suggests-15-june-for-first-kusama-parachain-slot-auction-1600x900.jpg -- make a FULL SCREEN image without any watermarks/logos showing if possible, no background or matching black background-->

Notes:
The `MultiLocation` type identifies any single _location_ that exists within the world of consensus.
Representing a scalable multi-shard blockchain such as Polkadot, a lowly ERC-20 asset account on a parachain, a smart contract on some chain, etc.
It is always represented as a location *relative* to the current consensus system, and never as an absolute path, due to the fact that the network structure can always change, and so absolute paths can quickly go out of date.

---

## Junction

A single item in a path to describe the relative location of a consensus system:

- `Parachain`
- `AccountId32`
- `PalletInstance`
- `GeneralKey`

Notes:
This is akin to a directory on a file path, e.g. the `foo` in `/foo/bar`.

---

## Junction*s*\*

Enum containing multiple `Junction`s

```rust
enum Junctions {
    X1(Junction),
    X2(Junction, Junction),
    X3(Junction, Junction, Junction),
    // ...
    X8(Junction, /*...*/),
}
```

Notes:
An array like `[Junction; 8]` or a `Vec` is explicitly not used in place of the `Junctions` enum. This is because `Vec`s cannot be pattern-matched, and arrays have a fixed size at compilation time, and thus unused `Junction` "element slots" will always be required to be filled in, bloating the _encoded_ size of a `Junctions` data structure.

---

## MultiLocation Examples

<!-- TODO DESIGN: use multilocation graphic from above and add labels in fragment / new slide here -->
<!-- Base on this set of slides: https://docs.google.com/presentation/d/18qRqqw73L9NTWOX1cfGe5sh484UgvlpMHGekQHu9_8M/edit#slide=id.g8063ab3d6f_0_1418 . If hard, just make these into images via screenshot & use full screen -->

- `../Parachain(1000)`: Evaluated within a parachain, this would identify our sibling parachain of index 1000. (In Rust we would write `MultiLocation { parents: 1, junctions: X1(Parachain(1000)) }` or alternatively `ParentThen(Parachain(1000)).into()`.)
- `../AccountId32(0x1234...cdef)`: Evaluated within a parachain, this would identify the 32-byte account 0x1234‚Ä¶cdef on the relay chain.
- `Parachain(42)/AccountKey20(0x1234...abcd)`: Evaluated on a relay chain, this would identify the 20-byte account 0x1234‚Ä¶abcd on parachain number 42 (presumably something like Moonbeam which hosts Ethereum-compatible accounts).

<!-- TODO: speak to an example of non-parachain multi-location that would use a bridge -->

Notes:
XCM reasons about addressing (as in a postal address) that must include understanding where you are, not just where you are going!
This will be very powerful later on (Origins)

<!-- TODO: does XCM explicitly need to know the Origin of the message? Could there be anonymous XCM? (no "return to sender" field on mail) -->

---

## Construct a `MultiLocation`!

1. What is _your_ location?

2. Where do you _want to send to_?

3. Write your `MultiLocation`!

Notes:
EXERCISE: Prompt students to decide whe a MultiLocation correctly.
Encourage non-trivial (but direct!) paths like a specific contract on a parachain from Bitcoin.
Call on students to state their path and where they want to go.

---

## Cross-Consensus Accounts

### Sovereign Account
Within a consensus system, an account which belongs to another consensus system

encoded_bits = encoded(b"para") ++ encoded(ParaID) ++ 000000...

Parachain sovereign account = decoded(encoded_bits)

**ParaID CAN change over time!** Don't hard code these into a dapp!!

Notes:
A parachain sovereign account is created via encoding the byte string "para" first, then concatenated with the encoded `ParaId`, and after that, padded with a number of 0's until a 32-byte array is created out of it.
Note that the concatenation of an encoded "para" byte string and an encoded `ParaId` is always equal to 8 bytes, since the "para" byte string is only 4 characters long and the `ParaId` is defined as a 32-bit unsigned integer, therefore we can never grow beyond 32 bytes and will always need additional trailing zeroes to pad it until the resultant array becomes 32 bytes large.
We must have a 32-byte array, because that is how an `AccountId32` can be decoded from.

---

## Cross-Consensus Origins

A `MultiLocation` denoting where an XCM originated from
- *Relative* to the current location

Can be converted into a pallet origin in a FRAME runtime
- Used for access control

Notes:
Since `MultiLocation`s are relative, when an XCM gets sent over to another chain, the origin location needs to be rewritten from the perspective of the receiver, before the XCM is sent to it. This is calling re-anchoring, and will be taught in later lessons.

---

## `MultiLocation` established!

Now we know how to describe the destination, what _do we want to send_?

Let's start with messages (XCVM Programs!) about **_assets_**.

Notes:

---

## ü§π Many models for transferring assets

1. "Remote control" an account on another system
2. Reserve transfers
3. Teleport transfers

Notes:
We might want to simply control an account on a remote chain, allowing the local chain to have an address on the remote chain for receiving funds and to eventually transfer those funds it controls into other accounts on that remote chain.

---

<img style="height: 100vh;" src="../../../assets/img/7-XCM/rm-tx.png" alt="Remote Transfer"/>
<img style="height: 100vh;" src="../../../assets/img/7-XCM/teleport.png" alt="Teleport"/>
<img style="height: 100vh;" src="../../../assets/img/7-XCM/reserve-tx.png" alt="Reserve Transfer"/>

<!-- TODO DESIGN: get these in nice flexbox side-by-side -->

Notes:

<!-- TODO: use examples from here https://medium.com/polkadot-network/xcm-the-cross-consensus-message-format-3b77b1373392 to describe the images -->

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### üí∞ `MultiAsset` in XCM

There are many _classes_ of assets (fungible, NFTs,...)

The datatype `MultiAsset` describes them all.

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust
struct MultiAsset {
   id: AssetId,
   fun: Fungibility,
}
```

</div>
</div>

Notes:
We would go more into details in future lessons.

---

## ü´Ä The XCVM

At the core of XCM lies the **Cross-Consensus Virtual Machine (XCVM)**.

A ‚Äúmessage‚Äù in XCM is an XCVM program.

The XCVM is a state machine, state is kept track in **Registers**.

Notes:
It‚Äôs an ultra-high level non-Turing-complete computer whose instructions are designed to be roughly at the same level as transactions.
Messages are one or more XCM instructions.
The program executes until it either runs to the end or hits an error, at which point it finishes up and halts.
An XCM executor following the XCVM specification is provided by Parity, and it can be extended or customized, or even ignored altogether and users can create their own construct that follows the XCVM spec.

---

### XCVM Instructions

XCM Instructions might change a register, they might change the state of the consensus system or both.

One example of such an instruction would be `TransferAsset` which is used to transfer an asset to some other address on the remote system.
It needs to be told which asset(s) to transfer and to whom/where the asset is to be transferred.

```rust
enum Instruction {
    TransferAsset {
        assets: MultiAssets,
        beneficiary: MultiLocation,
    }
    /* snip */
}
```

Notes:

<!-- TODO: add detail for speaker -->

---

## XCVM Instructions preview

Four kinds of instructions:

- Instruction
- Trusted Indication
- Information
- System Notification

Notes:
`Instruction` is a bad name for the kind of XCVM instructions that we have, but it means instructions that result in a state change in the local consensus system, or instruct the local consensus system to achieve some desired behaviour.

<!-- TODO example of XCM message that intuitively makes sense for students that can reason about assets and fees, highlight lines in code block and talk to them. Highlight LOCATION and ASSET instructions, that we will go into next -->

---

## XCVM Registers

<!-- TODO: split each register into slides to talk to each explicitly -->

```rust
pub struct XcmExecutor<Config: config::Config> {
    holding: Assets,
    holding_limit: usize,
    context: XcmContext,
    original_origin: MultiLocation,
    trader: Config::Trader,
    error: Option<(u32, XcmError)>,
    total_surplus: u64,
    total_refunded: u64,
    error_handler: Xcm<Config::Call>,
    error_handler_weight: u64,
    appendix: Xcm<Config::Call>,
    appendix_weight: u64,
    transact_status: MaybeErrorCode,
    fees_mode: FeesMode,
    topic: Option<[u8; 32]>,
    _config: PhantomData<Config>,
}
```

- Registers _are_ the state of XCVM
- Note that XCVM registers are temporary/transient

Notes:

<!-- TODO: add detail for speaker -->

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### üíÅ The Holding Register

`WithdrawAsset` has no location specified for assets.

They are _temporarily_ held in what in the Holding Register.

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust
WithdrawAsset(MultiAssets),

// There are a number of instructions which operate on the Holding Register.
// One very simple one is the `DepositAsset` instruction.

enum Instruction {
    DepositAsset {
        assets: MultiAssetFilter,
        max_assets: u32,
        beneficiary: MultiLocation,
    },
    /* snip */
}
```

</div>
</div>

Notes:
Let‚Äôs take a look at another XCM instruction: `WithdrawAsset`. On the face of it, this is a bit like the first half of `TransferAsset`: it withdraws some assets from the account of the place specified in the Origin Register.
But what does it do with them? ‚Äî if they don‚Äôt get deposited anywhere then it‚Äôs surely a pretty useless operation.

---

## Key configurable XCM

- Barrier
- WeightTrader
- XcmSender
- OriginConverter
- AssetTransactor

Notes:
There are more, but these are the key ones that are important enough to be mentioned, others are sort of optional features that can be configured with `()`.

---

## Barrier

Specifies whether or not an XCM is allowed to be executed on the local consensus system.

Notes:
This is the configurable "firewall" rules that gets to judge and decide whether or not an XCM can be executed locally.
It is **highly** important to configure this correctly, otherwise XCMs gets dropped, or the local consensus system becomes vulnerable to DDoS attacks.

---

## XcmSender

Specifies the message passing protocol that the XCM executor uses to send XCMs

Notes:
This is what ties XCM and XCMP together, and can take a tuple to allow for various kinds of message passing protocols to attempt to send XCMs to different destinations, e.g. a parachain can include an `ParentAsUmp` router to communicate with the relay chain and an `XcmpQueue` pallet to send/receive XCMs from other sibling parachains.
 
---

## ü§ë Fee payment in XCM

Most systems require these to mitigate ‚Äútransaction spam‚Äù and a denial-of-service (DOS) attacks.

XCM does _not_ include the idea of fees and fee-payment as a first-class citizen

Notes:
Exceptions to this exist when chains have good reason to believe that their interlocutor will be well-behaved‚Äîthis is the case when the Polkadot Relay Chain corresponds with the Polkadot Statemint common-good chain.
However for the general case, fees are a good way of ensuring that XCM messages and their transport protocols cannot be over-used.
Like Rust with its zero-cost abstractions, fee payment comes with no great design overhead in XCM.

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### XCM with Fees Example

For systems that do require some fee payment though, XCM provides the ability to buy execution resources with assets. Doing so, broadly speaking, consists of three parts:

1. Assets provided
2. Negotiate exchange of assets for compute time (weight)
3. XCM operations will be performed as instructed

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust [1|]
WithdrawAsset((Here, 10_000_000_000).into()),
BuyExecution {
    fees: (Here, 10_000_000_000).into(), // MultiAsset
    weight: 3_000_000, // u64
},
DepositAsset {
    assets: All.into(), // MultiAssets
    max_assets: 1,
    beneficiary: Parachain(1000).into(), // MultiLocation
},
```

</div>
</div>

Notes:
The first part is managed by one of a number of XCM instructions which provide assets.
We already know one of these (WithdrawAsset), but there are several others which we will see later.
The resultant assets in the Holding Register will of course be used for paying fees associated with executing the XCM.
Any assets not used to pay fees we will be depositing in some destination account.
For our example, we‚Äôll assume that the XCM is happening on the Polkadot Relay Chain and that it‚Äôs for 1 DOT (which is 10,000,000,000 indivisible units).
This brings us to the second part, exchanging (some of) these assets for compute time to pay for our XCM.
For this we have the XCM instruction BuyExecution.
Let‚Äôs take a look at it:
The first item fees is the amount which should be taken from the Holding Register and used for fee-payment.
It‚Äôs technically just the maximum since any unused balance is immediately returned.
The amount that ends up being spent is determined by the interpreting system ‚Äî fees only limits it and if the interpreting system needs to be paid more for the execution desired, then the BuyExecution instruction will result in error.
The second item specifies an amount of execution time to be purchased.
This should generally be no less than the weight of the XCM programme in total.
In our example we‚Äôll assume that all XCM instructions take a million weight, so that‚Äôs two million for our two items so far (WithdrawAsset and BuyExecution) and a further one for what‚Äôs coming next.
We‚Äôll just use all the DOT that we have to pay those fees (which is only a good idea if we trust the destination chain not to have crazy fees ‚Äî we‚Äôll assume that we do).
The third part of our XCM comes in depositing the funds remaining in the Holding Register.
For this we will just use the DepositAsset instruction.
We don‚Äôt actually know how much is remaining in the Holding Register, but that doesn‚Äôt matter since we can specify a wildcard for the asset(s) which should be deposited.
We‚Äôll place them in the sovereign account of Statemint (which is identified as Parachain(1000).

---

## Exercise instructions

<!--
Detail what you want students to do in your exercise
Most exercises are less than 15 minuets in length.
-->

1.
1.
1.

Notes:
Make sure to include things here to say to students, perhaps a hint or two.
Realize that students will be able to view the speaker's notes, as they will have access to them on their devices.

<!-- TODO: exercise indicator https://github.com/paritytech/polkadot-blockchain-academy/issues/67 -->

---

## Conclusion

<!-- Summarize what we just learned, and put it in the bigger picture of what the Academy and Web3 are all about.
-->

---

## Next steps

<!--
Compile a list of:
- topics not covered here but students should consider learning about independently
- examples of the concepts covered in this lesson applied to a project, to case-study
- useful resources related to the lesson

- Reference other slides/materials by relative directory in this repo, like the [copy-paste slide templates](../../content-templates/slides/copy-paste-reveal-template-slides.md)
-->

1. Gav's blog series introducing XCM: Parts [1](https://medium.com/polkadot-network/xcm-the-cross-consensus-message-format-3b77b1373392), [2](https://medium.com/polkadot-network/xcm-part-ii-versioning-and-compatibility-b313fc257b83), and [3](https://medium.com/polkadot-network/xcm-part-iii-execution-and-error-management-ceb8155dd166).
1. XCM Format [repository](https://github.com/paritytech/xcm-format)
1. <!-- TODO: fill this in - polkadot / cumulus / parachains repos?  -->

---

## References

<!--
Compile an **annotated** list of URLs to source material referenced in making these lessons.
Ideally this is exhaustive, it can be cleaned up before delivery to students, but must include _why_ a reference is used.
For example:

- [ss58-registry](https://github.com/paritytech/ss58-registry) - A list of known SS58 account types as an enum, typically used by the Polkadot, Kusama or Substrate ecosystems.
- [wiki on parathreads](https://wiki.polkadot.network/docs/learn-parathreads) - A description of the parathread model.
-->

---

## Glossary

<!-- TODO: ensure these are in the class glossary! Remove this slide and simply reference in the slides -->

- UMP (Upward Message Passing) allows parachains to send messages to their relay chain.
- DMP (Downward Message Passing) allows the relay chain to pass messages down to one of their parachains.
- HRMP (Horizontal Message Passing)
- XCM
- XCVM
- XCMP (Cross-Consensus Message Passing), which is perhaps the best known of them, allows the parachains to send messages between themselves.
- {XCM} Junctions
- MultiLocations
- Sovereign account(s)
- Holding register
- Consensus system
- {XCM} Instructions
- {XCM config} Barriers
- {XCM config} Filters
- UDP {networking}
- TTL {networking}
