---
title: Core Concepts, Terms, and Logic of XCM # Also update the h1 header on the first slide to the same name
description: Describe your slides here
duration: 1 hour
instructors: ["Gavin Wood", "Keith Yeung"]
teaching-assistants: ["Dan Shields"]
---

<!--
# Dan & Keith - Notes & TODO

## https://medium.com/polkadot-network/xcm-the-cross-consensus-message-format-3b77b1373392
- use Gav's blog -> slides for most content in this mod, and likely mod 2.

- [Moonbuilders Workshop: A Technical Introduction to XCM on Moonbeam](https://www.youtube.com/watch?v=5HD5rFBqvQ4)
    - [their docs on xcm](https://docs.moonbeam.network/builders/xcm/overview/)
    - Great overall intro, [slides are great](https://docs.google.com/presentation/d/1dKZiP1LUltfjJ4cHiB1XtJAGla3sngXSc7sFj84zRKk/)... might want to ask to use? Copy content perhaps
    - 39:20 demo code w/ xTokens (XC-20)
        - It's possible to have different versions for specific fields/xcm programs{?} (destination, beneficiary) in a single XCM? Why?
- Use examples from Shawn's workshop https://github.com/shawntabrizi/xcm-workshop
- MORE CONTENT: XCM testing and troubleshooting with Nacho & DS team

### [moonbeam slides](https://docs.google.com/presentation/d/1dKZiP1LUltfjJ4cHiB1XtJAGla3sngXSc7sFj84zRKk/edit#slide=id.g112909de4e6_0_92)

- slide 10:
  - sov account vs. a reserve ~~account~~ chain: These are not the same.
    - Have a reserve chain that could have
- slide 12:
  - might have the over-constricted/missing nuance/detail model vs this answer: Stack Exchange example: https://substrate.stackexchange.com/questions/37/how-can-i-transfer-assets-using-xcm/38#38
-->

# Core Concepts, Terms, and Logic of XCM

### _Module 7, Lecture 1_

---

<div class="flex-container">
<div class="left text-right"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

<!-- TODO: add a good circularly cropped headshot of ou to the `assets/profile` folder  -->
<img style="width: 550px; float:right; margin-right:30px" src="../../../assets/img/Shared/profile.png"/>
</div>
<div style="margin-top:130px" class="right text-left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### Instructor Name

<!-- .element: style="margin-bottom: -30px;" -->

#### _Position or Title_

<!-- .element: style="margin-left: 20px;" -->

- I am a Subject matter in X
- A bit about me

_[Twitter](https://twitter.com) // [LinkedIn](https://linkedin.com) // [Email](mailto:)_

</div>
</div>

---

### Outline

<!--
You can reference slides within this presentation like [this other slide](#at-the-end-of-this-lecture-you-will-be-able-to) by use of the header title.

Please make your lecture precise.

- Limit the main points in a lecture to five or fewer.
- Create effective visuals, analogies, demonstrations, and examples to reinforce the main points.
  {TAs and the Parity design team can assist! Please let us know marking an item here as `TODO`}
- Emphasize your objectives and key points in the beginning, as you get to them, and as a summary at the end.

-->

1. [Pre-requisites](#pre-requisites)
1. [Major topic A](#major-topic-a)
1. Major topic B
1. [Exercise X](#exercise-title)
1. Major topic C
1. [Conclusion](#conclusion)
1. [Next Steps](#next-steps)
1. [References](#references)

---

## Pre-requisites

- FRAME (Storage Items, Dispatchables, Event, Errors, etc.)
- Polkadot & parachains conceptually

---

### _At the end of this lecture, you will be able to:_

<!-- TODO: fill this in  -->

- Define the concepts, syntax, and terms of XCM
- Navigate exiting resources that relate to XCM
- Differentiate between XCM and XCMP-like protocols
- {more?}

---

## ü§ü A Format, not a Protocol

XCM is a **_messaging format_**. It is _not_ a messaging protocol.

XCM aims to be a _language communicating ideas between consensus systems._

Notes:
It cannot be used to actually ‚Äúsend‚Äù any message between systems; its utility is only in expressing what should be done by the receiver.

---

## XCMP has two _meanings_

<!-- TODO: out of place? we want to discuss this somewhere... -->

1. Generalized category of transport mechanisms (HRMP, DMP, UMP)
   - These are not all concretely defined, an incorrectly used interchangeably
2. Concretely the one transport protocol for parachains on the same relay chain.

---

<img style="height: 100vh;" src="../../../assets/img/7-XCM/xcm-stack.png" alt="XCM stack"/>

#### _XCM Protocol Stack_

Notes:
Polkadot systems for executing XCM: UMP, DMP and XCMP.
UMP (Upward Message Passing) allows parachains to send messages to their relay chain.
DMP (Downward Message Passing) allows the relay chain to pass messages down to one of their parachains.
XCMP, which is perhaps the best known of them, allows the parachains to send messages between themselves.
In addition to sending messages between chains, XCM is also useful in other contexts, for transacting with a chain whose transaction format you don‚Äôt necessarily know well in advance.
With chains whose business logic changes little (for example Bitcoin), the transaction format ‚Äî or the format used by wallets to send instructions to the chain ‚Äîtends to remain exactly the same, or at least compatible, indefinitely.

---

## üò¨ Why not _native_ messages?

Piggybacking on the native message/transaction format drawbacks:

<br>

1. Lack of compatibility between consensus systems
2. Common XCMs cannot "fit" into a single transaction/extrinsic
3. Most models today assume fee-payment has already been negotiated, like smart contract messages

Notes:

1. A system which intends to send messages to more than one destination would need to understand how to author a message for each. On that note, even a single destination may alter its native transaction/message format over time. Smart contracts might get upgrades, blockchains might introduce new features or alter existing ones and in doing so change their transaction format.
2. Special tricks may be required to withdraw funds, exchange them and then deposit the result all inside a single transaction. Onward notifications of transfers, needed for a coherent reserve-asset framework, do not exist in chains unaware of others.
3. Transaction envelopes, in comparison, provide some system for payment of processing, but are also generally designed to contain a signature which is not something that makes sense when communicating between consensus systems.

---

## üé¨ Some Concrete XCM Use-cases

1. Cross-consensus transfers
2. (Optional) payment of fees
3. Execute platform-specific actions (extrinsics)

Notes:
While the goal of XCM is to be general, flexible and future-proof, there are of course practical needs which it must address, not least the transfer of tokens between chains.
We might want to simply control an account on a remote chain, allowing the local chain to have an address on the remote chain for receiving funds and to eventually transfer those funds it controls into other accounts on that remote chain.

- Platform-specific action; for example, within a Substrate chain, it can be desirable to dispatch a remote call into one of its pallets to access a niche feature.
- This could include "remote control" of accounts on other consensus systems.

---

## ü§π Many models for transferring assets

1. "Remote control" an account on another system
2.

Notes:

1. Remote: allowing the local chain to have an address on the remote chain for receiving funds and to eventually transfer those funds it controls into other accounts on that remote chain.

---

<img style="height: 100vh;" src="../../../assets/img/7-XCM/rm-tx.png" alt="XCM stack"/>
<img style="height: 100vh;" src="../../../assets/img/7-XCM/teleport.png" alt="XCM stack"/>
<img style="height: 100vh;" src="../../../assets/img/7-XCM/reserve-tx.png" alt="XCM stack"/>

<!-- TODO DESIGN: get these in nice flexbox side-by-side -->

Notes:
TODO: use examples from here https://medium.com/polkadot-network/xcm-the-cross-consensus-message-format-3b77b1373392 to describe the images

---

## ü´Ä The XCVM

At the core of XCM lies the **Cross-Consensus Virtual Machine (XCVM)**.

A ‚Äúmessage‚Äù in XCM is actually just a programme that runs on the XCVM.

Notes:
It‚Äôs an ultra-high level non-Turing-complete computer whose instructions are designed to be roughly at the same level as transactions.
Messages are one or more XCM instructions. The programme executes until it either runs to the end or hits an error, at which point it finishes up (I‚Äôm leaving that intentionally unexplained for now) and halts.

---

## üìç Locations in XCM

The `MultiLocation` type identifies any single _location_ that exists within the world of consensus. It is quite an abstract idea and can represent all manner of things that exist within consensus, from a scalable multi-shard blockchain such as Polkadot all the way down to a lowly ERC-20 asset account on a parachain. In computer science terms, it‚Äôs really just a global singleton data structure, regardless of its size or complexity.

---

## MultiLocation Examples

- `../Parachain(1000)`: Evaluated within a parachain, this would identify our sibling parachain of index 1000. (In Rust we would write ParentThen(Parachain(1000)).into().)
- `../AccountId32(0x1234...cdef)`: Evaluated within a parachain, this would identify the 32-byte account 0x1234‚Ä¶cdef on the relay chain.
- `Parachain(42)/AccountKey20(0x1234...abcd)`: Evaluated on a relay chain, this would identify the 20-byte account 0x1234‚Ä¶abcd on parachain number 42 (presumably something like Moonbeam which hosts Ethereum-compatible accounts).

---

## Cross-Consensus Accounts and Origins

- How can a sovereign account be verified exactly?
<!-- TODO define & add to glossary -->
- NOTE paraID CAN change over time!
  - Don't hard code these into a dapp!!

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### üí∞ Assets in XCM

XCM is designed to be able to handle all such assets without breaking a sweat. For this purpose there is the datatype MultiAsset together with its associated types MultiAssets, WildMultiAsset and MultiAssetFilter. Let‚Äôs look at MultiAsset in Rust:

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust
struct MultiAsset {
   id: AssetId,
   fun: Fungibility,
}
```

</div>
</div>

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### XCVM registers

The XCVM includes a number of registers, as well as access to the overall state of the consensus system which is hosting it. XCM Instructions might change a register, they might change the state of the consensus system or both.

One example of such an instruction would be TransferAsset which is used to transfer an asset to some other address on the remote system. It needs to be told which asset(s) to transfer and to whom/where the asset is to be transferred. In Rust, it is declared like this:

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust
enum Instruction {
    TransferAsset {
        assets: MultiAssets,
        beneficiary: MultiLocation,
    }
    /* snip */
}
```

</div>
</div>

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### üíÅ The Holding Register

`WithdrawAsset` has no location specified for assets.

They are _temporarily_ held in what in the Holding Register.

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust
WithdrawAsset(MultiAssets),

// There are a number of instructions which operate on the Holding Register.
// One very simple one is the `DepositAsset` instruction.

enum Instruction {
    DepositAsset {
        assets: MultiAssetFilter,
        max_assets: u32,
        beneficiary: MultiLocation,
    },
    /* snip */
}
```

</div>
</div>

Notes:
Let‚Äôs take a look at another XCM instruction: `WithdrawAsset`. On the face of it, this is a bit like the first half of `TransferAsset`: it withdraws some assets from the account of the place specified in the Origin Register.
But what does it do with them? ‚Äî if they don‚Äôt get deposited anywhere then it‚Äôs surely a pretty useless operation.

---

## ü§ë Fee payment in XCM

Most systems require these to mitigate ‚Äútransaction spam‚Äù and a denial-of-service (DOS) attacks.

XCM does _not_ include the idea of fees and fee-payment as a first-class citizen

Notes:
Exceptions to this exist when chains have good reason to believe that their interlocutor will be well-behaved‚Äîthis is the case when the Polkadot Relay Chain corresponds with the Polkadot Statemint common-good chain.
However for the general case, fees are a good way of ensuring that XCM messages and their transport protocols cannot be over-used.
Like Rust with its zero-cost abstractions, fee payment comes with no great design overhead in XCM.

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### XCM with Fees Example

For systems that do require some fee payment though, XCM provides the ability to buy execution resources with assets. Doing so, broadly speaking, consists of three parts:

1. Assets provided
2. Negotiate exhange of assets for compute time (weight)
3. XCM operations will be performed as instructed

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust
// Part 1
WithdrawAsset((Here, 10_000_000_000).into()),

// Part 2
enum Instruction {
    /* snip */
    BuyExecution {
        fees: MultiAsset,
        weight: u64,
    },
}

//Part 3
WithdrawAsset((Here, 10_000_000_000).into()),
BuyExecution {
    fees: (Here, 10_000_000_000).into(),
    weight: 3_000_000,
},

// Part 4
WithdrawAsset((Here, 10_000_000_000).into()),
BuyExecution {
    fees: (Here, 10_000_000_000).into(),
    weight: 3_000_000,
},
DepositAsset {
    assets: All.into(),
    max_assets: 1,
    beneficiary: Parachain(1000).into(),
},
```

</div>
</div>

Notes:
The first part is managed by one of a number of XCM instructions which provide assets. We already know one of these (WithdrawAsset), but there are several others which we will see later. The resultant assets in the Holding Register will of course be used for paying fees associated with executing the XCM. Any assets not used to pay fees we will be depositing in some destination account. For our example, we‚Äôll assume that the XCM is happening on the Polkadot Relay Chain and that it‚Äôs for 1 DOT (which is 10,000,000,000 indivisible units).
This brings us to the second part, exchanging (some of) these assets for compute time to pay for our XCM. For this we have the XCM instruction BuyExecution. Let‚Äôs take a look at it:
The first item fees is the amount which should be taken from the Holding Register and used for fee-payment. It‚Äôs technically just the maximum since any unused balance is immediately returned.
The amount that ends up being spent is determined by the interpreting system ‚Äî fees only limits it and if the interpreting system needs to be paid more for the execution desired, then the BuyExecution instruction will result in error. The second item specifies an amount of execution time to be purchased. This should generally be no less than the weight of the XCM programme in total.
In our example we‚Äôll assume that all XCM instructions take a million weight, so that‚Äôs two million for our two items so far (WithdrawAsset and BuyExecution) and a further one for what‚Äôs coming next. We‚Äôll just use all the DOT that we have to pay those fees (which is only a good idea if we trust the destination chain not to have crazy fees ‚Äî we‚Äôll assume that we do).
The third part of our XCM comes in depositing the funds remaining in the Holding Register. For this we will just use the DepositAsset instruction. We don‚Äôt actually know how much is remaining in the Holding Register, but that doesn‚Äôt matter since we can specify a wildcard for the asset(s) which should be deposited. We‚Äôll place them in the sovereign account of Statemint (which is identified as Parachain(1000).

---

## ‚õì Moving Assets between Chains in XCM

Sending an asset to another chain is probably the most common use-case for inter-chain messaging. Allowing one chain to administer another chain‚Äôs native asset allows for all sorts of derivative use-cases (no pun intended), the simplest being a decentralised exchange but generally grouped together as decentralised finance or DeFi.

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### ‚ú® Teleporting

For chains that trust each other (such a homogeneous shards under the same overall consensus and security umbrella), we can use a framework that Polkadot calls teleporting, which basically just means destroying an asset on the sending side and minting it on the receiving side. This is simple and efficient ‚Äî it only requires the coordination of the two chains and only involves one action on either side. Unfortunately, if the receiving chain cannot 100% trust the sending chain to actually destroy the asset which it is minting (and indeed not to mint assets outside of the agreed rules for the asset), then the sending chain really has no basis for minting the asset on the back of a message.

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust
// XCM teleported (most of) 1 DOT from the Polkadot Relay Chain to its sovereign account on Statemint.
// We‚Äôll assume that the fees are already paid on the Polkadot side.

WithdrawAsset((Here, 10_000_000_000).into()),
InitiateTeleport {
    assets: All.into(),
    dest: Parachain(1000).into(),
    xcm: Xcm(vec![
        BuyExecution {
            fees: (Parent, 10_000_000_000).into(),
            weight: 3_000_000,
        },
        DepositAsset {
            assets: All.into(),
            max_assets: 1,
            beneficiary: Parent.into(),
        },
    ]),
}

// When Statemint eventually gets the message, it looks like this:

ReceiveTeleportedAsset((Parent, 10_000_000_000).into()),
BuyExecution {
    fees: (Parent, 10_000_000_000).into(),
    weight: 3_000_000,
},
DepositAsset {
    assets: All.into(),
    max_assets: 1,
    beneficiary: Parent.into(),
},

```

</div>
</div>

Notes:
TODO

---

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### üè¶ Reserves

- TODO

</div>

Notes:
The name comes from reserve banking, where assets are held ‚Äúin reserve‚Äù to give credibility to the idea that some issued promise is valuable.
For example, if we can reasonably believe exactly 1 ‚Äúreal‚Äù (e.g. Statemint or Relay Chain) DOT is redeemable for each ‚Äúderivative‚Äù DOT issued on an independent parachain, then we can treat the parachain‚Äôs DOT as being economically equivalent to real DOT.
(Most banks do something called fractional reserve banking, which means they keep less than the face-value in reserve.
This works fine until too many people wish to redeem, and then everything can go quite wrong quite fast.) So, the reserve is the place which stores the ‚Äúreal‚Äù assets and, for the purposes of transferral, whose logic and security is trusted by both sender and receiver.
Any corresponding assets on the sender and receiver side would then be derivatives, but they would be backed with the ‚Äúreal‚Äù reserve asset 100%.
Assuming that the parachain behaved well (i.e. that it was bug-free and its governance didn‚Äôt decide to run off with the reserve), this would make the derivative DOT more or less of the same value as the underlying reserve DOT.
The reserve assets are held in the sender/receiver‚Äôs sovereign account (i.e. the account controllable by the sender or receiver chain) on the reserve chain, so there‚Äôs good reason that unless something went wrong with the parachain, they‚Äôd be well guarded.

---

#### _Reserve Asset Example_

```rust [0|4-8|8-17|17-29]
// Sending 1 DOT from parachain 2000 to parachain 2001, which use reserve-backed DOT on parachain 1000
// We‚Äôll assume the fees are already paid on the sender side.

WithdrawAsset((Parent, 10_000_000_000).into()),
InitiateReserveWithdraw {
    assets: All.into(),
    dest: ParentThen(Parachain(1000)).into(),
    xcm: Xcm(vec![
        BuyExecution {
            fees: (Parent, 10_000_000_000).into(),
            weight: 3_000_000,
        },
        DepositReserveAsset {
            assets: All.into(),
            max_assets: 1,
            dest: ParentThen(Parachain(2001)).into(),
            xcm: Xcm(vec![
                BuyExecution {
                    fees: (Parent, 10_000_000_000).into(),
                    weight: 3_000_000,
                },
                DepositAsset {
                    assets: All.into(),
                    max_assets: 1,
                    beneficiary: ParentThen(Parachain(2000)).into(),
                },
            ]),
        },
    ]),
},

```

</div>
</div>

Notes:
TODO

---

# Additional slides

Not yet complete!

---

## The XCM format

- TODO: Cover all of https://github.com/paritytech/xcm-format
<!-- Walkthough of document.... maybe too verbose? Needs to be parsed into slides. Likely V3 as we will deliver in July 2022. -->

---

## Instancing

- TODO: Add some content

---

## Aggregation

- Define
- TODO: Add some content

---

## Weight (in XCM)

- TODO: Add some content

---

## Exotic Stuff:

- Genesis, Logs, Signed Extensions
- TODO: Add some content

---

# An important point

### _Make it clear_

<!-- .element: class="fragment" data-fragment-index="1" -->

Notes:
Stuff you should remember to say

---

# Exercise title

### _Describe it here_

<!-- TODO: exercise indicator https://github.com/paritytech/polkadot-blockchain-academy/issues/67 -->

---

## Exercise instructions

<!--
Detail what you want students to do in your exercise
Most exercises are less than 15 minuets in length.
-->

1.
1.
1.

Notes:
Make sure to include things here to say to students, perhaps a hint or two.
Realize that students will be able to view the speaker's notes, as they will have access to them on their devices.

<!-- TODO: exercise indicator https://github.com/paritytech/polkadot-blockchain-academy/issues/67 -->

---

## Conclusion

<!-- Summarize what we just learned, and put it in the bigger picture of what the Academy and Web3 are all about. -->

---

## Next steps

<!--
Compile a list of:
- topics not covered here but students should consider learning about independently
- examples of the concepts covered in this lesson applied to a project, to case-study
- useful resources related to the lesson

- Reference other slides/materials by relative directory in this repo, like the [copy-paste slide templates](../../content-templates/slides/copy-paste-reveal-template-slides.md)
-->

1. <!-- TODO: fill this in  -->
1. <!-- TODO: fill this in  -->
1. <!-- TODO: fill this in  -->

---

## References

<!--
Compile an **annotated** list of URLs to source material referenced in making these lessons.
Ideally this is exhaustive, it can be cleaned up before delivery to students, but must include _why_ a reference is used.
For example:

- [ss58-registry](https://github.com/paritytech/ss58-registry) - A list of known SS58 account types as an enum, typically used by the Polkadot, Kusama or Substrate ecosystems.
- [wiki on parathreads](https://wiki.polkadot.network/docs/learn-parathreads) - A description of the parathread model.
-->

---

## Glossary

<!-- TODO: ensure these are in the class glossary! Remove this slide and simply reference in the slides -->

- UMP (Upward Message Passing) allows parachains to send messages to their relay chain.
- DMP (Downward Message Passing) allows the relay chain to pass messages down to one of their parachains.
- HRMP (Horizontal Message Passing)
- XCMP (Cross-Consensus Message Passing), which is perhaps the best known of them, allows the parachains to send messages between themselves.
