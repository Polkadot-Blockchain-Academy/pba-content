---
title: Core Concepts, Terms, and Logic of XCM # Also update the h1 header on the first slide to the same name
description: Describe your slides here
duration: 1 hour
instructors: ["Gavin Wood", "Keith Yeung"]
teaching-assistants: ["Dan Shields"]
---

<!--
# Dan & Keith - Notes & TODO

## https://medium.com/polkadot-network/xcm-the-cross-consensus-message-format-3b77b1373392
- use Gav's blog -> slides for most content in this mod, and likely mod 2.

- [Moonbuilders Workshop: A Technical Introduction to XCM on Moonbeam](https://www.youtube.com/watch?v=5HD5rFBqvQ4)
    - [their docs on xcm](https://docs.moonbeam.network/builders/xcm/overview/)
    - Great overall intro, [slides are great](https://docs.google.com/presentation/d/1dKZiP1LUltfjJ4cHiB1XtJAGla3sngXSc7sFj84zRKk/)... might want to ask to use? Copy content perhaps
    - 39:20 demo code w/ xTokens (XC-20)
        - It's possible to have different versions for specific fields/xcm programs{?} (destination, beneficiary) in a single XCM? Why?
- Use examples from Shawn's workshop https://github.com/shawntabrizi/xcm-workshop
- MORE CONTENT: XCM testing and troubleshooting with Nacho & DS team

### [moonbeam slides](https://docs.google.com/presentation/d/1dKZiP1LUltfjJ4cHiB1XtJAGla3sngXSc7sFj84zRKk/edit#slide=id.g112909de4e6_0_92)

- slide 10:
  - sov account vs. a reserve ~~account~~ chain: These are not the same.
    - Have a reserve chain that could have
- slide 12:
  - might have the over-constricted/missing nuance/detail model vs this answer: Stack Exchange example: https://substrate.stackexchange.com/questions/37/how-can-i-transfer-assets-using-xcm/38#38
-->

# Core Concepts, Terms, and Logic of XCM

### _Module 7, Lecture 1_

---

<div class="flex-container">
<div class="left text-right"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

<!-- TODO: add a good circularly cropped headshot of ou to the `assets/profile` folder  -->
<img style="width: 550px; float:right; margin-right:30px" src="../../../assets/img/Shared/profile.png"/>
</div>
<div style="margin-top:130px" class="right text-left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### Instructor Name

<!-- .element: style="margin-bottom: -30px;" -->

#### _Position or Title_

<!-- .element: style="margin-left: 20px;" -->

- I am a Subject matter in X
- A bit about me

_[Twitter](https://twitter.com) // [LinkedIn](https://linkedin.com) // [Email](mailto:)_

</div>
</div>

---

### Outline

<!--
You can reference slides within this presentation like [this other slide](#at-the-end-of-this-lecture-you-will-be-able-to) by use of the header title.

Please make your lecture precise.

- Limit the main points in a lecture to five or fewer.
- Create effective visuals, analogies, demonstrations, and examples to reinforce the main points.
  {TAs and the Parity design team can assist! Please let us know marking an item here as `TODO`}
- Emphasize your objectives and key points in the beginning, as you get to them, and as a summary at the end.

-->

1. [Pre-requisites](#pre-requisites)
1. [Major topic A](#major-topic-a)
1. Major topic B
1. [Exercise X](#exercise-title)
1. Major topic C
1. [Conclusion](#conclusion)
1. [Next Steps](#next-steps)
1. [References](#references)

---

## Pre-requisites

- FRAME (Storage Items, Dispatchables, Event, Errors, etc.)
- Polkadot & parachains conceptually
- Assets (NFTs and fungibles)

---

### _At the end of this lecture, you will be able to:_

<!-- TODO: fill this in  -->

- Define the concepts, syntax, and terms of XCM
- Navigate exiting resources that relate to XCM
- Differentiate between XCM and XCMP-like protocols

---

## What cross-chain use cases exist?

Performing operations on different blokchains?

How might you go about designing a _system_ to facilitate them?

Notes:
EXERSIZE: ask the class to raise hands and postulate on generally what one might do .

---

## üé¨ Some Concrete Use-cases

1. Cross-consensus asset transfers
2. Execute platform-specific actions (extrinsics)
3. Payment of fees for exectution (if required, for the above)

Notes:
While the goal of XCM is to be general, flexible and future-proof, there are of course practical needs which it must address, not least the transfer of tokens between chains.
We need a way to reson about, and pay for, any required fees on the reciving CS.
Platform-specific action; for example, within a Substrate chain, it can be desirable to dispatch a remote call into one of its pallets to access a niche feature.

---

## Enter Cross _Consensus_ Messaging (XCM)

### XCM aims to be a _language communicating ideas between consensus systems._

---

## ü§ü A Format, not a Protocol

XCM is a **_messaging format_**.

It is _not_ a messaging protocol!

Notes:
It cannot be used to actually ‚Äúsend‚Äù any message between systems; its utility is only in expressing what should be done by the receiver.
like many aspects core to Substrate, this seporation of concerns / interace empowers us to be far more generic and enable much more.

---

## üò¨ Why not _native_ messages?

Piggybacking on the native message/transaction format drawbacks:

<br>

1. Lack of compatibility between consensus systems
2. Common XCMs cannot "fit" into a single transaction/extrinsic
3. Most assume fee-payment has already been negotiated

Notes:
1. A system which intends to send messages to more than one destination would need to understand how to author a message for each.
   On that note, even a single destination may alter its native transaction/message format over time.
   Smart contracts might get upgrades, blockchains might introduce new features or alter existing ones and in doing so change their transaction format.
2. Special tricks may be required to withdraw funds, exchange them and then deposit the result all inside a single transaction.
   Onward notifications of transfers, needed for a coherent reserve-asset framework, do not exist in chains unaware of others.
3. Transaction envelopes, in comparison, provide some system for payment of processing, but are also generally designed to contain a signature which is not something that makes sense when communicating between consensus systems.

---

## ü´Ä The XCVM

At the core of XCM lies the **Cross-Consensus Virtual Machine (XCVM)**.

A ‚Äúmessage‚Äù in XCM is an XCVM program.

Notes:
It‚Äôs an ultra-high level non-Turing-complete computer whose instructions are designed to be roughly at the same level as transactions.
Messages are one or more XCM instructions.
The programme executes until it either runs to the end or hits an error, at which point it finishes up (I‚Äôm leaving that intentionally unexplained for now) and halts.

---

## XCVM Instructions preview

<!-- TODO example of XCM message that intuitively makes sense for students that can reason about assets and fees, highlight lines in code block and talk to them. Highlight LOCATION and ASSET instructions, that we will go into next -->


---

## üìç Locations in XCM

`MultiLocation` = a unique **_relative_** entity in the consensus multiverse.

All entities are addressed in reference to _paths_ to them.

<!-- todo design consensus multiverse graphic, could use the ring w/ parachains and bridges (Dan) -->

Notes:
The `MultiLocation` type identifies any single _location_ that exists within the world of consensus.
Representing a scalable multi-shard blockchain such as Polkadot, a lowly ERC-20 asset account on a parachain, a smart contract on some chain, etc.

---

## MultiLocation Examples

<!-- TODO DESIGN: use multilocation graphic from above and add labes in fragment / new slide here -->

- `../Parachain(1000)`: Evaluated within a parachain, this would identify our sibling parachain of index 1000. (In Rust we would write ParentThen(Parachain(1000)).into().)
- `../AccountId32(0x1234...cdef)`: Evaluated within a parachain, this would identify the 32-byte account 0x1234‚Ä¶cdef on the relay chain.
- `Parachain(42)/AccountKey20(0x1234...abcd)`: Evaluated on a relay chain, this would identify the 20-byte account 0x1234‚Ä¶abcd on parachain number 42 (presumably something like Moonbeam which hosts Ethereum-compatible accounts).

<!-- TODO: add example of non-parachain multi-location that would use a bridge -->

Notes:
XCM reasons about addressing (as in a postal address) that must include understanding where you are, not just where you are going!
This will be very powerfull latter on (Origins)
<!-- TODO: does XCM explicitly need to know the Origin of the message? Could there be annonomus XCM? (no "return to sender" field on mail) -->


---

## Construct a `MultiLocation`!

1. What is _your_ location?

2. Where do you _want to send tp_?

3. Write your `MultiLocation`!

Notes:
EXERSIZE: Prompt students to decide whe a multilocation correctly.
Encourage non-trivial (but direct!) paths like a specific contract on a parachain from Bitcoin.
Call on students to state their path and where they want to go.

---

## `MultiLocation` Deep Dive

<!-- TODO: Things to add in detail, slides for each - from Shawn and Keith meeting -->

* Breakdown multilocation in terms of code representation
* Potentially show some encoding/decoding (SCALE) that is critical for debuggin/troubleshooting latter
* How it is configured on a specific chain, with the universal location
* Canonical representation of multilocation (i guess cannonical by default)
* Multilocation limits, and Junctions
* Implementation of Junctions as Tuple has a reason, we explicitly do not use a vec or array
    * for matching purposes and match arms/patterns
    * Double check reasoning here

Maybe some Day 2 Stuff
* Multilocation API, traversal and manipulation of multilocation
* Reanchoring when messages land on new consensus systems

Notes:
TODO

---

## Cross-Consensus Accounts and Origins

<!-- TODO SME to help define and fill this in -->

- How can a sovereign account be verified exactly?
<!-- TODO define & add to glossary -->
- NOTE paraID CAN change over time!
  - Don't hard code these into a dapp!!

---

## `MultiLocation` extablished!

Now we know how to describe the destination, what _do we want to send_?

Let's start with messages (XCVM Programs!) about **_assets_**e.

Notes:


---

## ü§π Many models for transferring assets

1. "Remote control" an account on another system
3. Reserve transfers
4. Teleport transfers

Notes:
We might want to simply control an account on a remote chain, allowing the local chain to have an address on the remote chain for receiving funds and to eventually transfer those funds it controls into other accounts on that remote chain.

---

<img style="height: 100vh;" src="../../../assets/img/7-XCM/rm-tx.png" alt="Remote Transfer"/>
<img style="height: 100vh;" src="../../../assets/img/7-XCM/teleport.png" alt="Teleport"/>
<img style="height: 100vh;" src="../../../assets/img/7-XCM/reserve-tx.png" alt="Reserve Transfer"/>

<!-- TODO DESIGN: get these in nice flexbox side-by-side -->

Notes:
TODO: use examples from here https://medium.com/polkadot-network/xcm-the-cross-consensus-message-format-3b77b1373392 to describe the images

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### üí∞ `MultiAsset` in XCM

There are many _classes_ of assets (fung., NFTs,...)

The datatype `MultiAsset` describes them all.

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust
struct MultiAsset {
   id: AssetId,
   fun: Fungibility,
}
```

</div>
</div>

---

TODO: Break down `AssetId` and `Fungibility` objects

---

### `MultiAsset` Associated types

- `MultiAssets` -  a set of `MultiAsset`
- `WildMultiAsset` - match  (`All` ; `Allof`) against one or more `MultiAsset`
- `MultiAssetFilter` -  wildcard _or_ list of definite assets to be specified


Notes:
`MultiAssets` is one of them and really just means a set of `MultiAsset` items.
Then we have `WildMultiAsset`; this is a wildcard which can be used to match against one or more `MultiAsset` items.
There are actually only two kinds of wildcard that it supports: 
- `All` (which matches against all assets) and `AllOf` which matches against all assets of a particular identity (`AssetId`) and fungibility.
  Notably, for the latter, the amount (in the case of fungibles) or instance(s) (for non-fungibles) does not need to be specified and all are matched.
Finally, there is `MultiAssetFilter`.
This is used most often and is really just a combination of `MultiAssets` and `WildMultiAsset` allowing either a wildcard or a list of definite (i.e. not wildcard) assets to be specified.

---

## XCVM Registers

<!-- TODO: split into slides -->

```rust
pub struct XcmExecutor<Config: config::Config> {
	holding: Assets,
	holding_limit: usize,
	context: XcmContext,
	original_origin: MultiLocation,
	trader: Config::Trader,
	error: Option<(u32, XcmError)>,
	total_surplus: u64,
	total_refunded: u64,
	error_handler: Xcm<Config::Call>,
	error_handler_weight: u64,
	appendix: Xcm<Config::Call>,
	appendix_weight: u64,
	transact_status: MaybeErrorCode,
	fees_mode: FeesMode,
	topic: Option<[u8; 32]>,
	_config: PhantomData<Config>,
}
```

- Registers _are_ the state of XCVM
- Note that XCVM registrar is temporary/transient

---
    
### XCVM Instructions

XCM Instructions might change a register, they might change the state of the consensus system or both.

One example of such an instruction would be `TransferAsset` which is used to transfer an asset to some other address on the remote system.
It needs to be told which asset(s) to transfer and to whom/where the asset is to be transferred.

```rust
enum Instruction {
    TransferAsset {
        assets: MultiAssets,
        beneficiary: MultiLocation,
    }
    /* snip */
}
```

---

## XCM Instruction Set

<!-- TODO: Instructions Deep Dive, split into slides -->

* What are all the different available instructions
* How / When are they used
* Instructions patterns
    * We always start with taking a fee, and converting it to weight
    * We always end with a weight refund
    * Registering available assets
* Handling errors (similar to handling Results)
    * End early, or continue to execute further instructions
    * Error handler
* Logic trees (if/else) (double check this)
    * Expect asset

---

## Deep dive into a specific instruction

* Note that instructions are composed of some static logic, and some logical hooks which can be configured by the user

* show a few examples of these hooks

---

## XCM Configurations

Now go through and explain the various XCM configurations and hooks that can be manipulated by the user, and how that may affect XCM behavior

This then leads naturally into a concept like fee payments, which is entirely a configuration, for things like:

* What assets are supported for fees (configurable)
* How much each asset is worth in terms of weight (configurable)
* What happens to unused weight (configurable)
* Other mechanisms for being given weight (for example a stipend for certain chains, or entirely free)
* Barrier conditions

---

A few slides from these key configurables:

## Key Configurables

* Barriers
* WeightTrader
* XCM Sender
* Origin Converer
* Asset Transactor

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### üíÅ The Holding Register

`WithdrawAsset` has no location specified for assets.

They are _temporarily_ held in what in the Holding Register.

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust
WithdrawAsset(MultiAssets),

// There are a number of instructions which operate on the Holding Register.
// One very simple one is the `DepositAsset` instruction.

enum Instruction {
    DepositAsset {
        assets: MultiAssetFilter,
        max_assets: u32,
        beneficiary: MultiLocation,
    },
    /* snip */
}
```

</div>
</div>

Notes:
Let‚Äôs take a look at another XCM instruction: `WithdrawAsset`. On the face of it, this is a bit like the first half of `TransferAsset`: it withdraws some assets from the account of the place specified in the Origin Register.
But what does it do with them? ‚Äî if they don‚Äôt get deposited anywhere then it‚Äôs surely a pretty useless operation.

---

## XCM Configuration

---

## ü§ë Fee payment in XCM

Most systems require these to mitigate ‚Äútransaction spam‚Äù and a denial-of-service (DOS) attacks.

XCM does _not_ include the idea of fees and fee-payment as a first-class citizen

Notes:
Exceptions to this exist when chains have good reason to believe that their interlocutor will be well-behaved‚Äîthis is the case when the Polkadot Relay Chain corresponds with the Polkadot Statemint common-good chain.
However for the general case, fees are a good way of ensuring that XCM messages and their transport protocols cannot be over-used.
Like Rust with its zero-cost abstractions, fee payment comes with no great design overhead in XCM.

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### XCM with Fees Example

For systems that do require some fee payment though, XCM provides the ability to buy execution resources with assets. Doing so, broadly speaking, consists of three parts:

1. Assets provided
2. Negotiate exhange of assets for compute time (weight)
3. XCM operations will be performed as instructed

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust [1|]
WithdrawAsset((Here, 10_000_000_000).into()),
BuyExecution {
    fees: (Here, 10_000_000_000).into(), // MultiAsset
    weight: 3_000_000, // u64
},
DepositAsset {
    assets: All.into(), // MultiAssets
    max_assets: 1,
    beneficiary: Parachain(1000).into(), // MultiLocation
},
```

</div>
</div>

Notes:
The first part is managed by one of a number of XCM instructions which provide assets.
We already know one of these (WithdrawAsset), but there are several others which we will see later.
The resultant assets in the Holding Register will of course be used for paying fees associated with executing the XCM.
Any assets not used to pay fees we will be depositing in some destination account.
For our example, we‚Äôll assume that the XCM is happening on the Polkadot Relay Chain and that it‚Äôs for 1 DOT (which is 10,000,000,000 indivisible units).
This brings us to the second part, exchanging (some of) these assets for compute time to pay for our XCM.
For this we have the XCM instruction BuyExecution.
Let‚Äôs take a look at it:
The first item fees is the amount which should be taken from the Holding Register and used for fee-payment.
It‚Äôs technically just the maximum since any unused balance is immediately returned.
The amount that ends up being spent is determined by the interpreting system ‚Äî fees only limits it and if the interpreting system needs to be paid more for the execution desired, then the BuyExecution instruction will result in error.
The second item specifies an amount of execution time to be purchased.
This should generally be no less than the weight of the XCM programme in total.
In our example we‚Äôll assume that all XCM instructions take a million weight, so that‚Äôs two million for our two items so far (WithdrawAsset and BuyExecution) and a further one for what‚Äôs coming next.
We‚Äôll just use all the DOT that we have to pay those fees (which is only a good idea if we trust the destination chain not to have crazy fees ‚Äî we‚Äôll assume that we do).
The third part of our XCM comes in depositing the funds remaining in the Holding Register.
For this we will just use the DepositAsset instruction.
We don‚Äôt actually know how much is remaining in the Holding Register, but that doesn‚Äôt matter since we can specify a wildcard for the asset(s) which should be deposited.
We‚Äôll place them in the sovereign account of Statemint (which is identified as Parachain(1000).

---

## ‚õì Moving Assets between Chains in XCM

Sending an asset to another chain is probably the most common use-case for inter-chain messaging.
Allowing one chain to administer another chain‚Äôs native asset allows for all sorts of derivative use-cases (no pun intended), the simplest being a decentralised exchange but generally grouped together as decentralised finance or DeFi.

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### ‚ú® Teleporting

For chains that trust each other (such a homogeneous shards under the same overall consensus and security umbrella), we can use a framework that Polkadot calls teleporting, which basically just means destroying an asset on the sending side and minting it on the receiving side.
This is simple and efficient ‚Äî it only requires the coordination of the two chains and only involves one action on either side.
Unfortunately, if the receiving chain cannot 100% trust the sending chain to actually destroy the asset which it is minting (and indeed not to mint assets outside of the agreed rules for the asset), then the sending chain really has no basis for minting the asset on the back of a message.

</div>

<!-- Put no content here -->

<div class="right">
<!-- Gotcha: You Need an empty line to render MD inside <div> -->

```rust
// XCM teleported (most of) 1 DOT from the Polkadot Relay Chain to its sovereign account on Statemint.
// We‚Äôll assume that the fees are already paid on the Polkadot side.

WithdrawAsset((Here, 10_000_000_000).into()),
InitiateTeleport {
    assets: All.into(),
    dest: Parachain(1000).into(),
    xcm: Xcm(vec![
        BuyExecution {
            fees: (Parent, 10_000_000_000).into(),
            weight: 3_000_000,
        },
        DepositAsset {
            assets: All.into(),
            max_assets: 1,
            beneficiary: Parent.into(),
        },
    ]),
}

// When Statemint eventually gets the message, it looks like this:

ReceiveTeleportedAsset((Parent, 10_000_000_000).into()),
BuyExecution {
    fees: (Parent, 10_000_000_000).into(),
    weight: 3_000_000,
},
DepositAsset {
    assets: All.into(),
    max_assets: 1,
    beneficiary: Parent.into(),
},

```

</div>
</div>

Notes:
TODO

---

---

<div class="flex-container">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### üè¶ Reserves

- TODO

</div>

Notes:
The name comes from reserve banking, where assets are held ‚Äúin reserve‚Äù to give credibility to the idea that some issued promise is valuable.
For example, if we can reasonably believe exactly 1 ‚Äúreal‚Äù (e.g. Statemint or Relay Chain) DOT is redeemable for each ‚Äúderivative‚Äù DOT issued on an independent parachain, then we can treat the parachain‚Äôs DOT as being economically equivalent to real DOT.
(Most banks do something called fractional reserve banking, which means they keep less than the face-value in reserve.
This works fine until too many people wish to redeem, and then everything can go quite wrong quite fast.) So, the reserve is the place which stores the ‚Äúreal‚Äù assets and, for the purposes of transferral, whose logic and security is trusted by both sender and receiver.
Any corresponding assets on the sender and receiver side would then be derivatives, but they would be backed with the ‚Äúreal‚Äù reserve asset 100%.
Assuming that the parachain behaved well (i.e. that it was bug-free and its governance didn‚Äôt decide to run off with the reserve), this would make the derivative DOT more or less of the same value as the underlying reserve DOT.
The reserve assets are held in the sender/receiver‚Äôs sovereign account (i.e. the account controllable by the sender or receiver chain) on the reserve chain, so there‚Äôs good reason that unless something went wrong with the parachain, they‚Äôd be well guarded.

---

#### _Reserve Asset Example_

```rust [0|4-8|8-17|17-29]
// Sending 1 DOT from parachain 2000 to parachain 2001, which use reserve-backed DOT on parachain 1000
// We‚Äôll assume the fees are already paid on the sender side.

WithdrawAsset((Parent, 10_000_000_000).into()),
InitiateReserveWithdraw {
    assets: All.into(),
    dest: ParentThen(Parachain(1000)).into(),
    xcm: Xcm(vec![
        BuyExecution {
            fees: (Parent, 10_000_000_000).into(),
            weight: 3_000_000,
        },
        DepositReserveAsset {
            assets: All.into(),
            max_assets: 1,
            dest: ParentThen(Parachain(2001)).into(),
            xcm: Xcm(vec![
                BuyExecution {
                    fees: (Parent, 10_000_000_000).into(),
                    weight: 3_000_000,
                },
                DepositAsset {
                    assets: All.into(),
                    max_assets: 1,
                    beneficiary: ParentThen(Parachain(2000)).into(),
                },
            ]),
        },
    ]),
},

```

</div>
</div>

Notes:
TODO

---

### `MultiAsset` deep dive (limitations & gotchas)

<!-- TODO: Things to add as slides, no that we have context on all the concepts needed : -->

* Limits to how many multiassets can exist in the holding registrar
* Only supports NFTs and Fungibles, and only supports "identifying" these assets, versus representing any kind of underlying behavior
    * for example, when transferring an NFT, you only know its unique GUID, if you do a bunch of other logic around NFTs, obviously that information is not transferred
    * The behavior of NFT is chain local, you can't really transfer that...
* Complexity of managing multiple assets
    * Represented as a vector over the message
        * There is a strict limit to number of items in the vector
        * We also expect users to provide a certain level of ordering to the assets (nfts then fungibles)
    * Represented as a hash-map in the registrar
        * There is complexity overhead to map items from the vector into the hashmap, and to access values
* Unsupported assets and behavior
* Asset ID is either a multilocation (Concrete assets) or a byte vector (Abstract assets)
* Describe the MultiAsset APIs, manipulations, common behaviors, etc...

---

## The XCM format

- TODO: Cover all of https://github.com/paritytech/xcm-format
<!-- Walkthough of document....
maybe too verbose? Needs to be parsed into slides.
Likely V3 as we will deliver in July 2022.
-->

---

## The XCM format

---

## Instancing

- TODO: Add some content

---

## Aggregation

- Define
- TODO: Add some content

---

## Weight (in XCM)

- TODO: Add some content

---

## Exotic Stuff:

- Genesis, Logs, Signed Extensions
- TODO: Add some content

---

# An important point

### _Make it clear_

<!-- .element: class="fragment" data-fragment-index="1" -->

Notes:
Stuff you should remember to say

---

# Exercise title

### _Describe it here_

<!-- TODO: exercise indicator https://github.com/paritytech/polkadot-blockchain-academy/issues/67 -->

---

## Exercise instructions

<!--
Detail what you want students to do in your exercise
Most exercises are less than 15 minuets in length.
-->

1.
1.
1.

Notes:
Make sure to include things here to say to students, perhaps a hint or two.
Realize that students will be able to view the speaker's notes, as they will have access to them on their devices.

<!-- TODO: exercise indicator https://github.com/paritytech/polkadot-blockchain-academy/issues/67 -->

---

## Conclusion

<!-- Summarize what we just learned, and put it in the bigger picture of what the Academy and Web3 are all about.
-->

---

## Next steps

<!--
Compile a list of:
- topics not covered here but students should consider learning about independently
- examples of the concepts covered in this lesson applied to a project, to case-study
- useful resources related to the lesson

- Reference other slides/materials by relative directory in this repo, like the [copy-paste slide templates](../../content-templates/slides/copy-paste-reveal-template-slides.md)
-->

1. <!-- TODO: fill this in  -->
1. <!-- TODO: fill this in  -->
1. <!-- TODO: fill this in  -->

---

## References

<!--
Compile an **annotated** list of URLs to source material referenced in making these lessons.
Ideally this is exhaustive, it can be cleaned up before delivery to students, but must include _why_ a reference is used.
For example:

- [ss58-registry](https://github.com/paritytech/ss58-registry) - A list of known SS58 account types as an enum, typically used by the Polkadot, Kusama or Substrate ecosystems.
- [wiki on parathreads](https://wiki.polkadot.network/docs/learn-parathreads) - A description of the parathread model.
-->

---

## Glossary

<!-- TODO: ensure these are in the class glossary! Remove this slide and simply reference in the slides -->

- UMP (Upward Message Passing) allows parachains to send messages to their relay chain.
- DMP (Downward Message Passing) allows the relay chain to pass messages down to one of their parachains.
- HRMP (Horizontal Message Passing)
- XCMP (Cross-Consensus Message Passing), which is perhaps the best known of them, allows the parachains to send messages between themselves.
- {XCM} Junctions
- Multilocations
- Sovereign account(s)
- Holding registrar
- Consensus system
- {XCM} Instructions
- {XCM config} Barriers
- {XCM config} Filters
- UDP {networking}
- TTL {networking}