# Module 3, Lesson 1: Overview of Blockchains

---

### Speaker

Joe Petrowski

---

### Upholding Expectations

What is the core problem we want to solve?

<!--potential for some discussion here-->

---

### Comparison with Cryptography

Cryptography provides strong guarantees about _messages_ without a trusted party, regardless of the conduit over which a message was transported.

---

### Web 1

Users can transmit information peer-to-peer.

Cryptography upholds its guarantees when used like this.

---

### Web 2

"Send _us_ your information."

Platforms started offering digital services.

However, users must place faith in the service provider. Any cryptographic guarantees are about interactions with the service provider, not peers.

---

### Web3

A provision of digital services without the need to trust a service _provider_.

---

### Desired Properties

We want a system that:

- Allows access and interaction from anyone, without gatekeeping.
- Provides users credible expectations of privacy and authenticity.
- Provides users credible expectations that a state transition will never be reverted.
- Behaves as expected, even if the operators of the system do not.
- Cannot be stopped by any single party or organized coallition.

<!--Maybe Iggy or someone can make some nice graphics. We could break this up into multiple slides
	or just make them icons.-->

---

### Motivation

People rely on digital services every day. They are inescapable.

- Twitter, Instagram, Facebook, etc.
- Journalism and sources
- Banks
- Lawyers, notaries, regulators

<!--ask class for more-->

---

### Trust

What is trust in this context? Blind faith.

---

### Trust Examples

<!--Here's one example, but class should discuss. Also possible activity.-->

Two users on Twitter:

- Trust that we are seeing information from the same database\*
- Trust that if a tweet is from X, then X wrote that tweet\*
- Trust that others see our messages as from us\*
- Trust that the messages we see are the messages the users wrote\*
- Trust that we're interacting with the application as equals

<!--
	Cryptography actually provides a lot of these guarantees, but not when an intermediary has
	stepped in between users!
-->

---

###  Disintermediation

Removing trust allows us to unpackage applications.

When users have credible guarantees that they are interacting with the same data and logic, many applications can be built on the same system.

---

### Application Disentanglement

<!--
	The goal of this slide may not be entirely clear from my little ASCII diagram. But the idea is
	to discuss how many applications are seen as an entire bundle: e.g. Instagram is the database,
	the algorithms, the UX. But when we have credible expectations that we're interacting with the
	same system, rules, data, it's possible to build lots of ways to access and interact with the
	system. It also removes the need for a central authority to deal with all appeals/complaints
	from various users.
-->

\----------------------------------

UI: Devices, languages, UX preferences, tinkerers

\----------------------------------

Curation: Feed algorithms, content moderation

\----------------------------------

State: Data, Access rules

\----------------------------------

---

### Desired Approach

Allow users to interact with a common system without trusting any intermediaries.

Opens the door to new application stacks:

- Shared state and state change rules
- Custom rendering, moderation, interfaces

---

### State Machine

Now we have tiptoed around it too long. We want a state machine.

<!-- Probably a diagram here showing that SMs have a global state and a STF -->

---

## Blockchain, Finally

---

### Blockchains

<!-- Probably a diagram to put here -->

Generally concerned with two dimensions:

- Consensus -> How does the state advance? What changes are final?
- State Transition Function -> What does the state hold? What are the _rules_ to change it?

---

### State Transition Function

A STF defines:

| Data Stored   | API & Behavior |
|---------------|----------------|
| Account Info  | Function calls |
| Balances      | Implementation |
| Authority Set | Responses      |
| Timestamp     |                |
| &c.           |                |

---

### Example

**Simple storage item write:**

```rust
/// The ideal number of staking participants.
#[pallet::storage]
#[pallet::getter(fn validator_count)]
pub type ValidatorCount<T> = StorageValue<_, u32, ValueQuery>;

/// Sets the ideal number of validators.
#[pallet::call]
impl<T: Config> Pallet<T> {
	pub fn set_validator_count(origin: OriginFor<T>, new: u32) -> DispatchResult {
		ensure_root(origin)?;
		ValidatorCount::<T>::put(new);
		Ok(())
	}
}
```

---

### Anatomy

- State
- Blocks

<!-- diagram, obviously -->

---

### Blocks

- Includes a header and a body
- Header includes consensus-related info: number, parent hash, some digests
- Body contains an ordered set of _extrinsics_: Packets from the outside world with _zero_ or more signatures attached.

```rust
/// Abstraction over a Substrate block.
pub struct Block<Header, Extrinsic: MaybeSerialize> {
	/// The block header.
	pub header: Header,
	/// The accompanying extrinsics.
	pub extrinsics: Vec<Extrinsic>,
}
```

---

### Headers

Consensus-related info. Varies per blockchain, but in Substrate:

- Parent hash
- Number
- State root
- Extrinsics root
- Digest

The parent hash links blocks together (cryptographically linked list). The other info is handy for other infrastructure and applications (more on that later).

---

### Extrinsics

Packets from the outside world with _zero_ or more signatures attached.

- Function calls to the STF
- Some functions require signatures (e.g., transfer some tokens)
- Others don't, but usually have some validation means

---

### Consensus

Whole next lecture is dedicated to consensus, going to stay strictly conceptual here.

<!-- class discussion -->

---

### Liveness

- Property that ensures state transitions will happen. The system should be _available_.
- Someone needs to propose a state transition (within a block) and a resultant state.
- Motivation for actors to do so? <!--discussion-->

---

### Liveness Examples

- Static leader
- Round robin
- Proof of Work
- Random assignment protocols

---

### Safety

Once a state transition occurs, under what conditions can users have a credible expectation that it will never revert?

- Probabilistic
- Deterministic

---

### Safety Examples

- Longest chain
- Most difficulty
- PBFT (per state transition)
- PBFT (on batches)

---

### View

No node has an omniscient view of the network. Therefore, one node may always have more information than another node.

But they should never believe an incongruity.

Example: I believe that block `B` is final. You may not see `B` as final _yet_, but you should never believe that a chain that excludes `B` is final.

---

### Security

What actually backs up the system's guarantees?

- Lazy: Omnipotence (AWS, Twitter, Bank)
- Some "proof" of authority, as defined within the system itself
	- Wasting energy (trivial)
	- Putting stake at risk
	- Being elected by participants via their willingness to put their own stake at risk

---

### Unscrupuous Actors

**The _system_ should uphold its credibility even if individual participants do not.**

| Technical Design               | Economic Design    |
|--------------------------------|--------------------|
| Key choices                    | Cost of misuse     |
| Public API                     | Fees & Deposits    |
| Hash choices                   | Slashing & Rewards |
| Stored data                    |                    |
| Transactional/Autonomous Logic |                    |
| Authorship & Censorship        |                    |

---

### State Transition Function Upgrades

All systems need to upgrade to stay relevant.

Bug fixes, new functionality, new information.

This can be tricky in blockchains... <!--getting to this soon and in 3.4-->

---

## Polkadot

<!-- Wrap up with some notes about Polkadot -->

---

### Consensus Over the STF

Who actually defines the STF?

In Polkadot, it's part of the state itself!

`:CODE => <some-wasm-executable>`

---

### Many State Machines

- If one state machine with such guarantees is useful, people will probably want more.
- But security can be diluted.
- Polkadot is designed to _host_ a large number of sovereign state machines. We call them parachains.

---

### Substrate

Practically, these parachains will have a lot in common:

- Similar needs for accounting units, databases, RPCs, etc.
- All need to "speak the same language", i.e. compile to Wasm

Substrate was created to make this part easy.

---

### Next Up

Workshop and Deep Dive on Consensus

---
