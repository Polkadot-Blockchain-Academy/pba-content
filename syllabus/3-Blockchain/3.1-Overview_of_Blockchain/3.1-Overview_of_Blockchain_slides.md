# Module 3, Lesson 1: Overview of Blockchains

---

### Speaker

Joe Petrowski

---

### Upholding Expectations

What is the core problem we want to solve?

<!--potential for some discussion here-->

---

### Comparison with Cryptography

Cryptography provides strong guarantees about _information_ without a trusted party, regardless of the conduit over which the information was transported.

---

### Digital Service Provision

We want a system with similarly strong guarantees about _behavior_. A provision of digital services without the need to trust a service _provider_.

---

### Desired Properties

We want a system that:

- Allows access and interaction from anyone, without gatekeeping.
- Provides users credible expectations of privacy and authenticity.
- Provides users credible expectations that a state transition will never be reverted.
- Behaves as expected, even if the operators of the system do not.
- Cannot be stopped by any single party or organized coallition.

<!--Maybe Iggy or someone can make some nice graphics. We could break this up into multiple slides
	or just make them icons.-->

---

### Motivation

People rely on digital services every day. They are inescapable.

- Twitter, Instagram, Facebook, etc.
- Journalism and sources
- Banks
- Lawyers, notaries, regulators

<!--ask class for more-->

---

### Trust

What is trust in this context? Blind faith.

---

### Trust Examples

<!--Here's one example, but class should discuss. Also possible activity.-->

Two users on Twitter:

- Trust that we are seeing information from the same database\*
- Trust that if a tweet is from X, then X wrote that tweet\*
- Trust that others see our messages as from us\*
- Trust that the messages we see are the messages the users wrote\*
- Trust that we're interacting with the application as equals

<!--
	Cryptography actually provides a lot of these guarantees, but not when an intermediary has
	stepped in between users!
-->

---

###  Disintermediation

Removing trust allows us to unpackage applications.

When users have credible guarantees that they are interacting with the same data and logic, many applications can be built on the same system.

---

### Desired Approach

Allow users to interact with a common system without trusting any intermediaries.

Opens the door to new application stacks:

- Shared state and state change rules
- Custom rendering, moderation, interfaces

---

### State Machine

Now we have tiptoed around it too long. We want a state machine.

<!-- Probably a diagram here showing that SMs have a global state and a STF -->

---

### Blockchain, Finally

<!-- Picture of Fleetwood Mac - The Chain. We are in England, after all. -->

---

### Blockchains

<!-- Probably a diagram to put here -->

Generally concerned with two dimensions:

- Consensus -> How does the state advance? What changes are final?
- State Transition Function -> What does the state hold? What are the _rules_ to change it?

---

### State Transition Function

A STF defines:

| Data Stored   | API & Behavior |
|---------------|----------------|
| Account Info  | Function calls |
| Balances      | Implementation |
| Authority Set | Responses      |
| Timestamp     |                |
| &c.           |                |

---

### Example

**Simple storage item write:**

```rust
/// The ideal number of staking participants.
#[pallet::storage]
#[pallet::getter(fn validator_count)]
pub type ValidatorCount<T> = StorageValue<_, u32, ValueQuery>;

/// Sets the ideal number of validators.
#[pallet::call]
impl<T: Config> Pallet<T> {
	pub fn set_validator_count(origin: OriginFor<T>, new: u32) -> DispatchResult {
		ensure_root(origin)?;
		ValidatorCount::<T>::put(new);
		Ok(())
	}
}
```

---

### Anatomy

- State
- Blocks

<!-- diagram, obviously -->

---

### Blocks

- Includes a header and a body
- Header includes consensus-related info: number, parent hash, some digests
- Body contains an ordered set of _extrinsics_: Packets from the outside world with _zero_ or more signatures attached.

```rust
/// Abstraction over a Substrate block.
pub struct Block<Header, Extrinsic: MaybeSerialize> {
	/// The block header.
	pub header: Header,
	/// The accompanying extrinsics.
	pub extrinsics: Vec<Extrinsic>,
}
```

---

### Consensus

Whole next lecture is dedicated to consensus, going to stay strictly conceptual here.

<!-- class discussion -->

---

### Liveness

- Property that ensures state transitions will happen. The system should be _available_.
- Someone needs to propose a state transition (within a block) and a resultant state.
- Motivation for actors to do so? <!--discussion-->

---

### Safety

Once a state transition occurs, under what conditions can users have a credible expectation that it will never revert?

- Probabilistic
- Deterministic

---

### View

No node has an omniscient view of the network. Therefore, one node may always have more information than another node.

But they should never believe an incongruity.

Example: I believe that block `B` is final. You may not see `B` as final _yet_, but you should never believe that a chain that excludes `B` is final.

---

### Security

What actually backs up the system's guarantees?

- Lazy: Omnipotence (AWS, Twitter, Bank)
- Some "proof" of authority, as defined within the system itself
	- Wasting energy (trivial)
	- Putting stake at risk
	- Being elected by participants via their willingness to put their own stake at risk

---

### Unscrupuous Actors

**The _system_ should uphold its credibility even if individual participants do not.**

| Technical Design               | Economic Design    |
|--------------------------------|--------------------|
| Key choices                    | Cost of misuse     |
| Public API                     | Fees & Deposits    |
| Hash choices                   | Slashing & Rewards |
| Stored data                    |                    |
| Transactional/Autonomous Logic |                    |
| Authorship & Censorship        |                    |

---

### Polkadot

<!-- Wrap up with some notes about Polkadot -->

---

### Consensus Over the STF

Some shared state machine...
...but lots of parties proposing state transitions.

Who actually defines the STF? In Polkadot, it's part of the state itself!

`:CODE => <some-wasm-executable>`

---

### Many State Machines

- If one state machine with such guarantees is useful, people will probably want more.
- But security can be diluted.
- Polkadot is designed to _host_ a large number of sovereign state machines. We call them parachains.

---

### Substrate

Practically, these parachains will have a lot in common:

- Similar needs for accounting units, databases, RPCs, etc.
- All need to "speak the same language", i.e. compile to Wasm

Substrate was created to make this part easy.

---

### Next Up

Workshop and Deep Dive on Consensus

---
