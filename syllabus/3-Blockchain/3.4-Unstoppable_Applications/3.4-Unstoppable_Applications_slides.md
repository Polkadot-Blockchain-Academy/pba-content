# Unstoppable Applications

---

### Speaker

Joe Petrowski

---

### Motivation

So far, we have discussed state machines and consensus.

But spent little time addressing the contexts in which they operate.

---

### Web2 Tech Stack

Heavily based on trust.

<!--diagram-->
[s] --trust me!--> [c]

Any cryptographic guarantees are between central authority and users. There are no user-to-user guarantees.

---

### People over Platforms

Web3 should prioritise _people_ over _platforms_.

Platforms are OK as service providers, but peer-to-peer guarantees must be upheld without requiring trust in a service provider.

---

### Web3 Tech Stack

<!--diagram
Here we can put in the Web3 tech stack diagram.
-->

---

### A Lot More Than Blockchain

Blockchains only form one part of the stack. Web3 applications must prevent attacks at all layers. For discussion today:

- Networking
- Consensus
- Node access
- Validator power
- Inter-consensus system trust

---

### Criticisms

There are valid criticisms of how many blockchain applications operate today.

- Mining pools
- RPC providers
- Bridges

We will discuss these and what we're building to realize a better stack.

---

## Network Level

---

### Peer-to-Peer Networks

<!--Pierre's diagram
https://docs.google.com/presentation/d/163fRaA149hdbYOnani7rKzeiIiDOaa7M57E9SE-8rIs/edit#slide=id.g13407fd9db0_0_0
-->

---

### Network Attacks

- Entry nodes and peer discovery
- Data center faults
- Traffic analysis and targetted takedowns

---

## Consensus

---

### Mining Pools

Proof of Work authority sets have no finite bound. But people like to organise.

We actually don't want authority sets to organise because it creates risk.

<!--diagram
https://www.buybitcoinworldwide.com/pages/mining/pools/img/pool-graph.png
-->

---

### Security Dilution

Security is always a finite resource:

- Centralized: Cost of corruption/influence
- Proof of Work: Number of CPUs in the world
- Proof of Stake: Value (by definition, finite)

<!--this is very diagram friendly-->

---

### Security Dilution

Consensus systems compete for security, and they have reason to attack each other.

Emergence of obscure/niche "Proof of X" algorithms to shelter from attack only goes so far.

---

### Authority Misbehavior

- Lack of availability
- Equivocation
	- Authorship: Proposing mutually exclusive chains
	- Finality: Voting for mutually exclusive chains to be final
- Invalidity

---

### Equivocation

<!--diagram, similar to GRANDPA but with equivocating node-->

---

### Validator Consolidation

How many validators does a system need?

Higher numbers should lead to a decrease in the ability for entities to collude.

But validators are expensive! Both economically and computationally.

---

### Polkadot Pause

<!--Note: I'm not sure how much to introduce Polkadot specifics at this point, at the risk of it
    sounding like a sales pitch. But IMO we're in territory where I think Polkadot really is more
	well thought out than others and the uniqueness is both interesting and pertinant.
-->
A few interesting design decisions in Polkadot w/r/t its architecture:

- More validators increases the state transition throughput of the network.
- Individual shards have full economic freedom by being members of a larger consensus system.
- Superlinear slashing puts colluding validators at existential risk (while well-meaning ones should have little to worry about).

---

## Network Access

---

### Node Queries

In an ideal case, application users would run nodes themselves, so as to not trust a provider.

But nodes can consume large amounts of storage, network, and CPU resources.

---

### Node Queries

So, most people outsource.

<!--diagram-->
[Node] --> [Some Company] --trust me!--> [user]

These service providers wield large amounts of power to deceive, censor, and surveil.

---

### Multi-Chain Applications

If running _one_ node is burdensome, try multiple.

<!--diagram, like https://docs.google.com/presentation/d/12CAlrxqnY6ASWI1Tp38FlBn9N9t4sn16fTwhjkxYcVg/edit#slide=id.g11719bb6ffd_0_40 -->

---

### Light Clients

Light clients only store block headers and consensus-critical information. They allow users to query full nodes from RPC providers, but take advantage of hash-based data structure to _verify_ the information coming from the provider.

Storage and bandwidth requirements are low enough to use in a browser extension or mobile device.

---

### Light Clients

<!--diagram-->
[Node] --> [RPC Service] --> {[Light Client] --> [User]}

---

## Validator Power

---

### STF Upgrades



---

### Transaction Censorship and Ordering



---

### 



---

### 



---

### 



---

### 



---

### 



---

### 



---

### 



---

### 



---

### 



---
