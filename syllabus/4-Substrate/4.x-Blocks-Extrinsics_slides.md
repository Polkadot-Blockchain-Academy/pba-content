---
title: Blocks and Extrinsics
duration: 30 minutes
instructors: ["Kian Paimani"]
teaching-assistants: [".."]
---

# Blocks and Extrinsics

<widget-speaker name="Kian Paimani" position="Core Dev" image="../../../assets/img/0-Shared/people/kian.png" github="kianenigma" twitter="kianenigma"></widget-speaker>

---

### Definition: A Block

- [source](https://github.com/paritytech/substrate/blob/c11877f5069155ad4cb97c32576eec39c38c89d1/primitives/runtime/src/generic/block.rs#L85)

```rust
pub struct Block<Header, Extrinsic> {
  pub header: Header,
  pub extrinsics: Vec<Extrinsic>,
}
```

---v

### Definition: A Block

- A header is anything that fulfils [`trait Header`](https://github.com/paritytech/substrate/blob/69b27c572eef910f0c03592086cfdba496bdc169/primitives/runtime/src/traits.rs#L828).
  - number
  - extrinsic root
  - state root
  - parent hash
  - ...
- An extrinsic is anything that fulfils [`trait Extrinsic`](https://github.com/paritytech/substrate/blob/69b27c572eef910f0c03592086cfdba496bdc169/primitives/runtime/src/traits.rs#L938)
  - _call_\*.
  - signature.

---

### Definition: Extrinsic

<div class="text-left">

<h3>extrinsic</h3>

_/ɪkˈstrɪnsɪk,ɛkˈstrɪnsɪk/_

<br />

&nbsp;&nbsp;&nbsp;&nbsp;_adjective_

<br />

> not part of the essential nature of someone or something; coming or operating from outside.
> "a complex interplay of extrinsic and intrinsic factors"

</div>

---v

### Definition: Extrinsic

> An Extrinsic is data that come from outside of the runtime.

Yes, transactions are **a type of extrinsic**, but not all extrinsics are transactions.

<hr />

<div class="text-left">

### Definition: Extrinsic

- **Signed** Extrinsics (--> what you typically call "_transaction_")
- **Unsigned** Extrinsics
- **Inherent** Extrinsics

</div>

---v

### Extrinsic: Signed

- a.k.a. "transactions"
- signed and submitted by external accounts
- _could_ involve some kind of fee payment.

---v

### Extrinsic: Unsigned

- extrinsics which are NOT signed in the "standard way".
- usually still requires a signature to be safe.
- extra layers of programability is provided to developers.

---v

### Extrinsic: Inherent

- data that is provided by block authors
- it may not be strictly deterministic
- "soft" verification by others

> All extrinsics must have some kind of check, else they are not sybil resistant.

---

script fot rest of the lecture: So far, we defined what a _generic_ block is. Also defined all 3 types of extrinsics.

Now let's look at the components that help construct blocks:

- Networking and P2P, everything in this layer is _opaqueu_.
- Tx-Pool
- BlockBuilder
- ImportQueue

---

### Lifecycle of a transaction

<image src="../../../assets/img/4-Substrate/4.4-pool-context.svg" style="width: 1000px">

Notes:

- Transaction are submitted to a transaction pool either externally (by other peers in the network) or locally (by RPC).
- A gossip protocol propagates transactions to other network participants.
- A block author builds the block which in turn updates the runtime's state transition function.

---v

### TxPool Tasks.

It (re)validates transactions, and bans them when needed.

<!-- .element: class="fragment" -->

Orders Transactions

<!-- .element: class="fragment" -->

It provides transaction submission and status updates via RPC.

<!-- .element: class="fragment" -->

---v

### Being Generic

Substrate's transaction pool is extremely generic in the sense that:

- It makes very little assumptions about what a transaction is.

- It allows for the behavior of the pool to be overwritten using rust's trait system (`graph::ChainApi`).

Let's Continue by looking at each of the 3 mentioned tasks of a transaction pool.

---

### 1. Transaction Validation

> Transaction validity is exclusively outside of the transaction pool, and is **100% determined by the Runtime**.

> Transaction validation should be **static** aka. cheap to perform.

<!-- .element: class="fragment" -->

This is done, as you guessed it, through the runtime API.

<!-- .element: class="fragment" -->

---v

### 1. Transaction Validation

The runtime API.

```rust
impl TaggedTransactionQueue<Block> for Runtime {
  fn validate_transaction(
    source: TransactionSource,
    tx: <Block as BlockT>::Extrinsic,
    block_hash: <Block as BlockT>::Hash,
  ) -> TransactionValidity {
    ..
  }
}
```

---v

### 1. Transaction Validation: Source

<pba-cols>

<pba-col center>

<pre>
impl TaggedTransactionQueue<Block> for Runtime {
  fn validate_transaction(
    <strong style="text-decoration:underline">source: TransactionSource,</strong>
    tx: <Block as BlockT>::Extrinsic,
    block_hash: <Block as BlockT>::Hash,
  ) -> TransactionValidity {
    ..
  }
}
</pre>
</pba-col>

<pba-col center>
Substrate's transaction pool implementation makes it possible to apply different validation schemes depending on the source of the transaction.

Transactions can be received either by:

- The network - gossiped by other peers.
- RPC - submitted locally.
  </pba-col>

</pba-cols>

---v

### 1. Transaction Validation

The important bit of this is the return type.

```rust [6]
impl TaggedTransactionQueue<Block> for Runtime {
  fn validate_transaction(
    source: TransactionSource,
    tx: <Block as BlockT>::Extrinsic,
    block_hash: <Block as BlockT>::Hash,
  ) -> TransactionValidity {
    ..
  }
}
```

---v

### 1. Transaction Validation

```rust [1|4|6,7|9|11|14-40]
pub type Tag = Vec<u8>
pub type TransactionValidity = Result<ValidTransaction, TransactionValidityError>;

pub struct ValidTransaction {
  pub priority: u64,

  pub requires: Vec<Tag>,
  pub provides: Vec<Tag>,

  pub longevity: u64,

  pub propagate: bool,
}

pub enum TransactionValidityError {
  Invalid(InvalidTransaction),
  Unknown(UnknownTransaction),
}

pub enum InvalidTransaction {
  Payment,
  Future,
  Stale,
  BadSigner,
  ...
}

pub enum UnknownTransaction {...}
```

---v

### 1. Transaction Validation

> The Runtime tells the pool almost everything, either about the transaction being valid, or invalid.

Notes:
important to emphasize: the transaction pool does not know what a valid transaction is because of
the runtime/client boundary, because it does not know the runtime at all. It can only "ask" the
runtime.

---v

### 1. Transaction (re)Validation

```rust [5]
pub struct ValidTransaction {
  pub priority: u64,
  pub requires: Vec<_>,
  pub provides: Vec<_>,
  pub longevity: u64,
  pub propagate: bool,
}
```

- The longevity means how long the transaction validity (whatever it was) is valid for.

- The pool re-checks with the pool based on this field.

---v

### 1. Transaction Validation: Banning

Once certain transaction is discovered to be invalid, it is banned for a fixed duration of time.

Default in substrate is `Duration::from_secs(60 * 30)`.

> Update: https://github.com/paritytech/substrate/pull/11786

Notes:

TODO we probably also ban the peer who sent us that transaction? but have to learn.

---

### 2. Transaction Ordering

```rust [3,4]
pub struct ValidTransaction {
	pub priority: u64,
	pub requires: Vec<_>,
	pub provides: Vec<_>,
	pub longevity: u64,
	pub propagate: bool,
}
```

The pool clusters **validated** transactions into two groups:

1. **Ready**: All of the `requires` tags of that transaction have already been seen _by other `Ready` transactions_.
2. **Future**: Some of the `requires` tags of that transaction have not yet been seen.

---v

### 2. Transaction Ordering: Quiz Time.

```rust
pool.import(Transaction {
  data: vec![1u8],
  requires: vec![],
  provides: vec![],
  ..Default::default()
});
```

```rust
pool.ready().count() // 1
pool.future().count() // 0
```

<!-- .element: class="fragment" -->

---v

### 2. Transaction Ordering: Quiz Time.

```rust
pool.import(Transaction {
  data: vec![1u8],
  requires: vec![1],
  provides: vec![2],
  ..Default::default()
});
```

```rust
pool.ready().count() // 1
pool.future().count() // 1
```

<!-- .element: class="fragment" -->

---v

### 2. Transaction Ordering: Quiz Time.

```rust
pool.import(Transaction {
  data: Default::default(),
  requires: vec![2],
  provides: vec![3],
  ..Default::default()
});
```

```rust
pool.ready().count() // 1
pool.future().count() // 2
```

<!-- .element: class="fragment" -->

---v

### 2. Transaction Ordering: Quiz Time.

```rust
pool.import(Transaction {
  data: Default::default(),
  requires: vec![],
  provides: vec![1],
  ..Default::default()
});
```

```rust
pool.ready().count() // 4
pool.future().count() // 0
```

<!-- .element: class="fragment" -->

---v

### 2. Transaction Ordering

> Common example: Wallet knows the current account nonce, and wants to submit a transaction for Alice.

```rust
requires: vec![(alice, current_nonce).encode()],
provides: vec![(alice, current_nonce + 1).encode()],
```

<!-- .element: class="fragment" -->

---v

### 2. Transaction Ordering

Once block authoring is happening, we only look at the **Ready** (sub)pool.

<image src="../../../assets/img/4-Substrate/4.4-pool-context.svg" style="width: 1000px">

---v

### 2. Transaction Ordering

From that pool, we take the transaction with the **highest priority** (and repeat).

Or, if you want to be specific, the pool orders based on:

1. priority.
2. ttl: shortest longevity goes first.
3. time in the queue: longest to have waited goes first.

<!-- .element: class="fragment" -->

---v

### 2. Transaction Ordering

> Someone asked the other day why the pool is not FIFO. Well, if you write a runtime that sets all
> priority to 0.. what happens?

---

### 3. Submission And Reporting

The transaction queue exposes a `submit_and_watch` api.

This is how applications submit transactions, and watch the outcome.

---v

### 3. Submission And Reporting

```rust
pub enum TransactionStatus<Hash, BlockHash> {
	/// Transaction is part of the future queue.
	Future,
	/// Transaction is part of the ready queue.
	Ready,
	/// The transaction has been broadcast to the given peers.
	Broadcast(Vec<String>),
	/// Transaction has been included in block with given hash.
	InBlock(BlockHash),
	/// The block this transaction was included in has been retracted.
	Retracted(BlockHash),
	/// Maximum number of finality watchers has been reached,
	/// old watchers are being removed.
	FinalityTimeout(BlockHash),
	/// Transaction has been finalized by a finality-gadget, e.g GRANDPA
	Finalized(BlockHash),
	/// Transaction has been replaced in the pool, by another transaction
	/// that provides the same tags. (e.g. same (sender, nonce)).
	Usurped(Hash),
	/// Transaction has been dropped from the pool because of the limit.
	Dropped,
	/// Transaction is no longer valid in the current state.
	Invalid,
}
```

---

### Bonus: A Page In History

> https://github.com/paritytech/substrate/issues/728

> Work towards a flexible transaction queue that relies **only on runtime logic to provide comprehensive dependency and queuing management**... should not be aware of the concepts of accounts, signatures, indexes or nonces.

> Returns `Valid` if the transaction can be **statically** validated; ... the u64 is the priority used to determine which of a mutually exclusive set of transactions are better to include... Any transactions that do get included in a block should be instantly discarded (and banned) if they result in a panic execution.
