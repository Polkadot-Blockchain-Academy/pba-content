---
title: Host/Runtime Interface # Also update the h1 header on the first slide to the same name
description: Substrate Host/Runtime Interface deep dive
duration: 1 hour
instructors: ["Joshy Orndorff", "Kian Paimani"]
teaching-assistants: ["Joshy Orndorff"]
---

## Host/Runtime Interface

Lecture 4, Module 4

Instructor: Joshy Orndorff, Kian Paimani

---v

The Client / Runtime division is one of the most important design decisions in Substrate.

In this lesson:

- Where is the division (the "wasm boundary")?
- Why did we make this distinction?
- How the two parts communicate with each other

---


### Language for a blockchain

- wasm
- ethereum evm blockchain specific opcode: SSTORE, SLOAD, CODESIZE, ORIGIN, ADDRESS, SHA3...
- wasm module function import and export
- ethereum transaction model

Note:

TODO not really happy with this slide, just like to relate to wasm design choice.

purpose here is to mention that wasm is a good choice for being generic and blockchain specific are just using standard wasm export and imports.

wasm instruction : good enough generic set of instruction for general deterministic computation as soon as you disable/forbid certain things (float mostly).

eth storage opcode are not what you expect from a general language, they are more a kind of std/external call.
It fits storage, it fits small computation, but using a real existing shared computing instruction set like wasm how do we do that:
window on tho io storage world

we can see two reason for these instruction:
- technical (speed) : eg SHA3  or ethereum Precompile (spending two minute on what they are can be good: actually could make sense
later in polkadot to show that this precompile model at a parachain level would work but it would not be available for pov verification
(as many optimization)).
- persistance. Chain state modification.
- ethereum got transaction of modified content embeded in the way thing works, we will see later that substrate simply use host function to reproduce this mechanism.


---

## The Substrate Runtime

![Diagram of Substrate Node](../../../assets/img/4-Substrate/4.4-node-diagram.png)

- Inside the boundary, in wasm, is the runtime
- Outside the boundary, in Rust, is the client

Notes:

On the client side, you have:

- P2P networking
- Block database including block storage
- Consensus (Block authoring/Finality)
- Wasm executor
  These are the normal P2P blockchain style tasks. Most chain developers will not want to customize this stuff at all. If you want to, you can. Especially consensus. But you typically won't need to.

Interesting to note that not all these element are directly (through host function) reachable from the runtime.
storage is, but behind a state-machine overlay.
wasm executor is, but not in real life usage (through the experimental worker api).
networking is but only in a limited form and only for offchain host function TODO have a slide at the end on offchain TODO check there is one on deterministic nature.


---v

### The Runtime _IS_ the STF

Its jobs are:

- Execute entire blocks
- Determine Transaction validity
- Communicate state changes to client as transactions are executed.
- Construct Blocks -- Only some nodes will call this API, but the runtime needs to support it.
- Consensus-adjacent tasks like authority set management
- Provide data to the client upon request through accessor apis (eg Aura Api)

Notes:
The first three are really the core jobs. Constructing blocks is a job for miners or validators. It makes sense to do block construction with the runtime because much code will be shared and the runtime itself is what will validate the blocks anyway.
Consensus related tasks are really just part of the same state transition logic. Although they can feel "meta" they are equal with token transfers etc.
Jobs like accessing data might seem tangential and redundant. We will talk about them more shortly

"Communicate state changes": TODO the expression confuse me a bit, it gives me the feeling that runtime is responsible for sending changes, but most of change management implementation is done in client side (eg transaction, change overlay and all state machine).

---v

### Why make the Runtime distinction?

Two reasons.

1. Separation of concerns
  * Runtime contains the chain's "business logic"
  * Most chains will only want to customize the Runtime
  * This is just good software engineering.

2. But the really compelling reason....

---v

### Runtime Upgrades!

The Runtime can _change_ through the life of the chain.

Analogy you can flash a new program on to your micro-controller. It can even use the same data that is stored on disk and same peripheral hardware. Likewise, you can deploy a new runtime to the blockchain.

This will be covered in much more detail later on. For now, know that it can happen.

---

## Client - Runtime Communication

<div class="left">

- The runtime uses host functions to get data from the client
- The client uses runtime apis to get data from the runtime
</div>

<div class = "right">

![Diagram of Substrate Node with RuntimeAPIs and Host Functions highlighted](../../../assets/img/4-Substrate/4.4-node-with-apis-labeled.png)

</div>

Notes:
sometime 'host functions' are refered as 'host api' eg in polkadot spec


---v

## An Alternate Visualization

![Two way Communication between Client and Runtime](../../../assets/img/4-Substrate/4.4-calling-between-client-and-runtime.png)


TODO I prefer the other schema, having arrow give me the feeling it is a flow of information going and I would have expected 'host function call' outgoing and 'host function reply' incomming.
Runtime api similarily, with 'trap' in addition to reply (no trap for client).

---v

## Example: Block Execution

To execute a block, we need both host functions and runtime apis:

- Runtime API: for example `execute_block` - The client provides a block to the runtime, and expects the runtime
  to execute that block.

- Host Function - for example `storage_get` - To execute the block, the runtime will probably need to read
  storage, which only the client has access to.

---v

## Smart Contracts use the same technique

![Communication between Client, Runtime, and Wasm Smart Contract](../../../assets/img/4-Substrate/4.4-client-runtime-contract.png)

We'll learn more in Lesson 6.5 about pallet contracts

---

## Coding Exercise

<!-- TODO: create the example starter code and work through the entire example. Link both starting point and example solutions. -->

Instructor has pre-written a basic minimal (toy) application that calls into a simple runtime using a simplified interface.
It creates a handful of blocks and tracks the state at each block. The initial example runtime does nothing.
Together we write a second runtime that acts as a flipper
Then we write one that acts as an adder.

---v

Exercise: make it so you can only add if you are adding at least 10% of the current accumulated value.

---v

Exercise: Write one that acts as an adder and subtracter. Add more operations as well like multiply, mod, whatever you want. This introduces the idea of transaction types.

---v

Exercise: Write one that has both the flipper and adder functionality. They should be orthogonal. Now you must keep track of multiple pieces of state.

---v

## Regroup after the Exercises

Instructor demonstrates how we can swap the runtime part way through.

Discussion points:

- Are these runtimes economically secure? <!-- no, there are no fees at all, nor prioritization -->
- Is the adder secure other than the fee part? <!-- no, it can overflow -->

---

## Substrate Runtime APIs

Some [existing runtime APIs](https://github.com/substrate-developer-hub/substrate-node-template/blob/main/runtime/src/lib.rs#L334) in Substrate include:

-  **Core** - most important - for executing blocks
-  **TxQueue** - tells the offchain code whether a transaction is valid and how to prioritize it.
- **BlockBuilder** - critical for authoring nodes - for writing blocks
- **Metadata** - we won't use it much today - to teach offchain tools the structure of your storage and extrinsics
- **Session Keys** - allow the runtime to generate cryptographic keys that will be used on the client side
- **Consensus related** - Aura, Babe, Grandpa, PoW all have their own - allows fetching consensus info from the runtime
- Accessors - many pallets will provide simple "getters" to obtain storage data. One example is the Aura API that just returns the authorities from storage. Any pallet author can write their own, and often some post-processing is included.


Notes:

TODO here (or just before) may be a good time to do in a terminal (or have some extract of it in slide):
```
cd substrate
fd .wasm
wasm2wat client/executor/benches/kusama_runtime.wasm | less
```
and then lookup `execute_block` and /export and /import 
Describe what is 'env' and quickly show Core_execute_block and for host function the versioning, don't forget to mention that the runtime only board import it uses (generally latest function but doesn't need to be).
inkerc20 is interesting for it's export.

Also can spend some time describing Block builder runtime api and underline that when building block we just run the extrinsic in a way
that mimic the executeblock logic: in some case parachain may need to for this logic.
Execute block calls initialize, and all extrinsic sequentiall then finalize.
Block building build context (Core_initialize_block) and try extrinsic one by one (BlockBuilder_apply_extrinsic).
But ultimately block building need to call Core_execute_block over their extrinsic choice.
(it is a bit of a digression but show how these host function are really relative to context, a question could rise: why not multiple runtime for each context: reduce size of runtime... Reply: runtime caching, shared code, generally a trade off).

---

## Substrate Host functions

See [some existing host functions](https://github.com/paritytech/substrate/blob/master/primitives/io/src/lib.rs) in Substrate:

- crypto and hashing
- io
  - storage
  - print
- allocating memory
- also extensible

Notes:

Extensible but with a lot of limitation when it comes to the polkadot system as will be seen in the next modules.

---

## Opaque Types (and round trips)

<div class = "right">
![Diagram showing round-trip communication between client and runtime and back to retrieve authorities from storage](../../../assets/img/4-Substrate/4.4-round-trip.png)

</div>
<div class= "left">
Question: Why make a roundtrip through the runtime instead of fetching the data directly from storage?
</div>

Notes:
Consider this design which is common in Pallets (for example, frontier).
The client calls a runtime API accessor to request some data. The runtime calls a host function to get the data from storage, then returns it.
TODO: locally the image did not show  for me

---v

First answer: You don't _have_ to make the round trip. There is the StorageBackend. (Frontier occasionally uses this _as an optimization_). But you should make the trip because...

---v

### Opaque Types

If the Runtime can change mid-flight, so can its data types, and storage keys.

Typical types that the client can't interpret:

- `Extrinsic`
- `Block`
- `AcccountId` - if you even have such a type
- Any data structures you store in storage
  - Token values
  - NFT data

Notes:
Since The substrate runtime is upgradeable, the data types it uses can change at any time
The client-side can't make any assumptions about what data types the runtime uses.
When the client is passing around and handling runtime data, it uses scale-encoded data. Just `Vec<u8>`. The client can't interpret the data at all.
Because the client can't interpret even basic data types like transaction, we have to call into the runtime for such things.
This is why we make a round trip through the runtime.

---v

### TransactionPoolApi

Did you ever wonder why the transaction pool logic is in the runtime? The TxPool is offchain. It is not part of the STF. If the runtime is the STF, why wrap TxPool logic into it.

Hopefully you can explain the answer based on the past few slides. Someone volunteer to explain it in your own words.

Notes:
Even the transaction type can change at any time. To the client it is just `Vec<u8>`. In order to validate them and prioritize them, we call into the runtime. The runtime just tells whether it is valid, and assigns a priority. Plus the whole tagged part which you covered in the previous lesson.

---

## More Subtle Considerations

Here are some practical tips and gotchas when extending Runtime APIs and Host Functions

---v

## Determinism

- For host function call from runtime all implement MUST be deterministic

- For host function call from offchain worker, no need too


Notes:

Move to the conclusion that offchain worker host function being in sp_io crate can be a big foot gun:
if you got a runtime you can try to use it (eg call http) and have a broken consensus.

## Speed

- Difference of speed between Wasm and native.
- How much slower is using the Wasm implementation than executing a native function
- Cost of calling a host function.
- Analogy: when contacting host function from Wasm, its like your OS contacting IO buffer

Notes:
- cost of calling is parameter passing: memory copy: one should strive to reduce the number of call to host function.
For instance in storage when calculating the root we do not build it in wasm and call the hash host function multiple times: we just have a host function doing the root calculation and state trie kept in client.
On the other hand things as `next_storage` are high cost (generally iteration on state from runtime is expensive). This design is related to the memory location, there is alternative but this is simple (simple as good design).
(iteration remains very costy: because each call to next is going through the host function boundaries (and historically caching is not supporting it : only get: trade off between code complexity and performance here)
note that with cumulus we do build the trie in wasm but it is a different use case.
- Question: we got host function for runing computation intensive code in native, but when simd for wasm would be added, then
will host function for a hashing be still usefull: wait and see, but is possible that simd optim of the hash function in wasm is way faster.
Again using a host function for speed up needs to be reasoned, cost of transmitting parameter in wasm can be bigger than the actual hashing
cost.

- one can notice that such host function in the context of cumulus pvf, only make sense if both in relay chain and para. Still a para can use custom host function for speed and pvf on a wasm implementation of it.

---v

## Advanced

- transaction (state machine transactional overlay)
- threads
- storage root

Note:

TODO I copied this since it was in my other branch, not convinced it is needed: will probably be part of others modules.

storage root: can spend time on it: explain the need to cache things, even go through state machine code a bit.

This is a good cost gain as using trie code on the hash function would be a LOT of host function calls.
Yet when using cumulus, that is what happen.

---v

## Missing Host Function

- If you have a runtime which expects a host function which does not exist, the runtime will fail at instantiation.
- When the client has a host function the runtime doesn't know of or need, nothing happens.
- If your new runtime needs a new host function, all nodes must upgrade first.

Notes:
First point, can talk about the memory passing and the fact that some types pass natively, while others are just scale encoded (actually this is something that need to be in the presentation: TODO maybe a slide for it) with obviously an even higher hast function call price.
This is handled by macros, this kind of linkage is very important: maybe word a bit about component proposal and WIT (and the fact that we don't use them).


Third point really need to be stressed: host function change require client upgrade not just runtime update.



---v

## Versioning and backwards compatibility

- Host functions are **FOREVER**: when finalizing a block that uses a specific host function, you always need to keep the same host functions.
- Imagine syncing your chain from scratch, every version of your blockchain's runtime will be needed to sync and get to the latest block.
- Thus your client must be able to provide all the host functions expected in the past and for
  present/future blocks.
- What level of specification do we need?

Note: Distinguish the implications of adding/removing host functions (and the lack of implications when adding runtime api).

https://github.com/w3f/polkadot-spec/tree/main/host-spec

Stress that a bug in a host function will need to stay (can point some), and worse will need to be implemented by all clients (eg gossamer).
Also the buggy or ill designed host function will need to be specified, you can check the polkadot spec and see some of those.


But still forever could end after a regenesis :)

Also stress that version are just different host function (nothing prevent from runing to different version in a runtime).

---

## Defining a Runtime API

- Use the `impl_runtime_api!` macro.
- No matter the return type, client sees the outcome as `Vec<u8>`.
- Client can always provide extra `at: Option<BlockNumber>`.


Note:

client side storage host function directly it a 'environmental' context that correspond to a backend at a given block.
Probably no need to go in architecture here.

---

<div class="left">

- conveniently a Rust trait
- always generic over `Block`.

</div>

<div class="right">

For example:

<pre><code style="font-size: 0.5em !important" data-trim data-noescape data-line-numbers="0-13" class="rust">
/// The `Metadata` api trait that returns metadata for the runtime.
pub trait Metadata {
  /// Returns the metadata of a runtime.
  fn metadata() -> OpaqueMetadata;
}

impl_runtime_api! {
  impl sp_api::Metadata<Block> for Runtime {
    fn metadata() -> OpaqueMetadata {
      OpaqueMetadata::new(Runtime::metadata().into())
    }
  }
}

</prev></code>

</div> 

---v

## Which Runtime APIs are "required"?

Depends on what you are doing.

![Venn Diagram distinguishing APIs that are called 1-on-chain, 2-off-chain, 3-in-development](../../../assets/img/4-Substrate/4.4-Venn.png)

## Cannonical Runtime APIs

These runtime APIs are needed by nodes to operate the live network. They are compiled into the on-chain wasm binary, and the chain breaks without them.

* On-chain ones are called in the block creation or execution flow. Consensus is reached over their results.
* Off-chain ones are called from off-chain contexts and are critical but consensus is not reached over their result.

## Feature gated runtime APIs for development

There are ways to implement runtime interfaces for development purposes, such as:

- Testing and verification: `try_runtime`
- Benchmarking: `frame_benchmarking`

---

## Defining a Host Function

<div class="left">

* use the `#[runtime_interface]` attribute
* just like an ordinary Rust trait

</div>

<div class="right">

For example:

<pre><code style="font-size: 0.5em !important" data-trim data-noescape class="rust">
  #[runtime_interface]
  pub trait Storage {
    /// Returns the data for `key` in the storage or `None` if the key can not be found.
    fn get(&self, key: &[u8]) -> Option<Vec<u8>> {
      self.storage(key).map(|s| s.to_vec())
    }

</prev></code>

</div>

---

## Coding Activity - Flipper Runtime

In this activity, we will write a Substrate runtime together without using FRAME.

Avoiding FRAME allows us to focus on implementing the Runtime APIs as they are written and use the host functions directly.

As a bonus this sets us up well to say "look how much easier and nicer FRAME is" in module 6.

This code is working in https://github.com/substrate-developer-hub/substrate-node-template/pull/347

<!-- TODO: Although the code is working, I still need to decide the best order to write each part pedogogically. -->


---v

### Exercise: Adder

Make it an adder like in our toy example earlier.

Bonus points for adding any of the enhancements from earlier:
* make it an adder / multipler.
* make it so you have to add at least 10%
* make it both flipper and adder.

---v

Make this runtime upgradeable!

You just need to store the new wasm code at the special `b":code"` key

### Exercise: Custom Host Function

Write a custom host function for your runtime. A simple example would be to use a different crypto like RSA or SM2. For an example of using custom crypto host function see https://github.com/hammeWang/substrate-sm2

### Exercise: Custom Runtime Api

Write a custom Runtime Api that fetches the current value of the adder.

As a more realistic example: If you have added the add-at-least-10% feature, this runtime API could return the minimum amount needed to be added next.

### Deterministism question

use case: In state we have 5u32 LE stored at key ":counter".
This value will be increase in a block by extrinsic 1.

case 1: value is read by extrinsic 1 stored in state machine overlay and written end of block
case 2: "increment :counter by one" operation is written in state machine and actual update and read is done end of block

Then both implementation sounds equivalent, but if you consider that your change may be drop, things are
very different: if the change ends up being drop, in case 1 the original counter value got accessed and
not in case 2, so the foot prints are very differnt and proofs needed are.
So case 2 is always better but it is not how it is implemented, and this kind of interaction ultimately
would need to be reflected by the specification (not the case probably).

This kind of logic are really sensitive and sometime, implementation of host function needs to be so similar to ensure determinism.
(project such as gossamer tend to suffer for specification being a bit to shallow in some area, in the end tests/fuzzing are all eg ethereum json test suite, alas for substrate we are not there yet).

