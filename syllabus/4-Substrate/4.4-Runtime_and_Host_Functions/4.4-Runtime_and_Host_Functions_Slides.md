## Host/Runtime Interface

Lecture 4, Module 4

Instructor: Bastian KÃ¶cher

---v

In this lesson we'll learn about how the client / runtime division in Substrate is one of the most important decisions that Substrate has taken.
Thus, understanding the communication interface between the two is equally important.

---

### Language for a blockchain

- wasm
- ethereum evm blockchain specific opcode: SSTORE, SLOAD, CODESIZE, ORIGIN, ADDRESS, SHA3...
- wasm module function import
- ethereum transaction model

Note:

wasm instruction : good enough generic set of instruction for general deterministic computation as soon as you disable certain things.

eth storage opcode are not what you expect fro m a general language, they are more a kind of std/external call.
It fits storage, it fits small computation, but using a real existing shared computing instruction set like wasm how do we do that:
window on tho io storage world

we can see two reason for these instruction:
- technical (speed) : eg SHA3  or ethereum Precompile (spending two minute on what they are can be good: actually could make sense
later in polkadot to show that this precompile model at a parachain level would work but it would not be available for pov verification
(as many optimization)).
- persistance. Chain state modification.
- ethereum got transaction of mdified content embeded in the way thing works, we will see later that substrate simply use host function to reproduce this mechanism.

### What does the runtime interface look like?

<div class="left">
The client and runtime need a way to communicate with eachother:

- The runtime uses host functions to get data from the client
- The client uses runtime apis to get data from the runtime
  </div>

  ![Diagram of Substrate Client](http://placehold.jp/150x150.png)

  _TODO: diagram of two way communication between the Runtime api and host functions._

---

## Example: Block Execution

To execute a block, we need both host functions and runtime apis:

- Runtime API: for example `execute_block` - The client provides a block to the runtime, and expects the runtime
  to execute that block.

- Host Function - for example `storage_get` - To execute the block, the runtime will probably need to read
  storage, which only the client has access to.

---

## Runtime APIs

Some [existing runtime APIs]((https://github.com/paritytech/substrate/blob/master/bin/node/runtime/src/lib.rs#L1618) in Substrate include:

- Core
- TxQueue
- BlockBuilder

---

## Host functions

See [some existing host functions](https://github.com/paritytech/substrate/blob/master/primitives/io/src/lib.rs) in Substrate:

- crypto and hashing
- io
  - storage
  - print
- allocating memory

---

## Speed

- Wasm interfaces are slow to access
- Analogy: when contacting host function from Wasm, its like your OS contacting IO buffer
- Hash host function
- Simd for wasm

TODO

Note:

- simd: ask the audience: we got host function for runing computation intensive code in native, but when simd for wasm would be added, then
will host function for a hashing be still usefull: wait and see, but is possible that simd optim of the hash function in wasm is way faster.
And if wasm code coul be shared as component.
Again using a host function for speed up needs to be reasoned.


---

## State

- key value like storage api
- changes are local to the state
- trie oriented
- offchain host function are non local change


Note:

trie oriented: values are ordered, we expose next_value api. Consequences, the storage, caches are using btreemap
same as key value api (iteration remains very costy: because each call to next is going through the host function boundaries (and historically caching is not supporting it : only get: trade off between code complexity and performance here).

---

## Advanced

- transaction (state machine transactional overlay)
- threads
- storage root

Note:

storage root: can spend time on it: explain the need to cache things, even go through state machine code a bit.

This is a good cost gain as using trie code on the hash function would be a LOT of host function calls.
Yet when using cumulus, that is what happen.


## Common errors

What could go wrong?

- If you have a runtime which expects a host function which does not exist, or vice versa, the runtime will fail at instantiation.

Note: When the client has a host function the runtime doesn't know of or need, nothing happens.

This is handled by macros, this kind of linkage is very important: maybe talk a bit about component proposal.

---

## Versioning and backwards compatibility

- Host functions are **FOREVER**: when finalizing a block that uses a specific host function, you always need to keep the same host functions.
- Imagine syncing your chain from scratch, every version of your blockchain's runtime will be needed to sync and get to the latest block.
- Thus your client must be able to provide all the host functions expected in the past and for
  present/future blocks.

Note: Distinguish the implications of adding/removing host functions (and the lack of implications when adding runtime api).

Only way to remove host function could be to regenesis the relay chain.

---

## Exercise 1

Let's walkthrough the existing host functions / runtime interfaces.

What runtime interface is most commonly used when developing?

---

## Feature gated runtime APIs and host functions

There are ways to implement runtime interfaces for development purposes, such as:

- Testing and verification: `try_runtime`
- Benchmarking: `frame_benchmarking`

Basically anything which should be executed locally (or non-consensus code path), and not on the public network.

---

## Polkadot Standard Proposals

- How might we introduce a new host function into the Polkadot ecosystem?

- What level of specification do we need?

https://github.com/w3f/polkadot-spec/tree/main/host-spec

TODO

Notes:

specifying:
- api
- documenting function
- really need to go into implementation details sometime. Good example is storage where state machine
logic needs to be described. For instance do we drop values.
It usually ends up relate to the accesses done on the state trie.

Question: 
use case: In state we have 5u32 le stored at key ":counter".
This value will be increase in a block by extrinsic 1.

case 1: value is read by extrinsic 1 stored in state machine overlay and written end of block
case 2: increment by one is written in state machine and actual update and read is done end of block

Then both implementation sounds equivalent, but if you consider that your change may be drop, things are
very different: if the change ends up being drop, in case 1 the original counter value got accessed and
not in case 2, so the foot prints are very differnt and proofs needed are.
So case 2 is always better but it is not how it is implemented, and this kind of interaction ultimately
would need to be reflected by the specification (not the case prbably).

-> link to the polkadot spec web

---

## How to write a Runtime API

- Use the `impl_runtime_api!` macro.
- No matter the return type, client sees the outcome as `Vec<u8>`.
- Client can always provide extra `at: Option<BlockNumber>`.

---

<div class="left">

- conveniently a Rust trait
- always generic over `Block`.

</div>

<div class="right">

For example:

<pre><code style="font-size: 0.5em !important" data-trim data-noescape data-line-numbers="0-13" class="rust">
/// The `Metadata` api trait that returns metadata for the runtime.
pub trait Metadata {
  /// Returns the metadata of a runtime.
  fn metadata() -> OpaqueMetadata;
}

impl_runtime_api! {
  impl sp_api::Metadata<Block> for Runtime {
    fn metadata() -> OpaqueMetadata {
      OpaqueMetadata::new(Runtime::metadata().into())
    }
  }
}

</prev></code>

</div> 

---

## How to write a Host Function

<div class="left">

* use the `#[runtime_interface]` attribute
* just like an ordinary Rust trait

</div>

<div class="right">

For example:

<pre><code style="font-size: 0.5em !important" data-trim data-noescape class="rust">
  #[runtime_interface]
  pub trait Storage {
    /// Returns the data for `key` in the storage or `None` if the key can not be found.
    fn get(&self, key: &[u8]) -> Option<Vec<u8>> {
      self.storage(key).map(|s| s.to_vec())
    }

</prev></code>

</div>

---

## Bonus

* Why the way smart contract functions work is unusual (two-way)
* Instantiating multiple wasm instances

(TODO: see where to fit this section / what to add)

---

## Workshop and Activities

* [Create an Offchain worker](./4.4-Workshops_and_Activities/4.4-Runtime_and_Host_Functions_Workshop.md)
* [Create your own runtime interface](./4.4-Workshops_and_Activities/4.4-Runtime_and_Host_Functions_Activities.md)
