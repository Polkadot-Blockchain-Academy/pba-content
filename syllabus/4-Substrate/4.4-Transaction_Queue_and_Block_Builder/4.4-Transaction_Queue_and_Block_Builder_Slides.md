---
title: Transaction Queue and Block Builder
description: Substrate Transaction Queue and Block Builder for Web3 engineers
duration: 1 hour
instructors: ["Kian Paimani"]
teaching-assistants: ["Sacha Lansky"]
---

# Transaction Queue and Block Builder

---

### Context

<image src="../../../assets/img/4-Substrate/4.4-pool-context.svg" style="height: 600px">

Notes:

- Transaction are submitted to a transaction pool either externally (by other peers in the network) or locally (by RPC).
- A gossip protocol propagates transactions to other network participants.
- A block author builds the block which in turn updates the runtime's state transition function.

---v

### TxPool Tasks.

It (re)validates transactions, and bans them when needed.

<!-- .element: class="fragment" -->

Orders Transactions

<!-- .element: class="fragment" -->

It provides transaction submission and status updates via RPC.

<!-- .element: class="fragment" -->

Notes:
TODO: more study on banning.

---v

### Being Generic

<br>

Substrate's transaction pool is extremely generic in the sense that:

<br>

- It makes very little assumptions about what a transaction is.

- It allows for the behavior of the pool to be overwritten using rust's trait system (`graph::ChainApi`).

<br>

Let's Continue by looking at each of the 3 mentioned tasks of a transaction pool.

---

### 1. Transaction Validation

<br>

> Transaction validity is exclusively outside of the transaction pool, and is **100% determined by the Runtime**.

> Transaction validation should be **static** aka. cheap to perform.

<!-- .element: class="fragment" -->

This is done, as you guessed it, through the runtime API.

<!-- .element: class="fragment" -->

---v

### 1. Transaction Validation

The runtime API.

```rust
impl TaggedTransactionQueue<Block> for Runtime {
  fn validate_transaction(
    source: TransactionSource,
    tx: <Block as BlockT>::Extrinsic,
    block_hash: <Block as BlockT>::Hash,
  ) -> TransactionValidity {
    ..
  }
}
```

---v

### 1. Transaction Validation: Source

<br>

<div class="flex-container">

<div class="left">

<pre>
impl TaggedTransactionQueue<Block> for Runtime {
  fn validate_transaction(
    <strong style="text-decoration:underline">source: TransactionSource,</strong>
    tx: <Block as BlockT>::Extrinsic,
    block_hash: <Block as BlockT>::Hash,
  ) -> TransactionValidity {
    ..
  }
}
</pre>
</div>

<div class="right">
Substrate's transaction pool implementation makes it possible to apply different validation schemes depending on the source of the transaction.

Transactions can be received either by:

- The network - gossiped by other peers.
- RPC - submitted locally.
</div>

</div>

---v

### 1. Transaction Validation

The important bit of this is the return type.

```rust [6]
impl TaggedTransactionQueue<Block> for Runtime {
  fn validate_transaction(
    source: TransactionSource,
    tx: <Block as BlockT>::Extrinsic,
    block_hash: <Block as BlockT>::Hash,
  ) -> TransactionValidity {
    ..
  }
}
```

---v

### 1. Transaction Validation

```rust [1|4|6,7|9|11|14-40]
pub type TransactionValidity = Result<ValidTransaction, TransactionValidityError>;

pub struct ValidTransaction {
  pub priority: u64,

  pub requires: Vec<Vec<u8>>,
  pub provides: Vec<Vec<u8>>,

  pub longevity: u64,

  pub propagate: bool,
}

pub enum TransactionValidityError {
  Invalid(InvalidTransaction),
  Unknown(UnknownTransaction),
}

pub enum InvalidTransaction {
  Payment,
  Future,
  Stale,
  BadSigner,
  ...
}

pub enum UnknownTransaction {...}
```

---v

### 1. Transaction Validation

<br>

> The Runtime tells the pool almost everything, either about the transaction being valid, or invalid.

Notes:
important to emphasize: the transaction pool does not know what a valid transaction is because of
the runtime/client boundary, because it does not know the runtime at all. It can only "ask" the
runtime.

---v

### 1. Transaction (re)Validation

```rust [5]
pub struct ValidTransaction {
  pub priority: u64,
  pub requires: Vec<_>,
  pub provides: Vec<_>,
  pub longevity: u64,
  pub propagate: bool,
}
```

- The longevity means how long the transaction validity (whatever it was) is valid for.

- The pool re-checks with the pool based on this field.

---v

### 1. Transaction Validation: Banning

Once certain transaction is discovered to be invalid, it is banned for a fixed duration of time.

Default in substrate is `Duration::from_secs(60 * 30)`.

> Update: https://github.com/paritytech/substrate/pull/11786

Notes:

TODO we probably also ban the peer who sent us that transaction? but have to learn.

---

### 2. Transaction Ordering

```rust [3,4]
pub struct ValidTransaction {
	pub priority: u64,
	pub requires: Vec<_>,
	pub provides: Vec<_>,
	pub longevity: u64,
	pub propagate: bool,
}
```

The pool clusters **validated** transactions into two groups:

1. **Ready**: All of the `requires` tags of that transaction have already been seen _by other `Ready` transactions_.
2. **Future**: Some of the `requires` tags of that transaction have not yet been seen.

---v

### 2. Transaction Ordering: Quiz Time.

```rust
pool.import(Transaction {
  data: vec![1u8],
  requires: vec![],
  provides: vec![],
  ..Default::default()
});
```

```rust
pool.ready().count() // 1
pool.future().count() // 0
```

<!-- .element: class="fragment" -->

---v

### 2. Transaction Ordering: Quiz Time.

```rust
pool.import(Transaction {
  data: vec![1u8],
  requires: vec![1],
  provides: vec![2],
  ..Default::default()
});
```

```rust
pool.ready().count() // 0
pool.future().count() // 1
```

<!-- .element: class="fragment" -->

---v

### 2. Transaction Ordering: Quiz Time.

```rust
pool.import(Transaction {
  data: Default::default(),
  requires: vec![2],
  provides: vec![3],
  ..Default::default()
});
```

```rust
pool.ready().count() // 1
pool.future().count() // 2
```

<!-- .element: class="fragment" -->

---v

### 2. Transaction Ordering: Quiz Time.

```rust
pool.import(Transaction {
  data: Default::default(),
  requires: vec![],
  provides: vec![1],
  ..Default::default()
});
```

```rust
pool.ready().count() // 4
pool.future().count() // 0
```

<!-- .element: class="fragment" -->

---v

### 2. Transaction Ordering

<br>

> Common example: Wallet knows the current account nonce, and wants to submit a transaction for Alice.

```rust
requires: vec![(alice, current_nonce).encode()],
provides: vec![(alice, current_nonce + 1).encode()],
```

<!-- .element: class="fragment" -->

---v

### 2. Transaction Ordering

Once block authoring is happening, we only look at the **Ready** (sub)pool.

<image src="../../../assets/img/4-Substrate/4.4-pool-context.svg" style="height: 600px">

---v

### 2. Transaction Ordering

From that pool, we take the transaction with the **highest priority** (and repeat).

Or, if you want to be specific, the pool orders based on:

1. priority.
2. ttl: shortest longevity goes first.
3. time in the queue: longest to have waited goes first.

<!-- .element: class="fragment" -->

---v

### 2. Transaction Ordering

<br>

> Someone asked the other day why the pool is not FIFO. Well, if you write a runtime that sets all
> priority to 0.. what happens?

---

### 3. Submission And Reporting

The transaction queue exposes a `submit_and_watch` api.

This is how applications submit transactions, and watch the outcome.

---v

### 3. Submission And Reporting

```rust
pub enum TransactionStatus<Hash, BlockHash> {
	/// Transaction is part of the future queue.
	Future,
	/// Transaction is part of the ready queue.
	Ready,
	/// The transaction has been broadcast to the given peers.
	Broadcast(Vec<String>),
	/// Transaction has been included in block with given hash.
	InBlock(BlockHash),
	/// The block this transaction was included in has been retracted.
	Retracted(BlockHash),
	/// Maximum number of finality watchers has been reached,
	/// old watchers are being removed.
	FinalityTimeout(BlockHash),
	/// Transaction has been finalized by a finality-gadget, e.g GRANDPA
	Finalized(BlockHash),
	/// Transaction has been replaced in the pool, by another transaction
	/// that provides the same tags. (e.g. same (sender, nonce)).
	Usurped(Hash),
	/// Transaction has been dropped from the pool because of the limit.
	Dropped,
	/// Transaction is no longer valid in the current state.
	Invalid,
}
```

---

### Bonus: A Page In History

> https://github.com/paritytech/substrate/issues/728

> Work towards a flexible transaction queue that relies **only on runtime logic to provide comprehensive dependency and queuing management**... should not be aware of the concepts of accounts, signatures, indexes or nonces.

> Returns `Valid` if the transaction can be **statically** validated; ... the u64 is the priority used to determine which of a mutually exclusive set of transactions are better to include... Any transactions that do get included in a block should be instantly discarded (and banned) if they result in a panic execution.
