---
title: Substrate Wasm meta-protocol
description: A deeper dive into how the Wasm is meta-protocol functions in substrate.
duration: 60 minutes
---

# Substrate Wasm Meta Protocol

---

# Part 1

- This is a big lecture, so I divided it into two small parts, that's all 🫵🏻

---

## It All Began With a Runtime..

- The Client / Runtime division is one of the most important design decisions in Substrate.
  - 👿 Bad: Fixed opinion.
  - 😇 Good: Enables countless other things to **not be fixed**.

note:

Recall that the boundary for this division is the **state transition**

---v

### It All Began With a Runtime..

- Personal opinion:

> Substrate technology stack will put "Wasm stored onchain" on the map,<br/>
> the same way Ethereum put "smart contracts stored onchain" on the map.

note:


> It is only a matter of time until every blockchain is doing the same thing.

---v

## It All Began With a Runtime..

<img rounded style="width: 1200px;" src="../../assets/img/4-Substrate/dev-4-3-substrate-wasm.png" />

---

## Substrate: a short recap

<img style="width: 1200px;" src="../../assets/img/4-Substrate/dev-4-3-full-comm.svg" />

---v

### Substrate: a short recap

- **Host Functions**: Means of a runtime communicating with its host environment, i.e. the Substrate client.

---v

### Substrate: a short recap

- **Runtime API**: The well-defined functions that a Wasm substrate runtime is providing.

Notes:

Building a WASM module's activity was building something akin to runtime-apis

---v

### Substrate: a short recap

- Database is a _untyped_, _opaque_, **key-value** storage, stored **per-block**, on the **client side**.

---v

### Substrate: a short recap

- Communication language of client/runtime is SCALE:

```rust
let bytes: Vec<u8> = 42u128.encode();
let magic: u128 = vec![1, 2, 3, 4, 5, 6, 7, 8].decode();
```

---

## Learning with Examples

and some pseudo-code..

note:

During each example, we deduce what host functions and/or runtime APIs are needed.

---

## Example #1: State

- The runtime wants to add 10 units to Kian's balance.

---v

### Example #1: State

```rust [1-100|1-2|4,5|7,8|10,11|13,14|1-100]
// the runtime decides what key stores kian's balance.
key: Vec<u8> = b"kian_balance".to_vec();

// the runtime reads the raw bytes form that key.
let current_kian_balance_raw: Vec<u8> = host_functions::get(key);

// and needs to know to which type it should be decoded, u128.
let mut current_kian_balance: u128 = current_kian_balance_raw.decode();

// actual logic.
current_kian_balance += 10;

// encode this again into an opaque byte-array.
let new_balance_encoded: Vec<u8> = current_kian_balance.encode();

// write the encoded bytes again.
host_functions::set(key, new_balance_encoded);
```

---v

### Example #1: State

- 💡 The runtime needs host functions to read/write to state.

```rust
fn get(key: Vec<u8>) -> Vec<u8>;
fn set(key: Vec<u8>, value: Vec<u8>);
```

note:

ofc the IO to these functions is all opaque bytes, because the client does not know the state
layout.

---v

### Example #1: State

- could we have communicated with the client like this?

```rust
fn set_balance(who: AccountId, amount: u128)
```

note:

This would imply that the client would have to know, indefinitely, the types needed for account id
and balance. Also, it would have to know the final key for someone's balance.

---v

### Example #1: State

- Exceptions:

```rust
/// The keys known to the client.
mod well_known_keys {
  const CODE: &[u8] = b":code";
}
```

note:

See https://paritytech.github.io/substrate/master/sp_storage/well_known_keys/index.html

---v

### Example #1: State

<img style="width: 1000px;" src="../../assets/img/4-Substrate/dev-4-1-state-opaqueu.svg" />

---

## Example #2: Block Import

---v

### Example #2: Block Import

- Client's view of the state -> Opaque.
- Client's view of the transactions? 🤔
<!-- .element: class="fragment" -->

Notes:

Short answer is: anything that is part of the STF definition must be opaque to the client, and is
upgradeable, but we will learn this later.

---v

### Example #2: Block Import

- Transactions format is by definition part of the state transition function as well.
- What about header, and other fields in a typical block?

Notes:

as in, do we want to able to update our transactions format as well in a forkless manner?
we want the runtime to be able to change its transactions format as well, in a forkless manner.

The answer to the latter is more involved. The short answer is that these fields like header must be
known and established between client and runtime. If you want to alter the header format, that's a
hard fork.

The concept of `digest` is a means through which additional data can be put in the header without
breaking changes, but that is outside the scope of this lecture.

Yet, as with other primitives, substrate allows you to readily change your header type when you are
building your blockchain. This is achieved by a set of traits in `sp-runtime`. Notably, `trait
Block` and `trait Header` in this crate define what it means to be a header and block, and as long
as you fulfill that, you are good to go.

Also, substrate provides one set of implementation for all of these types in
https://paritytech.github.io/substrate/master/sp_runtime/generic/index.html

---v



<img style="width: 1200px;" src="../../assets/img/4-Substrate/dev-4-3-block-opaqueu.svg" />


---v

### Example #2: Block Import

<pba-cols>

<pba-col>

```rust
struct ClientBlock {
  header: Header,
  extrinsics: Vec<Vec<u8>>
}
```

</pba-col>

<pba-col>

```rust
struct RuntimeBlock {
  header: Header,
  extrinsics: Vec<KnownExtrinsic>
}
```

</pba-col>

</pba-cols>




---v

### Example #2: Block Import

```rust [1-100|1-2|4-6|8-9|1-100]
// fetch the block from the outer world.
let opaque_block: ClientBlock = networking::import_queue::next_block();

// initialize a wasm runtime.
let code = database::get(well_known_keys::CODE);
let runtime = wasm::Executor::new(code);

// call into this runtime.
runtime.execute_block(opaque_block);
```

---v

### Example #2: Block Import

- 💡 The client needs a runtime API to ask the runtime to execute the block.

```rust
fn execute_block(opaque_block: ClientBlock) -> Result<_, _> { .. }
```

note:

`execute_block` is the most basic, fundamental runtime API that any substrate based runtime has to
implement in order to be called a "blockchain runtime".

---

## Detour: Extrinsic

- Previous slides used the term "transactions" in a simplified way. Let's correct it.


---v

### Detour: Extrinsic

<diagram class="mermaid" center>
  %%{init: {'theme': 'dark', 'themeVariables': { 'darkMode': true }}}%%
  flowchart TD
    E(Extrinsic) --> S(Signed);
    S --> SE(Signed Extrinsic aka Transaction)
    E --> U(Unsigned)
    U --> UE(Unsigned Extrinsic)
    U --> I(Inherent)
</diagram>

note:

- An Extrinsic is data that come from outside of the runtime.
- Yes, transactions are **a type of extrinsic**, but not all extrinsics are transactions.

---

### Example #2: Block Import

- But something's ambiguous about this code... 🤨

```rust
// 🤔
let code = database::get(well_known_keys::CODE);

// 🤔
runtime.execute_block(opaque_block);
```

Notes:

- From which block's state do we fetch the code??
- This probably calls into `host_functions::{get/set}` internally. What do we return

---v

### Example #2: Block Import

```rust [1-100|1-2|4-6|8-10|12-15|17-100]
// fetch the block from the outer world.
let block: ClientBlock = networking::import_queue::next_block();

// get the parent block's state.
let parent = block.header.parent_hash;
let mut state = database::state_at(parent);

// initialize a wasm runtime FROM THE PARENT `state`!
let code = state::get(well_known_keys::CODE);
let runtime = wasm::Executor::new(code);

// call into this runtime, updates `state`.
state.execute(|| {
  runtime.execute_block(block);
});

// create the state of the next_block
database::store_state(block.header.hash, state)
```

Notes:

- Question: why is `state` defined as `mut`?
- within these snippets, more or less, everything inside `state.execute` is executed within Wasm.

---v

### Example #2: Block Import

- A state key is only meaningful at a given block.
- A :code is only meaningful at at given block.
<!-- .element: class="fragment" -->
- 💡 A runtime (API) is only meaningful when executed at a give block.
<!-- .element: class="fragment" -->

note:

- The same way that Alice's balance value is only meaningful when read at a given block.

- Based on that:

  - The correct runtime code is loaded.
  - The correct state (and other host functions) is provided.

- Similarly, almost all RPC operations that interact with the runtime have an `Option<Hash>`
  argument. This specifies "at which block to load the runtime and state from".

---v

### Example #2: Block Import

- I can add one more small touch to this to make it more accurate.. 🤌

---v

### Example #2: Block Import

```rust [14-20]
// fetch the block from the outer world.
let block: ClientBlock = networking::import_queue::next_block();

// get the parent hash. Note that `sp_runtime::traits::Header` provides this.
let parent = block.header.parent_hash;
let mut state = database::state_at(parent);

// initialize a wasm runtime FROM THE PARENT `state`!
let code = state::get(well_known_keys::CODE);
let runtime = wasm::Executor::new(code);

// call into this runtime, update `state`.
state.execute(|| {
  // within this, we probably call into `host_functions::set` a lot.
  runtime.execute_block(block);

  let new_state_root = host_functions::state_root();
  let claimed_state_root = block.header.state_root;
  assert_eq!(new_state_root, claimed_state_root);
});

// create the state of the next_block
database::store_state(block.header.hash, state)
```

---v

### Example #2: Block Import: Recap

<img style="width: 1200px;" src="../../assets/img/4-Substrate/dev-4-3-import.svg" />

---

## Example #3: Block Authoring


<img style="width: 1200px;" src="../../assets/img/4-Substrate/dev-4-3-author-pool.svg" />
<div class="fragment current-visible" style="border: 1px solid red; width: 200px; height: 100px; position: fixed; left: 470px; bottom: 200px; background: #140526"></div>
<div class="fragment" style="border: 1px solid red; width: 200px; height: 75px; position: fixed; left: 470px; bottom: 200px; background: #140526"></div>
<div class="fragment" style="border: 1px solid red; width: 200px; height: 50px; position: fixed; left: 470px; bottom: 200px; background: #140526"></div>
<div class="fragment" style="border: 1px solid red; width: 200px; height: 25px; position: fixed; left: 470px; bottom: 200px; background: #140526"></div>



Notes:

1. gossip
2. tx-pool (validation also happens, but that can be a different lecture)
3. block-builder
4. construct the runtime executor based on the best known existing block.
5. runtime-api to apply transactions until full.
6. put correct state-root/extrinsic root hash in header
7. propagate back to everyone else.

---v

### Example #3: Block Authoring

```rust [1-100|1-2|4-5|7-9|11-12|14-20|21-100]
// get the best-block, based on whatever consensus rule we have.
let (best_number, best_hash) = consensus::best_block();

// get the latest state.
let mut state = database::state_at(best_hash);

// initialize a wasm runtime.
let code = state::get(well_known_keys::CODE);
let runtime = wasm::Executor::new(code);

// get an empty client block.
let mut block: ClientBlock = Default::default();

// repeatedly apply transactions.
while let Some(next_ext) = transaction_pool_iter::next() {
  state.execute(|| {
    runtime.apply_extrinsic(next_ext);
  });
  block.extrinsics.push(next_ext);
}

// set the new state root.
block.header.state_root = state.root();
```

Notes:

- What is the type of `next_ext`? `Vec<u8>`
- Do we actually loop forever until the tx-pool is empty? probably not!

---v

### Example #3: Block Authoring

- Substrate based runtimes are allowed to perform some operations at the beginning and end of each block.

> And recall that a smart contract could not do this.

---v

### Example #3: Block Authoring

```rust [11-100|14-15,25-26]
// get the best-block, based on whatever consensus rule we have.
let (best_number, best_hash) = consensus::best_block();

// get the latest state.
let mut state = database::state_at(best_hash);

// initialize a wasm runtime.
let code = state::get(well_known_keys::CODE);
let runtime = wasm::Executor::new(code);

// get an empty client block.
let mut block: ClientBlock = Default::default();

// tell this runtime that you wish to start a new block.
runtime.initialize_block();

// repeatedly apply transactions.
while let Some(next_ext) = transaction_pool_iter::next() {
  state.execute(|| {
    runtime.apply_extrinsic(next_ext);
  });
  block.extrinsics.push(next_ext);
}

// tell the runtime that we are done.
runtime.finalize_block();

// set the new state root.
block.header.state_root = state.root();
```

---v

### Example #3: Block Authoring

```rust
fn initialize_block(..) { ... }
// note the opaque extrinsic type.
fn apply_extrinsic(extrinsic: Vec<u8>) { ... }
fn finalize_block(..) { ... }
```

---

## Recap of Interactions Learned:

- State Update
- Block Import
- Block Authoring

- A few items that you have not learned about, but worth a moment of explanation:
  - Transaction Pool Validation
  - Version Check
  - Offchain Workers

---

## BUT WAIT A MINUTE 😱

- if the `code` changes, all the following can also change:

  - What state key is Kian's balance.
  - What block/extrinsic format is valid.

- How on earth is an application (i.e. a wallet) is supposed to survive?

---v

### BUT WAIT A MINUTE 😱

- Metadata 🎉

```rust
fn metadata() -> Vec<u8> { ... }
```

- `-> Vec<u8>`

Notes:

- Metadata contains all the basic information to know about all storage items, all extrinsics, and so
  on. It will also help a client/app decode them into the right type.
- Substrate itself doesn't impose what the metadata should be. It is `Vec<u8>`.
- FRAME based runtime expose a certain format, which is extensively adopted in the ecosystem.

Some personal rant: radical upgrade-ability is the biggest advantage, and arguably one of the main
develop-ability problems of the substrate ecosystem. Writing clients, such as block explorers,
scanners, and even exchange integration are orders of magnitude harder than a blockchain that has a
fixed format and only changes every 18 months at most. That being said, this is a battle that is to
me obvious: we simply HAVE to win. When ethereum first introduced smart contracts, everyone
probably had the same class of issues. This is the same matter, on a a different level.

also, as noted in an earlier slide, once you make it work for one chain, it works for many chains.

---v

### BUT WAIT A MINUTE 😱

- Recall the fact that runtime is only meaningful at a certain block".

<div class="fragment">

- Two different runtimes at block `N` and `N+1` return different metadata ✅.

</div>

Notes:

By Applications/Clients I really mean anyone/anything. Substrate client doesn't really use metadata
because it is dynamically typed, but if needed, it could.

---

## Oblivious Client 🙈🙉

- The underlying reason why the client is "**kept in the dark**" is so that it wouldn't need to care about the runtime upgrading from one block to the other.

---v

## Oblivious Client 🙈🙉

$$STF = F(block_{N}, state_{N}) > state_{N+1}$$

*Anything that is part of the STF is opaque to the client, but it can change forklessly!*


- The `F` itself (your Wasm blob)? It can change!
<!-- .element: class="fragment" -->
- Extrinsic format? It can change!
<!-- .element: class="fragment" -->
- State format? It can change!
<!-- .element: class="fragment" -->



Notes:

In essence, all components of the STF must be opaque to the client. `Vec<u8>`.
Metadata is there to assist where needed.
This is why forkless upgrades are possible in substrate.

---

## Substrate: The Full Picture

<img style="width: 1200px;" src="../../assets/img/4-Substrate/dev-4-3-full.svg" />

note:

time to ask any missing questions.

---

## Activity: Haunting APIs and Host Functions

---v

### Runtime APIs: The Full List

- look for `impl_runtime_apis! {...}` and `decl_runtime_apis! {...}` macro calls.
  - Try and find the corresponding the client code calling a given api as well.
- Look for `#[runtime_interface]` macro.
- You have 30 minutes!

---v

### Runtime APIs: The Full List

- Runtime APIs
  - **Core**, **TxQueue**, **BlockBuilder**, **OffchainWorker**, **Metadata**.
  - Sky's the limit! A runtime can expose any more functions through APIs.

---v

### Runtime APIs: The Full List

- A blockchain node is more or less anything that implements the `Core` API.
- A blockchain validators implements `BlockBuilder` and `TxQueue` as well.
- A lot of other runtime APIs _could_ be optional depending on the context.

---

# Part 2

---

## Defining a Runtime API

```rust [1-7|9-15|17-100|1-100]
// somewhere in common between client/runtime => substrate-primitive.
decl_runtime_apis! {
	pub trait Core {
		fn version() -> RuntimeVersion;
		fn execute_block(block: Block) -> bool;
	}
}

// somewhere in the runtime code.
impl_runtime_apis! {
  impl sp_api::Core<Block> for Runtime {
    fn version() -> RuntimeVersion { /* stuff */ }
    fn execute_block(block: Block) -> bool { /* stuff */ }
  }
}

// somewhere in the client code..
let block_hash = "0xffff...";
let block = Block { ... };
let outcome: Vec<u8> = api.execute_block(block, block_hash).unwrap();
```

notes:

- All runtime APIs are generic over a `<Block>` by default.
- All runtime APIs are executed on top of a **specific block**. This is the implicit _at_ parameter.
- Going over the API, everything is SCALE encoded both ways, but abstractions like
  `impl_runtime_apis` hide that away from you.

---

## Defining a Host Function

```rust
// somewhere in substrate primitives, almost always `sp_io`.
#[runtime_interface]
pub trait Storage {
  fn get(&self, key: &[u8]) -> Option<Vec<u8>> {...}
  fn get(&self, key: &[u8], value: &[u8]) -> Option<Vec<u8>> {...}
  fn root() -> Vec<u8> {...}
}

#[runtime_interface]
pub trait Hashing {
	fn blake2_128(data: &[u8]) -> [u8; 16] {
		sp_core::hashing::blake2_128(data)
	}
}

// somewhere in substrate runtime
let hashed_value = sp_io::storage::get(b"key")
  .and_then(sp_io::hashing::blake2_128)
  .unwrap();
```

---

## Considerations

---

## Considerations: Speed

- (new) Wasmtime is near-native 🏎️.
- (old) `wasmi` is significantly slower 🐢.

note:

slower wasmi was one of the reasons to have native execution.
there are talks of exploring Risk-v ISA instead of wasm nowadays.

https://github.com/paritytech/substrate/issues/13640

---v

### Considerations: Speed

<pba-cols>
<pba-col center>

- Host is generally **faster** and **more capable**, but it has a one-time cost of getting there,
  and copying the data.

</pba-col>
<pba-col center>

<img style="width: 700px;" src="../../assets/img/4-Substrate/dev-4-3-io.svg" />

</pba-col>
</pba-cols>

Notes:

We do hashing and crypto operations as host functions. Why? This is actually questionable. AFAIK
Smoldot does both in wasm and it is doing just fine.

- Going over the runtime boundary is analogous to your CPU needing to go to memory.

On the other hand things as `next_storage` are high cost (generally iteration on state from runtime
is expensive). This design is related to the memory location, there is alternative but this is
simple (simple as good design).

- Question: we got host function for running computation intensive code in native, but when simd for
  wasm would be added, then will host function for a hashing be still useful:
  A: wait and see, but is possible that simd optimization of the hash function in wasm is way faster.

Again using a host function for speed up needs to be reasoned, cost of transmitting parameter in
wasm can be bigger than the actual hashing cost.

---

### Consideration: Native Runtime

<img style="width: 1200px;" src="../../assets/img/4-Substrate/dev-4-3-native.svg" />

---v

### Consideration: Native Runtime

- Remember the `fn version()` in `Core` API!

```rust [1-100|4-5]
/// Runtime version.
#[sp_version::runtime_version]
pub const VERSION: RuntimeVersion = RuntimeVersion {
	spec_name: create_runtime_str!("node"),
	spec_version: 268,
	impl_name: create_runtime_str!("substrate-node"),
	impl_version: 0,
	authoring_version: 10,
	apis: RUNTIME_API_VERSIONS,
	transaction_version: 2,
	state_version: 1,
};
```

---v

### Consideration: Native Runtime

- Native is only an option if spec versions match!

```rust
fn execute_native_else_wasm() {
  let native_version = runtime::native::api::version();
  let wasm_version = runtime::wasm::api::version();

  // if spec name and version match.
  if native_version == wasm_version {
    runtime::native::execute();
  } else {
    runtime::wasm::execute();
  }
}
```

---v

### Consideration: Native Runtime

- The days of native runtime are numbered 💀.
- Question: what happens if you upgrade your runtime, but forget to bump the spec version?

Notes:

If everyone is executing wasm, technically nothing, but that's super confusing, don't do it.
But, if some are executing native, then you will have a consensus error.

---v

## Speaking of Versions..

- Make sure you understand the difference! 👍
  - Client Version
  - Runtime Version

---v

### Speaking of Versions..

<img style="width: 1200px;" src="../../assets/img/4-Substrate/dev-4-3-telemetry.png" />

---v

### Speaking of Versions..

<img style="width: 1200px;" src="../../assets/img/4-Substrate/dev-4-3-PJS.png" />

---v

### Speaking of Versions..

- What happens when Parity release a new `parity-polkadot` client binary?
- What happens when the Polkadot fellowship wants to update the runtime?

---

## Considerations: Panic

- What if any of the runtime calls, like `execute_block` or `apply_extrinsic` panics 😱?

Notes:

The rule of thumb is: A panic will cause the wasm execution environment to be immediately
terminated, and any state change is dropped aka. reverted.

While you might think the state revert is the good thing here, it is the main problem, and the main
reason you should not let a code-path that is accessible by arbitrary users to panic. Because, any
fees paid for the wasted execution of that runtime API call is also reverted.

In other words, a panic in the runtime typically allows everyone's time to be wasted, for free,
indefinitely. In other words, a DOS vector.

> A panic in `initialize_block` and `finalize_block` have even more catastrophic effects, which will
> be discussed further in the FRAME section.

workshop idea: make a panicing runtime, and DoS it out.
workshop idea for FRAME: find all instances where the runtime actually correctly panics (wrong timestamp, disabled validator)

---v

### Considerations: Panic

- Panic in a user-callable code path is _typically_ abusable 😠.
- Panic on "automatic" part of your blockchain like `initialize_block` are deadly 💀.

- Once you get to FRAME, you can find some examples where panics are expected.

---

### Consideration: Altering Host Function

- A runtime upgrade now requires a new `sp_io::new_stuff::foo()`. Can we do a normal runtime upgrade?

<div>

- Clients need to upgrade first. No more fully forkless upgrade 😢

</div>

<!-- .element: class="fragment" -->

---v

### Consideration: Breaking a Host Function

- Here's another example, from substrate:

```rust
// old
fn root(&mut self) -> Vec<u8> { .. }

// new
fn root(&mut self, version: StateVersion) -> Vec<u8> { .. }
```

<div>

- For some period of time, the client needs to support both..🤔

</div>

<!-- .element: class="fragment" -->

<div>

- When can the old host function be deleted?

</div>

<!-- .element: class="fragment" -->

---v

### Host Functions..

## NEED TO BE KEPT FOREVER 😈

<!-- .element: class="fragment" -->

- Optional activity: Go to the substrate repo, and find PRs that have altered host functions, and see the PR discussion. There are a few labels that help you find such PRs 😉.
<!-- .element: class="fragment" -->

---

## Workshop: Inspecting Wasm Code

- Compile the `node-template` in substrate.
- `wasm2wat polkadot_runtime.wasm > dump | rg import`
- `wasm2wat polkadot_runtime.wasm > dump | rg export`
- You have 15 minutes!

---

## Additional Resources! 😋

> Check speaker notes (click "s" 😉)

Notes:

- All Substrate PRs that have added new host functions: https://github.com/paritytech/substrate/issues?q=label%3AE4-newhostfunctions+is%3Aclosed

- All substrate PRs that have required the client to be update first: https://github.com/paritytech/substrate/issues?q=is%3Aclosed+label%3A%22E10-client-update-first+%F0%9F%91%80%22

- New metadata version, including types for the runtime API: https://github.com/paritytech/substrate/issues/12939

- Recent development on api versioning: https://github.com/paritytech/substrate/issues/13138

- In Substrate, a type needs to provide the environment in which host functions are provided, and
  can be executed.

> We call this an "externality environment", represented by `trait Externalities`.

```rust
SomeExternalities.execute_with(|| {
    let x = sp_io::storage::get(b"foo");
});
```

### Post Lecture Notes

- TODO: add a slide about XCM and XCQ being the community-led "standard" interface to write to and
  read from the underlying storage, without needing to make assumptions.

---

## Appendix

Content that is not covered, but is relevant.

### Consideration: Runtime API Versioning

- Same principle, but generally easier to deal with.
- Metadata is part of the runtime, known **per block**.
- Those written in a dynamically typed languages are usually fine 😎.

Notes:

Also, it is arguable to say that the runtime is the boss here. The client must serve the runtime
fully, but the runtime may or may not want to support certain APIs for certain applications.

Recall from another slide:

> - A lot of other runtime APIs _could_ be optional depending on the context.

---v

### Consideration: Runtime API Versioning

- The Rust code (which is **statically** typed) in substrate client does care if the change _is breaking_.
  - For example, input/output types change. Rust code cannot deal with that!

---v

### Consideration: Runtime API Versioning

```rust
sp_api::decl_runtime_apis! {
    // latest version
    fn foo() -> u32;

    // old version
    #[changed_in(4)]
    fn foo() -> u64;
}

let new_return_type = if api.version < 4 {
    // this weird function name is generated by decl_runtime_apis!
    let old_return_type = api.foo_before_version_4();
    // somehow convert it. don't care
    old_return_type.try_into().unwrap()
} else {
    api.foo()
}
```

---v

### Consideration: Runtime API Versioning

> Rule of thumb: Every time you change the signature of a host function / runtime API, i.e. change
> the input/output types, you need to think about this.

But what you have to do is dependent on the scenario.

### Activity: API Versioning

- Look into substrate and find all instances of `#[changed_in(_)]` macro to detect runtime api version.
- Then see if/how this is being used in the client code.

- Find all the `#[version]` macros in `sp-io` to find all the versioned host functions.

<hr>

- You have only 15 minutes!
