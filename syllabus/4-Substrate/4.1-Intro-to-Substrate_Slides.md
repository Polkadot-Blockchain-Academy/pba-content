---
title: Introduction to Substrate
description: Substrate Overview for Web3 engineers
duration: 45 minutes
---

# Introduction to Substrate

---

## What is Substrate?

Substrate is a **Rust framework** for **building blockchains** in a modular and extensible way.

---v

### Why Substrate?

- â›“ï¸ Future is multi-chain.

<img rounded width="1000px" src="../../assets/img/4-Substrate/dev-4.1-maximalism.png"></img>

---v

### Why Substrate?

- â›“ï¸ Future is multi-chain.
- ğŸ˜­ Building a blockchain is hard.
<!-- .element: class="fragment" -->
- ğŸ§  The need for a framework to build various blockchains is crucial for this future.
<!-- .element: class="fragment" -->

> In general you shouldn't try to build a blockchain yourself from scratch.
> You will probably get it wrong.

<!-- .element: class="fragment" -->

---v

### Core Philosophies of Substrate ğŸ’­

The **pre-substrate** way of thinking:

- Writing and coordination of upgrades in blockchains is hard.
- We are going to spend maximal resources at making sure we get it right the first time.

---v

### Core Philosophies of Substrate ğŸ’­

The **substrate** way of thinking:

- It all starts with a deep acknowledgment that **society and technology evolves**.
- _It is only a matter of time until the "right choice" of today turns into a mistake in the future._

---v

### Core Philosophies of Substrate ğŸ’­

Outcomes of this:

- Rust as a language
- Upgradeability through a WASM meta-protocol.
- Generic (build _APIs_, not _fixed implementations_).

---v

### Core Philosophies of Substrate: Rust as a language

- Memory safety is a fundamental issue in most major system-level programming languages.

<br>

- ğŸ˜­ `segfault`
- ğŸ˜‡ You **cannot** make certain mistakes in Rust.
- ğŸï¸ Most Rust abstractions are zero-cost.
  Rust has no "runtime".
  It as fast as a binary can be.

---v

### Core Philosophies of Substrate: Rust as a language

<img width="1400px" src="../../assets/img/4-Substrate/dev-4-1-speed.png"></img>

---v

### Core Philosophies of Substrate: Upgradeability

- ğŸ’ªğŸ» Substrate is HIGHLY upgradable.
- ğŸ•¸ï¸ Encoding the **application logic** of the chain as WASM, and storing it onchain, such that it can be upgraded on the fly.

---v

### Core Philosophies of Substrate: Generic

- Multiple consensus engines (BABE/Grandpa/AURA)
- Multiple network protocols (QUIC, TCP..)
- Multiple database implementations (ParityDB, RocksDB)
- Multiple ledger-state formats (UTXO, Account-based)

---v

### Core Philosophies of Substrate: Generic

- **AlephZero**: Custom consensus, DAG-based, 1s block time.
- **Moonbeam**: Ethereum compatible, build with substrate
- **HydraDX**: Custom transaction pool logic to match DEX orders.
- **Kulupu**: Proof of work.

---

### Substrate Architecture

<img src="../../assets/img/4-Substrate/dev-4-1-substrate.svg"></img>

---

## The Runtime

- The runtime contains all of the **business logic** of your chain.

...

- In a more _fancy_ term, the runtime is the **state transition function**.

...

- In a more _technical_ term, the definition of **how your blockchain executes blocks**.

...

> (WASM) Runtime ~ STF ~ Application Logic ~ Business Logic

---v

### State Transition

- **State:** The entire set of data that we want to come to consensus about.
- **Transition:** The runtime, the piece of logic that dictates how the state changes.

---v

### State Transition

<img style="width: 1200px;" src="../../assets/img/4-Substrate/dev-4-1-state.svg"></img>

---v

### Positive Consequences of _WASM_ Runtime ğŸ”¥

- ğŸ¤– deterministic execution
- ğŸ§± sandboxing (more relevant in Polkadot)
- ğŸŒˆ Easier client development, including light clients.
- ğŸ˜ forkless upgrade!

---v

### ğŸ¤– Deterministic Execution

- The need for determinism in a blockchain runtime is _absolute_.

---v

### ğŸ§± Sandboxing

- Substrate uses the same WASM machinery for executing:

1. Smart contracts
2. Parachain runtime (i.e. PVF)

---v

### ğŸŒˆ Easier Client Development

- A Substrate client written in a different language needs to ONLY implement the host/client side.
- Then, possibly ALL SUBSTRATE BASED CHAINS will get a new client.

- Same story for a dapp that you write.

---v

### ğŸ˜ Forkless Upgrade:

<img style="width: 1400px;" src="../../assets/img/4-Substrate/dev-4-1-forkless-1.svg" />

---v

### ğŸ˜ Forkless Upgrade:

<img style="width: 1400px;" src="../../assets/img/4-Substrate/dev-4-1-forkless-2.svg" />

---v

### Negative Consequences of _WASM_ Runtime ğŸ¥²

- ğŸ˜© Constrained resources
- ğŸ¤” Client diversification != state-transition diversification

---v

### What is WASM Anyways?

<img style="width: 1400px;" src="../../assets/img/4-Substrate/dev-4-1-wasm-langs.svg">

---v

### What is WASM Anyways?

<pba-cols>
<pba-col>

- WASM â¤ï¸ WEB
- Streaming and rapid compilation.
- Designed with the concept of host in mind.
  Sandboxed, permissioned sys-calls.

> People actually tried sticking things like JVM into the browser (_Java Applets_), but it didn't work.

</pba-col>
<pba-col>

<img style="height: 700px;" src="../../assets/img/4-Substrate/dev-4-1-wasm.svg">

</pba-col>
</pba-cols>

---v

### How to Write a WASM Runtime?

- Any language that can compile to WASM and exposes a fixed set of functions, to be used by the client.
- ... But, of course, Substrate comes with a framework to make this developer-friendly, **FRAMEâ„¢ï¸**.

---

## The Client

Everything else you need in a blockchain, except the consensus-critical, deterministic runtime we just spoke of.

---v

### The Client

- Compiled to native.
- Less need for determinism.
- Has access to anything a normal native binary does (memory, disk, syscalls etc.)
- Does all the other shared things that most blockchains want
  - Database, Networking, Mempool, Consensus..

---v

### The Client

<img style="width: 1400px;" src="../../assets/img/4-Substrate/dev-4-3-full.svg">

---v

### The Client: Consensus ğŸ¤”

- Yes, consensus is not a core part of a blockchain runtime.
  It is not application logic.
  It is not something you want to customize.

- The consensus protocol is to your runtime what HTTP is to Facebook.

Notes:

comments from Joshy:

I think this is important.

The runtime is the application you want to run.
Consensus is outside of this application helping us agree what the official state of this runtime is.
Last wave I used this analogy.

Imagine a writers room for some TV show.
Writers are sitting around coming up with potential plot points for future episodes.
Any of their ideas could work.
But eventually they need to agree what the next episode to air actually will be.

---v

### The Client: Database ğŸ¤”

- The client is in charge of storing the data, but has **no meaningful way to interpret it**.
- The database, from the client's PoV, is a _untyped_, _opaque_, key-value storage.
- The runtime knows which key means what.

> A few exceptions exist, like `:code` being the key for the WASM blob.

---v

### The Client: Database ğŸ¤”

<pba-cols>

<pba-col center>

Because the runtime can change independently!

</pba-col>

<pba-col center>

<img style="width: 1000px" src="../../assets/img/4-Substrate/dev-4-1-state-opaqueu.svg">

</pba-col>

</pba-cols>

---v

### SMOLDOT: Compile the Client to WASM

<pba-cols>

<pba-col center>

A marvel of universe ğŸ¤¯.

- (light) Substrate\* client compiled to WASM, by the browser.
- Itself executing another WASM blob, the aforementioned runtime.

</pba-col>

<pba-col center>

<img style="width: 600px;" src="../../assets/img/4-Substrate/dev-4-1-smoldot.svg">

</pba-col>

</pba-cols>

---

## Communication Paths

<img style="width: 1400px" src="../../assets/img/4-Substrate/dev-4-1-comms.svg">

---v

### Communication Paths

<img style="width: 1400px" src="../../assets/img/4-Substrate/dev-4-1-comms-format.svg">

---v

### Example: SCALE vs JSON

- SCALE is an efficient, non-descriptive, binary encoding format, used EXTENSIVELY in the Substrate ecosystem.

---v

### Example: SCALE vs JSON

```rust
use parity_scale_codec::{Encode};

#[derive(Encode)]
struct Example {
	number: u8,
	is_cool: bool,
	optional: Option<u32>,
}

fn main() {
	let my_struct = Example {
		number: 42,
		is_cool: true,
		optional: Some(69),
	};
	println!("{:?}", my_struct.encode());
	// [42, 1, 1, 69, 0, 0, 0]
	println!("{:?}", my_struct.encode().len());
	// 7
}
```

---v

### Example: SCALE vs JSON

```rust
use serde::{Serialize};

#[derive(Serialize)]
struct Example {
	number: u8,
	is_cool: bool,
	optional: Option<u32>,
}

fn main() {
	let my_struct = Example {
		number: 42,
		is_cool: true,
		optional: Some(69),
	};
	println!("{:?}", serde_json::to_string(&my_struct).unwrap());
	// "{\"number\":42,\"is_cool\":true,\"optional\":69}"
	println!("{:?}", serde_json::to_string(&my_struct).unwrap().len());
	// 42
}
```

---

### Substrate: The Gaming Console of Blockchains!

<pba-cols>
<pba-col center>

<img src="../../assets/img/4-Substrate/nintendo-console-2.png" style="width:400px;"/>

Substrate Client

</pba-col>
<pba-col center>

<img src="../../assets/img/4-Substrate/nintendo-game.png" style="width:400px;"/>

Substrate Runtime

</pba-col>
</pba-cols>

Notes:

https://www.cleanpng.com/png-game-boy-advance-deviantart-video-game-consoles-2183359/

---

### Substrate: VHDL and FPGA analogy.

---

## Substrate and Polkadot

<img style="width: 1400px;" src="../../assets/img/4-Substrate/dev-4-1-polkadot.svg">

---

## Substrate and Smart Contracts

<img style="width: 100px;" src="../../assets/img/4-Substrate/dev-4-1-ink.jpeg">

NOTE:

I was asked this yesterday as well. My latest answer is: if you don't need any of the customizations
that a blockchain client/runtime gives to you, and the performance of a shared platform is okay for
you, then go with a smart contract. If you need more, you need a "runtime" (some kind of chian,
parachain or solo)

An example of customization is that a runtime has access to `on_initialize` etc.

Also, a contract usually depends on a token for gas, while a runtime can be in principle token-less
fee-less.

---v

### Substrate and Smart Contracts

<img style="width: 1000px;" src="../../assets/img/4-Substrate/dev-4-1-contracts.svg">

---v

### Substrate and Smart Contracts

- So a SMOLDOT instance, syncing a substrate based chain which has pallet-contracts is ...ğŸ¤”

---v

### Substrate and Smart Contracts

<pba-cols>
<pba-col center>

<img style="width: 600px;" src="https://media.tenor.com/Oc4nf8N08jIAAAAM/mind-blow-galaxy.gif">

</pba-col>
<pba-col center>

- a WASM blob (smoldot)
- that executed a WASM blob (runtime)
- that executed a WASM blob (contract)

</pba-col>
</pba-cols>

---

## Technical Freedom vs Ease

<img style="width: 1000px;" src="../../assets/img/4-Substrate/dev-4-1-freedom.svg"/>

---

## Rest of This Module! ğŸ˜ˆ

<pba-cols>
<pba-col>

##### Lecture

- Day 0:
  - **Introduction**
  - Folder structure.
- Day 1:
  - **WASM Meta-Protocol**
  - SCALE, JSON-RPC
- Day 2:
  - **Storage**
  - Substrate CLI, TX-Pool

</pba-col>
<pba-col>

##### Activity

- Day 0:
  - Compiling Rust to WASM
- Day 1:
  - FRAME-less Activity
- Day 2:
  - FRAME-less Activity

</pba-col>
</pba-cols>
