---
title: Substrate Storage
duration: 30 mins
instructors: ["Kian Paimani"]
teaching-assistants: ["..."]
---

# Substrate Storage

---

## Substrate Storage: Key Value



<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-storage-1.svg"></img>

---v

### Substrate Storage: Key Value

* Recall that at the `sp_io` layer, you have keys and values.

* `sp_io::storage::get(b"key")`;
* `sp_io::storage::get(b"key", b"value")`;


> Database is a *untyped*, *opaque*, **key-value** storage, stored **per-block**.

---v

### Substrate Storage: Key Value

* In Substrate, a type needs to provide the environment in which host functions are provided, and
  can be executed.

> We call this an "externality environment", represented by `trait Externalities`.

By convention, an externality has a "**backend**" that is in charge of dealing with storage.


---v

### Substrate Storage: Key Value

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-storage-2.svg"></img>

---v

### Substrate Storage: Key Value

* How about a key-value storage externality? why not? ðŸ™ˆ

<br>

* O(1) Read and write.
* Hash all the data once to get a root.

---v

### Substrate Storage: Key Value

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-kv-backend.svg"></img>


---v

### Substrate Storage: Key Value

* If alice only has this root, how can I prove to her how much balance she has?

> Alice is representing a light client, I represent a full node.

THE WHOLE FUCKING DATABASE ðŸ˜±.

<!-- .element: class="fragment" -->

---

## Substrate Storage: Merklized

* This brings us again to why we like to "merkelize" things.
* We take the key, and make it be the path on a trie.
* Some nodes contain value, some nodes are just "connectors".
* Then we store the nodes of this tree in a database by hashing them.

---v

### Substrate Storage: Merklized

#### Walking Over a Trie Backed By a Key Value Database

- Let's assume we know the first root node.
- assume this is a radix-26, patricia trie. English alphabet is the key-scope.
- If we want to store the same data as we did with the kv-ext, this is how it would look like.

---v


<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-trie-backend-unhashed.svg"></img>

NOTE:

1. walk over the process of retrieving "balances_alice".

---v

### Substrate Storage: Merklized

* If alice only has this root, how can I prove to her how much balance she has?

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-trie-backend-proof.svg"></img>

---

## WAIT A FUCKING MINUTE... ðŸ¤”

* What if there is a node with a very large value along the path of a proof?

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-trie-backend-proof-fat.svg"></img>

* Can you now guess why the WASM code is stored under `:code`?

* Good thing no other hash starts with `:code` or something like that ðŸ˜…

<!-- .element: class="fragment" -->

---

## WAIT A FUCKING MINUTE... ðŸ¤”

* Also.. what if I only want to delete a node? should the whole data be in the proof?

TODO: Link to PR, state-version and all of that.

---

### Substrate Storage: *Real* Merklized

* The Trie-node format I showed was a massive simplification.
* Instead of alphabet, we use the base-16 representation of the hashes.

> Radix 16, Patricia Merkle Tree.

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-trie-backend-hashed.svg"></img>

TODO: Now's a good time to talk about an unbalanced tree.

TODO: State root is dependent on the trie format. This is why it is explained in
spec.polkadot.network. If a new client wants to sync a substrate-based chain, it needs to know the
trie format in order to come to the same state root hash

---

## Substrate Storage: The Updated Picture

<img style="width: 1000px;" src="../../../assets/img/4-Substrate/dev-storage-3.svg"></img>

---

## Substrate Storage: The Role of FRAME

* All FRAME does is hashing keys, really. No seriously, that's almost all it does.

<img style="width: 1000px;" src="../../../assets/img/4-Substrate/dev-storage-4.svg"></img>

---

## WAIT A FUCKING MINUTE... ðŸ¤”


<div class="flex-container">

<div class="right">
<div><div style="height:0;padding-bottom:100%;position:relative;width:100%"><iframe allowfullscreen="" frameBorder="0" height="100%" src="https://giphy.com/embed/dkATeHzqzp74aROpcp/video" style="left:0;position:absolute;top:0" width="100%"></iframe></div></div>

</div>

<div class="left">

* Most of the time, the domain at which we care about storage is within one runtime API call...
* We rarely care about state root before the end of the block, when importing..

> A runtime-api-scoped cache for storage.
</div>

</div>



---

## Substrate Storage: Overlay

* Is a cache layer.
* It works **based on key-values**, **not trie-format**.
  * Once you read a value, it stays here, and can be re-read for cheap.
  * Once you write a value, it will only be written here.
    * It can be read for cheap.
  * All writes are flushed at the end of the runtime api call.


---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-overlay.svg"></img>

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-overlay-1.svg"></img>

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-overlay-2.svg"></img>

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-overlay-3.svg"></img>

---v

### Substrate Storage: Overlay


* Cheap != Free

```rust
let temp = sp_io::storage::get(b"bar");

// is a lot faster!
let cached = sp_io::storage::get(b"bar");
// but not as fast as this!
let in_memory = temp;
```

NOTE:

* A deletion is basically a write.

---v

### Substrate Storage: Overlay

* The overlay is also able to spawn child-overlays, know as "*storage layer*".
* Useful for having a *transactional* block of code.

```rust
// spawn a new layer.
with_storage_layer(|| {
    let foo = sp_io::storage::read(b"foo");
    sp_io::storage::set(b"bar", foo);

    if cond {
        Err("this will be reverted")
    } else {
        Ok("This will be commit to the top overlay")
    }
})
```

NOTE:

- implement with zero-copy. So, the size of values is not so important, it is more about the number.

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-overlay-nested.svg"></img>

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-overlay-nested-1.svg"></img>

---v

### Substrate Storage: Overlay

* There is a limit to how many tested layers you can spawn
* It is not free, thus it is attack-able.

```rust
with_storage_layer(|| {
    let foo = sp_io::storage::read(b"foo");
    with_storage_layer(|| {
        sp_io::storage::set(b"foo", b"foo");
        with_storage_layer(|| {
            sp_io::storage::set(b"bar", foo);
            with_storage_layer(|| {
                sp_io::storage::set(b"foo", "damn");
                Err("damn")
            })
            Ok("what")
        })
        Err("the")
    });
    Ok("hell")
})
```

---v

### Substrate Storage: Overlay

> What if I call `sp_io::storage::root()` in the middle of the block?

* Can the overlay respond to this?

NOTE:

NO! overlay works on the level on key-values, ot knows nothing of trie nodes, and to compute the root we have to go to the trie layer and pull a whole lot of data back from the disk and build all the nodes etc. etc.

---v

### Substrate Storage: Word on Caches

* There are more caches in the trie layer as well.
* I am too afraid to talk about them though.

---

### Substrate Storage: Final Figure

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-storage-full.svg"></img>

---v

### Substrate Storage

There are multiple implementations of `Externalities`:

* [`TestExternalities`](https://paritytech.github.io/substrate/master/sp_state_machine/struct.TestExternalities.html):
  * `Overlay`
  * `TrieDb` with `InMemoryBackend`
* [`Ext`](https://paritytech.github.io/substrate/master/sp_state_machine/struct.Ext.html) (the real thing ðŸ«¡)
  * `Overlay`
  * `TrieDb` with a real database being the backend

---v

### Substrate Storage

* Recall: Any code accessing host functions needs to wrapped in something that implements
  `Externalities`

```rust
SomeExternalities.execute_with(|| {
    let x = sp_io::storage::get(b"foo");
});
```

* The error message if you forget about this is amongst the most common in substrate:

```
thread '..' panicked at '`get_version_1` called outside of an Externalities-provided environment.'
```
