# SCALE Codec

Lecture 0, Module 4

Instructor: Shawn Tabrizi

<hr>

At the end of this lecture, you will learn why Substrate uses SCALE codec, how all different kinds of data types are encoded.

---

### SCALE

Simple Concatenated Aggregate Little-Endian

SCALE is a light-weight format which allows encoding (and decoding) which makes it highly suitable for resource-constrained execution environments like blockchain runtimes and low-power, low-memory devices.

---

### Why SCALE?

* Simple to define.
* Not Rust-specific (but happens to work great in Rust).
	* Easy to derive codec logic: `#[derive(Encode, Decode)]`
	* Viable and useful for APIs like: `MaxEncodedLen` and `TypeInfo`
	* It does not use Rust `std`, and thus can compile to Wasm `no_std`.
* Consensus critical / bijective; one value will always encode to one blob and that blob will only decode to that value.
* Supports a copy-free decode for basic types on LE architectures.
* It is about as thin and lightweight as can be.

---

### SCALE is NOT Self-Descriptive

It is important to note that the encoding context (knowledge of how the types and data structures look) needs to be known separately at both encoding and decoding ends.

The encoded data does not include this contextual information.

---

### Example: JSON vs SCALE

---

### Try It Yourself!

```bash
mkdir temp
cd temp
cargo init
cargo add parity-scale-codec --features derive
```

---

### Fixed Width Integers

Basic integers are encoded using a fixed-width little-endian (LE) format.

```rust
use parity_scale_codec::Encode;

fn main() {
	println!("{:02x?}", 69i8.encode());
	println!("{:02x?}", 42u16.encode());
	println!("{:02x?}", 16777215u32.encode());
}
```

```bash
[45]
[2a, 00]
[ff, ff, ff, 00]
```

---

### Compact Integers

A "compact" or general integer encoding is sufficient for encoding large integers (up to 2<sup>536</sup>) and is more efficient at encoding most values than the fixed-width version.

Though for single-byte values, the fixed-width integer is never worse.

---

### Compact Prefix

Compact/general integers are encoded with the two least significant bits denoting the mode:

- `0b00`: single-byte mode; upper six bits are the LE encoding of the value (valid only for values of `0` through `63`).
- `0b01`: two-byte mode: upper six bits and the following byte is the LE encoding of the value
	(valid only for values `64` through `(2^14 - 1)`).
- `0b10`: four-byte mode: upper six bits and the following three bytes are the LE encoding of the
	value (valid only for values `(2^14)` through `(2^30 - 1)`).
- `0b11`: Big-integer mode: The upper six bits are the number of bytes following, plus four. The
	value is contained, LE encoded, in the bytes following. The final (most significant) byte must be
	non-zero. Valid only for values `(2^30)` through `(2^536 - 1)`.

---

### Compact Integers: 0

```rust
use parity_scale_codec::{Encode, HasCompact};

#[derive(Encode)]
struct AsCompact<T: HasCompact>(#[codec(compact)] T);

fn main() {
	println!("{:02x?}", 0u8.encode());
	println!("{:02x?}", 0u32.encode());
	println!("{:02x?}", AsCompact(0u8).encode());
	println!("{:02x?}", AsCompact(0u32).encode());
}
```

```bash
[00]
[00, 00, 00, 00]
[00]
[00]
```

---

### Compact Integers: 42

```rust
use parity_scale_codec::{Encode, HasCompact};

#[derive(Encode)]
struct AsCompact<T: HasCompact>(#[codec(compact)] T);

fn main() {
	println!("{:02x?}", 42u8.encode());
	println!("{:02x?}", 42u32.encode());
	println!("{:02x?}", AsCompact(42u8).encode());
	println!("{:02x?}", AsCompact(42u32).encode());
}
```

```bash
[2a]
[2a, 00, 00, 00]
[a8]
[a8]
```

---

### Compact Integers: 69

```rust
use parity_scale_codec::{Encode, HasCompact};

#[derive(Encode)]
struct AsCompact<T: HasCompact>(#[codec(compact)] T);

fn main() {
	println!("{:02x?}", 69u8.encode());
	println!("{:02x?}", 69u32.encode());
	println!("{:02x?}", AsCompact(69u8).encode());
	println!("{:02x?}", AsCompact(69u32).encode());
}
```

```bash
[45]
[45, 00, 00, 00]
[15, 01]
[15, 01]
```

---

### Compact Integers: 65535 (u16::MAX)

```rust
use parity_scale_codec::{Encode, HasCompact};

#[derive(Encode)]
struct AsCompact<T: HasCompact>(#[codec(compact)] T);

fn main() {
	println!("{:02x?}", 65535u16.encode());
	println!("{:02x?}", 65535u32.encode());
	println!("{:02x?}", AsCompact(65535u16).encode());
	println!("{:02x?}", AsCompact(65535u32).encode());
}
```

```bash
[ff, ff]
[ff, ff, 00, 00]
[fe, ff, 03, 00]
[fe, ff, 03, 00]
```

---

### Compact Integers Are "Backwards Compatible"

As you can see, you are able to "upgrade" a type without affecting the encoding.

---

### Unit, Bool, Option, and Result

```rust
use parity_scale_codec::Encode;

fn main() {
	println!("{:02x?}", ().encode());
	println!("{:02x?}", true.encode());
	println!("{:02x?}", false.encode());
	println!("{:02x?}", Ok::<u32, ()>(42u32).encode());
	println!("{:02x?}", Err::<u32, ()>(()).encode());
	println!("{:02x?}", Some(42u32).encode());
	println!("{:02x?}", None::<u32>.encode());
}
```

```bash
[]
[01]
[00]
[00, 2a, 00, 00, 00]
[01]
[01, 2a, 00, 00, 00]
[00]
```

---

### Arrays, Vectors, Strings

* Arrays: Just concatenate the items.
* Vectors: Also prefix with length (compact encoded).
* String: Just `Vec<u8>` as utf-8 characters.

```rust
use parity_scale_codec::Encode;

fn main() {
	println!("{:02x?}", [0u8, 1u8, 2u8, 3u8, 4u8].encode());
	println!("{:02x?}", vec![0u8, 1u8, 2u8, 3u8, 4u8].encode());
	println!("{:02x?}", "hello".encode());
}
```

```bash
[00, 01, 02, 03, 04]
[14, 00, 01, 02, 03, 04]
[14, 68, 65, 6c, 6c, 6f]
```

---

### Tuple and Struct

Just encode and concatenate the items.

```rust
use parity_scale_codec::Encode;

#[derive(Encode)]
struct Example {
	number: u8,
	is_cool: bool,
	optional: Option<u32>,
}

fn main() {
	let my_struct = Example {
		number: 0,
		is_cool: true,
		optional: Some(69),
	};
	println!("{:02x?}", (0u8, true, Some(69u32)).encode());
	println!("{:02x?}", my_struct.encode());
}
```

```bash
[00, 01, 01, 45, 00, 00, 00]
[00, 01, 01, 45, 00, 00, 00]
```

---

### Enum

Prefix with index (`u8`), then the value, if any.

```rust
use parity_scale_codec::Encode;

#[derive(Encode)]
enum Example {
    First,
    Second(u8),
    Third(Vec<u8>),
    Fourth,
}

fn main() {
    println!("{:02x?}", Example::First.encode());
    println!("{:02x?}", Example::Second(2).encode());
    println!("{:02x?}", Example::Third(vec![0, 1, 2, 3, 4]).encode());
    println!("{:02x?}", Example::Fourth.encode());
}
```

```bash
[00]
[01, 02]
[02, 14, 00, 01, 02, 03, 04]
[03]
```

---

### Metadata

---
