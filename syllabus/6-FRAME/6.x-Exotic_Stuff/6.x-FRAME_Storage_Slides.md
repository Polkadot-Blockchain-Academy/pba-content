---
title: FRAME Storage
description: Deep dive into FRAME Storage
duration: 1 hour
instructors: ["Shawn Tabrizi"]
---

# FRAME Storage

---

## FRAME Storage

In this presentation, we will go even deeper into the concepts of Substrate storage, and see what kind of storage primitives FRAME provides you with to make Pallet development easy.

---

<div class="flex-container">

<div class="left-small">
	<table class="storage-layer-table">
	<tr><td class="ends">Developer</td></tr>
	<tr><td style="background-color: pink;">Runtime Storage API</td></tr>
	<tr><td style="background-color: pink;">Storage Overlays</td></tr>
	<tr><td>Patricia-Merkle Trie</td></tr>
	<tr><td>Key-Value Database</td></tr>
	<tr><td class="ends">Computer</td></tr>
	</table>
</div>
<div class="right">

### Storage layers

As we have learned, there are four core layers to Substrate's storage system.

Today we will focus on the top two layers: Runtime Storage APIs and Storage Overlays, which FRAME uses to improve developer experience.

</div>
</div>

---

## Overlay Change Set


<br>
<div class="flex-container">
<div class="left-small">

- As you have learned, any changes which make its way to the overlay change set will be committed to the database at the end of the block.
- This means, once you have written to storage, you cannot really undo it.
- This lead to the principle of "verify first, write last".

</div>
<div class="right">

<table class="overlay-table">
<tr><td style="background-color: red;">Runtime Logic</td></tr>
<tr><td style="background-color: darkred;">Runtime Memory</td></tr>
</table>

<br>
<table class="overlay-table" style="background-color: green;">
<tr><td>Runtime Storage API</td></tr>
</table>

<br>
<table class="overlay-table">
<tr><td colspan=4>Overlay Change Set</td></tr>
<tr>
	<td style="color: lightgreen;">Alice: 15</td>
	<td style="color: lightgreen;">Bob: 15</td>
	<td>&nbsp;</td>
	<td>&nbsp;</td>
</tr>
</table>

<br>
<table class="overlay-table" style="background-color: blue;">
<tr><td>Memory / Database Interface</td></tr>
</table>

<br>
<table class="overlay-table">
<tr><td colspan=4>Database</td></tr>
<tr>
	<td>Alice: 10</td>
	<td>Bob: 20</td>
	<td>Cindy: 30</td>
	<td>Dave: 40</td>
</tr>
</table>

</div>

---

## Verify First, Write Last

This was the rule for all of FRAME development.

```rust
fn give_balance_to_bob(who: &[u8]) -> Result<(), ()> {
	sp_io::storage::set(who, &100u32.encode());
	if who != b"bob" {
		// Too late to return an error, change is already made.
		return Err(())
	}

	Ok(())
}

#[test]
fn verify_first_write_last() {
	sp_io::TestExternalities::new_empty().execute_with(|| {
		assert_err!(give_balance_to_bob(b"alice"), ());
		let balance = sp_io::storage::get(b"alice").unwrap();
		assert_eq!(balance, 100u32.encode());
	});
}
```

---

## Transactional Storage

<br>
<div class="flex-container">
<div class="left-small">

- We mentioned previously that we are able to spawn new transactional layers.
- This can help us isolate changes caused by certain logic from reaching storage if we don't want it.
- We also learned, that the impact of these transactional layers are not zero, but very small (.15% per layer, per storage item).

</div>
<div class="right text-small">

<table class="overlay-table">
<tr><td style="background-color: red;">Runtime Logic</td></tr>
<tr><td style="background-color: darkred;">Runtime Memory</td></tr>
</table>

<br>
<table class="overlay-table" style="background-color: green;">
<tr><td>Runtime Storage API</td></tr>
</table>

<br>
<table class="overlay-table">
<tr><td colspan=4>Transactional Layer</td></tr>
<tr>
	<td style="color: yellow;">Alice: 25</td>
	<td>&nbsp;</td>
	<td style="color: yellow;">Cindy: 20</td>
	<td>&nbsp;</td>
</tr>
</table>

<br>
<table class="overlay-table">
<tr><td colspan=4>Overlay Change Set</td></tr>
<tr>
	<td>Alice: 15</td>
	<td>&nbsp;</td>
	<td>Cindy: 30</td>
	<td>&nbsp;</td>
</tr>
</table>

<br>
<table class="overlay-table" style="background-color: blue;">
<tr><td>Memory / Database Interface</td></tr>
</table>

<br>
<table class="overlay-table">
<tr><td colspan=4>Database</td></tr>
<tr>
	<td>Alice: 15</td>
	<td>Bob: 15</td>
	<td>Cindy: 30</td>
	<td>Dave: 40</td>
</tr>
</table>

</div>

---

## Storage Layer by Default

As of very recently, we have introduced an additional transactional storage layer by default for all FRAME extrinsics.

So verify first, write last should not be needed anymore within the FRAME pallets... but be careful in general.

---

## Patricia Trie

<img style="height: 600px;" src="../../../assets/img/4-Substrate/patricia-trie.svg" />

---

## Storage Keys

<img src="../../../assets/img/4-Substrate/navigate-storage-2.svg" />

---

## FRAME Storage Keys

We follow a simple pattern:

```
hash(name) + hash(name2) + hash(name3) + hash(name4) ...
```

For example:

```
twox128(pallet_name) + twox128(storage_name) + ...
```

We will get into more details as we look at the specific storage primitives.

---

## Pallet Name

The pallet name comes from the `construct_runtime!`.

```rust
// Configure a mock runtime to test the pallet.
frame_support::construct_runtime!(
	pub enum Test where
		Block = Block,
		NodeBlock = Block,
		UncheckedExtrinsic = UncheckedExtrinsic,
	{
		System: frame_system::{Pallet, Call, Config, Storage, Event<T>},
		Example: pallet_template,
	}
);
```

This means that changing the name of your pallet here is a **BREAKING** change, since it will change your storage keys.

---

## FRAME Storage Primitives

* `StorageValue`
* `StorageMap`
* `CountedStorageMap`
* `StorageDoubleMap`
* `StorageNMap`

We will go over all of them, and many important and subtle details along the way.

---

## Storage Value

Place a single item into the runtime storage.

```rust
pub struct StorageValue<Prefix, Value, QueryKind = OptionQuery, OnEmpty = GetDefault>(_);
```

Storage Key:

```rust
Twox128(Prefix::pallet_prefix()) ++ Twox128(Prefix::STORAGE_PREFIX)
```

---

## Storage Value: Example

```rust
#[pallet::storage]
pub type Item1<T> = StorageValue<_, u32>;
```

```rust
#[test]
fn storage_value() {
	sp_io::TestExternalities::new_empty().execute_with(|| {
		assert_eq!(Item1::<T>::get(), None);
		Item1::<T>::put(10u32);
		assert_eq!(Item1::<T>::get(), Some(10u32));
	});
}
```

---

## Storage Value Key

```rust
use sp_core::hexdisplay::HexDisplay;
println!("{}", HexDisplay::from(&Item1::<T>::hashed_key()));
```

This will depend on your pallet's name of course...

```bash
e375d60f814d02157aaaa18f3639a254c64445c290236a18189385ed9853fb1e
```

```bash
e375d60f814d02157aaaa18f3639a254 + c64445c290236a18189385ed9853fb1e
```

```bash
twox128("Example") = e375d60f814d02157aaaa18f3639a254
twox128("Item1") = c64445c290236a18189385ed9853fb1e
```



---

## All Storage is an Option

* At the Runtime Storage API level, a storage key will either have a value or not have a value.
* If there is no value, any query from the backend will be `None`.
* If there is a value, the query will be `Some(value)`.
* However, we can also hide this with a `Default` value.

---

## Query If Storage Actually Exists

There are APIs which expose to you whether the value actually exists in the database.

```rust
#[pallet::storage]
pub type Item1<T> = StorageValue<_, u32>;
```

```rust
#[test]
fn storage_value() {
	sp_io::TestExternalities::new_empty().execute_with(|| {
		// Nothing is actually there yet.
		assert_eq!(Item1::<T>::exists(), false);
		assert_eq!(Item1::<T>::try_get().ok(), None);
	});
}
```

---

## Query Kind

* `OptionQuery`: Default choice, represents the actual DB state.
* `ValueQuery`: Return a value when `None`. (`Default` or configurable)

```rust
#[pallet::storage]
pub type Item2<T> = StorageValue<_, u32, ValueQuery>;
```

```rust
#[test]
fn value_query() {
	sp_io::TestExternalities::new_empty().execute_with(|| {
		// `0u32` is the default value of `u32`
		assert_eq!(Item2::<T>::get(), 0u32);
		Item2::<T>::put(10u32);
		assert_eq!(Item2::<T>::get(), 10u32);
	});
}
```

Remember that 0 is not actually in storage when doing the first query.

---

## On Empty

You can control the `OnEmpty` value with:

```rust
#[pallet::type_value]
pub fn MyDefault<T: Config>() -> u32 { 42u32 }

#[pallet::storage]
pub type Item3<T> = StorageValue<_, u32, ValueQuery, MyDefault<T>>;
```

```rust
#[test]
fn my_default() {
	sp_io::TestExternalities::new_empty().execute_with(|| {
		// `42u32` is the configured `OnEmpty` value.
		assert_eq!(Item3::<T>::get(), 42u32);
		Item3::<T>::put(10u32);
		assert_eq!(Item3::<T>::get(), 10u32);
	});
}
```

Remember that 42 is not actually in storage when doing the first query.

---

## Not Magic

These "extra features" are just ways to simplify your code.

You can get the same effect without any magic:

```rust
let value = Item1::<T>::try_get().unwrap_or(42u32);
```

But you wouldn't want to do this every time.

---

## Set vs Put

* `pub fn set(val: QueryKind::Query)`
* `pub fn put<Arg: EncodeLike<Value>>(val: Arg)`

For Example:

```rust
#[pallet::storage]
pub type Item1<T> = StorageValue<_, u32>;
```

```rust
Item1::<T>::set(Some(42u32));
Item1::<T>::put(42u32);
```

---

## Don't Put The Option AS the Storage Value

This is basically an anti-pattern, and it doesn't really make sense to do.

```rust
#[pallet::storage]
pub type Item4<T> = StorageValue<_, Option<u32>>;

#[pallet::storage]
pub type Item5<T> = StorageValue<_, Option<u32>, ValueQuery>;
```

```rust
#[test]
fn nonsense() {
	sp_io::TestExternalities::new_empty().execute_with(|| {
		assert_eq!(Item4::<T>::exists(), false);
		assert_eq!(Item5::<T>::exists(), false);
		Item4::<T>::put(None::<u32>);
		Item5::<T>::put(None::<u32>);
		assert_eq!(Item4::<T>::exists(), true);
		assert_eq!(Item5::<T>::exists(), true);
	});
}
```

---

## Unit Type Instead of Bool

You might want to simply signify some true or false value in storage...

Save some bytes! Use the unit type.

```rust
#[pallet::storage]
pub type Item6<T> = StorageValue<_, ()>;
```

```rust
#[test]
fn better_bool() {
	sp_io::TestExternalities::new_empty().execute_with(|| {
		// false case
		assert_eq!(Item6::<T>::exists(), false);
		Item6::<T>::put(());
		// true case
		assert_eq!(Item6::<T>::exists(), true);
	});
}
```

---

## Kill Storage

Remove the item from the database using `kill()` or `take()`.

```rust
#[pallet::type_value]
pub fn MyDefault<T: Config>() -> u32 { 42u32 }

#[pallet::storage]
pub type Item3<T> = StorageValue<_, u32, ValueQuery, MyDefault<T>>;
```

```rust
#[test]
fn kill() {
	sp_io::TestExternalities::new_empty().execute_with(|| {
		assert_eq!(Item3::<T>::get(), 42u32);
		Item3::<T>::put(10u32);
		assert_eq!(Item3::<T>::get(), 10u32);
		//Item3::<T>::kill();
		let old_value = Item3::<T>::take();
		assert_eq!(Item3::<T>::get(), 42u32);
		assert_eq!(old_value, 10u32);
	});
}
```

---

## Mutate

Execute a closure on a storage item.

```rust
#[test]
fn mutate() {
	sp_io::TestExternalities::new_empty().execute_with(|| {
		Item2::<T>::put(42u32);
		Item2::<T>::mutate(|x| {
			if *x % 2 == 0 {
				*x = *x / 2;
			}
		});
		assert_eq!(Item2::<T>::get(), 21);
	});
}
```

---

## Try Mutate

Execute a closure on a storage item, but only write if the closure returns `Ok`.

```rust
#[test]
fn try_mutate() {
	sp_io::TestExternalities::new_empty().execute_with(|| {
		Item2::<T>::put(42u32);
		assert_noop!(Item2::<T>::try_mutate(|x| -> Result<(), ()> {
			*x = *x / 2;
			if *x % 2 == 0 {
				Ok(())
			} else {
				Err(())
			}
		}), ());
		// Nothing written
		assert_eq!(Item2::<T>::get(), 42);
	});
}
```

---

## Assert Noop

You may have noticed we just used `assert_noop!` instead of `assert_err!`.

```rust
/// Evaluate an expression, assert it returns an expected `Err` value and that
/// runtime storage has not been mutated (i.e. expression is a no-operation).
///
/// Used as `assert_noop(expression_to_assert, expected_error_expression)`.
#[macro_export]
macro_rules! assert_noop {
	(
		$x:expr,
		$y:expr $(,)?
	) => {
		let h = $crate::storage_root($crate::StateVersion::V1);
		$crate::assert_err!($x, $y);
		assert_eq!(h, $crate::storage_root($crate::StateVersion::V1), "storage has been mutated");
	};
}
```

There is also `assert_storage_noop!` which does not care what is returned, just that storage is not changed.

---

## Vec Tricks

You can use `decode_len()` and `append()` to work with a `Vec` without decoding all the items.

```rust
#[pallet::storage]
#[pallet::unbounded]
pub type Item7<T> = StorageValue<_, Vec<u8>, ValueQuery>;
```

```rust
#[test]
fn vec_tricks() {
	sp_io::TestExternalities::new_empty().execute_with(|| {
		assert_eq!(Item7::<T>::decode_len(), None);
		Item7::<T>::put(vec![0u8]);
		assert_eq!(Item7::<T>::decode_len(), Some(1));
		Item7::<T>::append(1u8);
		Item7::<T>::append(2u8);
		assert_eq!(Item7::<T>::get(), vec![0u8, 1u8, 2u8]);
		assert_eq!(Item7::<T>::decode_len(), Some(3));
	});
}
```

---

## Bounded Storage

You may have noticed `#[pallet::unbounded]` on the storage item in the previous slide.

Remember that blockchains are limited by:

* Computation Time
* Memory Limits
* Storage Size / Proof Size

In general, every storage item in FRAME should be **bounded** in size.

We will talk about this more when we discuss benchmarking.

---

## Bounded Vector

We have bounded versions of unbounded items like `Vec`, `BTreeSet`, etc...

```rust
#[pallet::storage]
pub type Item8<T> = StorageValue<_, BoundedVec<u8, ConstU32<100>>, ValueQuery>;
```

A second `Get<u32>` type is used to give a maximum number of values.

```rust
#[test]
fn bounded_vec() {
	sp_io::TestExternalities::new_empty().execute_with(|| {
		for i in 0u8..100u8 {
			assert_ok!(Item8::<T>::try_append(i));
		}
		// Only supports at most 100 items.
		assert_noop!(Item8::<T>::try_append(100), ());
	});
}
```

---
