# Outer Enum

---

## Outer Enum

In this presentation, you will learn about a common pattern used throughout FRAME, which abstracts many separate types into a single unified type that is used by the Runtime.

---

## Enums in FRAME

There are 3 main Enums which you will encounter throughout your FRAME development:

* The Call Enum
* The Event Enum
* The Error Enum

All of these enums have some representation within individual pallets, but also the final FRAME runtime you develop.

---

## Breaking It Down

```rust [0|10-30|32-52|54-80|82-97|99|102-107|109-114|116-140]
#![allow(non_camel_case_types)]
#![allow(dead_code)]

use parity_scale_codec::Encode;

pub type AccountId = u16;
pub type Balance = u32;
pub type Hash = [u8; 32];

mod balances {
    use crate::*;

    #[derive(Encode)]
    pub enum Call {
        transfer { from: AccountId, to: AccountId, amount: Balance },
        transfer_all { to: AccountId },
    }

    #[derive(Encode)]
    pub enum Error {
        InsufficientBalance,
        ExistentialDeposit,
        KeepAlive,
    }

    #[derive(Encode)]
    pub enum Event {
        Transfer { from: AccountId, to: AccountId, amount: Balance },
    }
}

mod democracy {
    use crate::*;

    #[derive(Encode)]
    pub enum Call {
        propose { proposal_hash: Hash },
        vote { proposal_id: u32, aye: bool },
    }

    #[derive(Encode)]
    pub enum Error {
        DuplicateProposal,
    }

    #[derive(Encode)]
    pub enum Event {
        Proposed { proposal_index: Hash },
        Passed { proposal_index: Hash },
        NotPassed { proposal_index: Hash },
    }
}

mod staking {
    use crate::*;

    #[derive(Encode)]
    pub enum Call {
        unstake,
        stake { nominate: Vec<AccountId>, amount: Balance },
    }

    #[derive(Encode)]
    pub enum Error {
        TooManyTargets,
        EmptyTargets,
        AlreadyBonded,
    }

    impl Into<DispatchError> for Error {
        fn into(self) -> DispatchError {
            DispatchError::Module(
                ModuleError {
                    pallet: runtime::Runtime::Staking as u8,
                    error: self as u8,
                }
            )
        }
    }
}

// Similar to `sp-runtime`
mod runtime_primitives {
    use crate::*;

    #[derive(Encode)]
    pub struct ModuleError {
        pub pallet: u8,
        pub error: u8,
    }

    #[derive(Encode)]
    pub enum DispatchError {
        BadOrigin,
        Module(ModuleError),
    }
}

mod runtime {
    use crate::*;

    #[derive(Encode)]
    pub enum Runtime {
        Balances = 0,
        Democracy = 1,
        Staking = 2,
    }

    #[derive(Encode)]
    pub enum Call {
        BalancesCall(balances::Call),
        DemocracyCall(democracy::Call),
        StakingCall(staking::Call),
    }

    #[derive(Encode)]
    pub enum Event {
        BalancesEvent(balances::Event),
        DemocracyEvent(democracy::Event),
        // No staking events... not even in the enum.
    }

    // Imagine this for all of the possible types above...
    impl Into<Event> for balances::Event {
        fn into(self) -> Event {
            Event::BalancesEvent(self)
        }
    }

    // Imagine this for all of the possible types above...
    impl TryFrom<Event> for balances::Event {
        type Error = ();

        fn try_from(outer: Event) -> Result<Self, ()> {
            match outer {
                Event::BalancesEvent(event) => Ok(event),
                _ => Err(())
            }
        }
    }
}

use runtime_primitives::*;

fn main() {
	let runtime_call = runtime::Call::StakingCall(staking::Call::stake { nominate: vec![13], amount: 42 });
	let runtime_error: DispatchError = staking::Error::AlreadyBonded.into();
	let runtime_event: runtime::Event = balances::Event::Transfer { from: 1, to: 2, amount: 3 }.into();
	println!("{:?}", runtime_call.encode());
	println!("{:?}", runtime_error.encode());
	println!("{:?}", runtime_event.encode());
}
```

---

## Outer Enum Encoding
