# Events and Errors

---

## Events and Errors

In this presentation, we will go over two of the tools you have access to when developing FRAME Pallets to express how your runtime calls are executing.

---

## Errors

Not all extrinsics are valid. It could be for a number of reasons:

* The extrinsic itself is badly formatted. (wrong parameters, encoding, etc...)
* The call does

---

## Dispatch Result

All pallet calls return at the end a `DispatchResult`.

From: `substrate/frame/support/src/dispatch.rs`

```rust
pub type DispatchResult = Result<(), sp_runtime::DispatchError>;
```

So a function can either return `Ok(())` or some `DispatchError`.

---

## Dispatch Error

From: `substrate/primitives/runtime/src/lib.rs`

```rust [0|6-10|13-14|15-16]
/// Reason why a dispatch call failed.
#[derive(Eq, Clone, Copy, Encode, Decode, Debug, TypeInfo, PartialEq)]
#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
pub enum DispatchError {
	/// Some error occurred.
	Other(
		#[codec(skip)]
		#[cfg_attr(feature = "std", serde(skip_deserializing))]
		&'static str,
	),
	/// Failed to lookup some data.
	CannotLookup,
	/// A bad origin.
	BadOrigin,
	/// A custom error in a module.
	Module(ModuleError),
	/// At least one consumer is remaining so the account cannot be destroyed.
	ConsumerRemaining,
	/// There are no providers so the account cannot be created.
	NoProviders,
	/// There are too many consumers so the account cannot be created.
	TooManyConsumers,
	/// An error to do with tokens.
	Token(TokenError),
	/// An arithmetic error.
	Arithmetic(ArithmeticError),
	/// The number of transactional layers has been reached, or we are not in a transactional
	/// layer.
	Transactional(TransactionalError),
}
```

---

## Module Errors

From: `substrate/primitives/runtime/src/lib.rs`

```rust
/// The number of bytes of the module-specific `error` field defined in [`ModuleError`].
/// In FRAME, this is the maximum encoded size of a pallet error type.
pub const MAX_MODULE_ERROR_ENCODED_SIZE: usize = 4;

/// Reason why a pallet call failed.
#[derive(Eq, Clone, Copy, Encode, Decode, Debug, TypeInfo)]
#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
pub struct ModuleError {
	/// Module index, matching the metadata module index.
	pub index: u8,
	/// Module specific error value.
	pub error: [u8; MAX_MODULE_ERROR_ENCODED_SIZE],
	/// Optional error message.
	#[codec(skip)]
	#[cfg_attr(feature = "std", serde(skip_deserializing))]
	pub message: Option<&'static str>,
}
```

So an error is at most just 5 bytes.

---

## Declaring Errors

```rust
// Errors inform users that something went wrong.
#[pallet::error]
pub enum Error<T> {
	/// There is currently no owner set.
	NoOwner,
	/// The calling user is not authorized to make this call.
	NotAuthorized,
}

#[pallet::call]
impl<T: Config> Pallet<T> {
	/// This function allows the current owner to set a new owner.
	/// If there is no owner, this function will return an error.
	#[pallet::weight(0)]
	pub fn change_ownership(origin: OriginFor<T>, new: T::AccountId) -> DispatchResult {
		let who = ensure_signed(origin)?;
		let current_owner = CurrentOwner::<T>::get().ok_or(Error::<T>::NoOwner)?;
		ensure!(current_owner == who, Error::<T>::NotAuthorized);
		CurrentOwner::<T>::put(new);
		Ok(())
	}
}

#[pallet::storage]
pub type CurrentOwner<T: Config> = StorageValue<_, T::AccountId>;
```

---

## Using Errors

When writing tests, you can use errors to make sure that your functions execute exactly as expected.

```rust
#[test]
fn errors_example() {
	new_test_ext().execute_with(|| {
		assert_noop!(TemplateModule::change_ownership(Origin::signed(1), 2), Error::<T>::NoOwner);
		CurrentOwner::<T>::put(1);
		assert_ok!(TemplateModule::change_ownership(Origin::signed(1), 2));
		assert_noop!(TemplateModule::change_ownership(Origin::signed(1), 2), Error::<T>::NotAuthorized);
	});
}
```

---

## Encoding Errors

All errors ultimately become a `DispatchError`, which is the final type returned by the runtime.

```rust
println!("{:?}", Error::<T>::NoOwner.encode());
println!("{:?}", Error::<T>::NotAuthorized.encode());
let dispatch_error1: DispatchError = Error::<T>::NoOwner.into();
let dispatch_error2: DispatchError = Error::<T>::NotAuthorized.into();
println!("{:?}", dispatch_error1.encode());
println!("{:?}", dispatch_error2.encode());
```

```bash
[0]
[1]
[3, 1, 0, 0, 0, 0]
[3, 1, 1, 0, 0, 0]
```

---

## Dispatch Error Encoding

<table>
<tr>
	<td>3</td>
	<td>1</td>
	<td>1</td>
	<td>0</td>
	<td>0</td>
	<td>0</td>
</tr>
<tr>
	<td>DispatchError::Module</td>
	<td>Pallet #2</td>
	<td>Error #2</td>
	<td>(unused)</td>
	<td>(unused)</td>
	<td>(unused)</td>
</tr>
</table>

Encoding based on configuration:

<div class="flex-container">
<div class="left" style="max-width: 700px;">

```rust
// Configure a mock runtime to test the pallet.
frame_support::construct_runtime!(
	pub struct Test where
		Block = Block,
		NodeBlock = Block,
		UncheckedExtrinsic = UncheckedExtrinsic,
	{
		System: frame_system::{Pallet, Call, Config, Storage, Event<T>},
		TemplateModule: pallet_template,
	}
);
```

</div>
<div class="right" style="margin-left: 10px; max-width: 700px;">

```rust
// Errors inform users that something went wrong.
#[pallet::error]
pub enum Error<T> {
	/// There is currently no owner set.
	NoOwner,
	/// The calling user is not authorized to make this call.
	NotAuthorized,
}
```

</div>
</div>
---

## Nested Errors
