---
title: pallet-contracts # Also update the h1 header on the first slide to the same name
description: Describe your slides here
duration: 1 hour
instructors: ["some one", "another gal"]
teaching-assistants: ["some one", "another gal"]
revealOptions:
    transition: "slide"
---

# `pallet-contracts`

## _Module 6, Lecture 5.2_

---

<div class="flex-container">
<div class="left text-right"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

<!-- TODO: add a good circularly cropped headshot of ou to the `assets/profile` folder  -->
<img style="width: 550px; float:right; margin-right:30px" src="../../../assets/img/0-Shared/profile.png"/>

</div>
<div style="margin-top:130px" class="right text-left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->

### Alexander Thei√üen

<!-- .element: style="margin-bottom: -30px;" -->

#### _Core Developer @ Parity Technologies_

<!-- .element: style="margin-left: 20px;" -->

- With Parity since early 2020
- Leads the smart contract execution team
- Works on pallet-contracts

[Github](https://github.com/athei) // [LinkedIn](https://www.linkedin.com/in/athei/)

</div>
</div>

---

### Outline

<!--
You can reference slides within this presentation like [this other slide](#at-the-end-of-this-lecture-you-will-be-able-to) by use of the header title.

Please make your lecture precise.

- Limit the main points in a lecture to five or fewer.
- Create effective visuals, analogies, demonstrations, and examples to reinforce the main points.
  {TAs and the Parity design team can assist! Please let us know marking an item here as `TODO`}
- Emphasize your objectives and key points in the beginning, as you get to them, and as a summary at the end.

-->

1. [Pre-requisites](#pre-requisites)
1. [Architecture of pallet-contracts](#architecture-of-pallet-contracts)
1. [Contract Execution]()
1. [Exercise: Your first contract]()
1. [Fixing Storage Bloat]()
1. [Contracts on parachains]()
1. [Conclusion](#conclusion)
1. [Next Steps](#next-steps)
1. [References](#references)

---v

## Pre-requisites

No background in WebAssembly is necessary. However, the following are expected:

- General idea how blockchain and consensus works
- How a substrate runtime and pallets work
- Knowledge of what a virtual machine is
- Familiarity with the concept of weight
- Knowledge of how smart contracts work on ethereum

---v

### _At the end of this lecture, you will be able to:_

- Describe ...
- Navigate ...
- Justify ...

Notes:

- We have learned why smart contracts are useful and why we want to have them in out blockchain.
- In order to offer this functionality we need to have a piece of software in our runtime that executes them
- Substrate includes `pallet-contracts` which executes WebAssembly (wasm) based smart contracts
- WebAssebmly smart contracts only refer to the bytecode used to express the contracts
- There are a lot of different ways you could implement a wasm based smart contract platform
- `pallet-contracts` is one opiniated way of doing this. It stays purposefully close to the EVM way
    of doing this (synchronous cross contract calls) while differentiating itself in some key areas.
  - We will learn about this in the next chapter
  
---

## WebAssembly

Notes:

- In order to understand how WebAssembly (abbreviated Wasm) contracts are constructed we just
  need to understand the general concept. No detailed knowledge is required.
- WebAssembly is a virtual machine standard originally intended for web.
- However, because of its generality it can be used in other domains.

---v

### Embedding Wasm

TODO: Illustration of an embedder including a wasm file

Notes:

- WebAssembly is meant to be embedded by other applications as a way to express logic in a platform
  independend way. The application including the WasmVM is called the "embedder". A programming
  language that is often used in a similar way is LUA. This is often called "scripting".
- The embedder here is our blockchain's runtime which wants to execute some logic defined in
  a platform independed way (contracts).
- Another popular embedder is a web browser.
- The embedder defines which functions can be called by the Wasm code and which functions it
  expects to be present in the Wasm code.

---v

### Minimal example

```Rust
pub fn factorial(n: u64) -> u64 {
  if n == 0 {
    1
  } else {
    n * factorial(n - 1)
  }
}
```

```WebAssembly
(func (param i64) (result i64)
  (if (result i64) (i64.eqz (local.get 0))
    (then
      (i64.const 1)
    )
    (else
      (i64.mul
        (local.get 0)
        (call 0 (i64.sub (local.get 0) (i32.const 1)))
      )
    )
  ) 
)
```

Notes:

- This format is called 'wat' and is essentially a wasm assembler.
  - It is compiled to a binary format like any asm would be compiled to machine code.
  - Instead of pushing things to the stack line by line we can group them with parenthesis
    to the consuming instruction. This is just syntax sugar removed by the assembler.
- The instruction set includes what you would expect from a instruction set:
  - Arithmetic operations
  - Stack manipulation
  - Memory manipulation
  - Control flow operations
  - It uses structured control flow similar to high level programming lanuages as oposed to
  jumps.
- Entities within a Wasm code file (Wasm module) are enumrated by their appearence (starting with 0).
  - Calling the first defined function is accomplished via `call 0` for example
  - Parameters of functions are variables and are ordered before any variables of the function themself.
  - `local.get 0` fetches the first parameter of a function

---v

### Linear Memory

```Rust
pub fn write_to_mem(val: u64, address: &mut u64) {
    *address = val;
}
```

```WebAssembly
(func (param i64)
  (i64.store (local.get 1) (local.get(0))
)
```

Notes:

- In addition to the stack Wasm also has linear memory. This is byte addressable and can be manipulated
  using `x.store` and `x.load` which stored and loads primitives from and to the stack. Instructions
  never operate directly on linear memory.
  - The target address is taken from the stack and can be adjusted by passing an offset as immediate.
- The Rust compiler uses for dynamic/heap memory and to pass non primitives to functions by emulating
  an additional stack within the linear memory it allocates at some offset.
  - This emulated stack is what we would understand as stack in other architectures.
  - The Wasm stack would be implemented using registers in other architectures

---v

### Anatomy of a Contract

```WebAssembly
(module
  ;; params: data_ptr, data_len_ptr
  (import "seal0" "seal_input" (func $seal_input (param i32 i32)))
  (import "env" "memory" (memory 1 1))

  (func (export "deploy")
    ;; execute some code on contract deployment (we do nothing)
  )

  (func (export "call")
    ;; execute some code on contract execution
    (i32.store (i32.store 4) (i32.const 256)) ;; store the length of our buffer at mem[4]
    (call $seal_input (i32.const 0) (i32.const 4)) ;; copy input buffer to mem[0]
  )
)
```

Notes:

- The standard does not only include the binary instruction set but also the way the code is
bundled for consumption.
- This bundle is called a Wasm module and is what an ELF file is to classical instruction sets
- Each embedder provides the environment. The most important properties of this environment are:
  - List of functions ("imported functions") which can be called by the Wasm blob to interact with
  the environment (e.G `seal_return`). The identifier of an import consists of a `module` and a `name`.
  Those don't have any meaning and can be chosen by the embedder completely arbitrarily. While
  any byte sequence can be used it is customary to make them human readable (ASCII). The `module`
  is usually used for namespacing.
  - List of entry points ("exported functions") the the embedder expects to be present in the Wasm
  module. The embedder would call these functions at pre-defined points in time. For example,
  `pallet-contracts` expects two functions to be present: `deploy` and `call`.
  - Input and output is passed through linear memory.
- `pallet-contracts` acts as such an embedder and hence contracts are defined in terms of a Wasm
module according to the environment defined by `pallet-contracts`.
- `seal_input` is used to copy the input buffer to local memory where it can be further processed.
  - Second argument is an in-out pointer which is used to pass in the buffer length and pass out
    the actual size of the input.
  - Execution ends with an error if the specified buffer can't fit the whole input.
  - Every function offered by pallet-contracts that the contract wants to use needs to be
    explicitly imported.

---

## Exercise: Your first contract

- Mentioned wasm2wat <-> wat2wasm tooling
- Write a very basic contract in wat
- Provide skelleton: Users write code to read input, do addition and write to storage

### _Describe it here_

<!-- TODO: exercise indicator https://github.com/paritytech/polkadot-blockchain-academy/issues/67 -->

---v

### Exercise instructions

<!--
Detail what you want students to do in your exercise
Most exercises are less than 15 minuets in length.
-->

1.
1.
1.

Notes:
Make sure to include things here to say to students, perhaps a hint or two.
Realize that students will be able to view the speaker's notes, as they will have access to them on their devices.

<!-- TODO: exercise indicator https://github.com/paritytech/polkadot-blockchain-academy/issues/67 -->

---

## Architecture of pallet-contracts

---v

### Dispatchables

Notes:

- Dispatchables are functions exposed by pallets than can be referenced in an signed extrinsic
  in order execute some code on-chain. For normal pallets this is fixed functionality.
  For contracts however, we can trigger execution of previously stored (also using dispatchables)
  Wasm code.
- Once it is included into the runtime it makes the following dispatchables available for
  a extrinsics (the argument list is shortened):
  - `upload_code(code: Vec<u8>)`: We differentiate between "code" and contract". This uploads a Wasm module that can be referenced by its hash in other extrinsics. It will validate, instrument and finally store the code on-chain. With code we just mean a Wasm module while a contract is an account that has state attached to it that is governed by some previously uploaded code instead of a
    private key.
  - `instantiate(code_hash: CodeHash, input: Vec<u8>, salt: Vec<u8>)`: Creates a new contract using the specified
  `code_hash`. It's state is initialized by the `deploy` function defined in its code. By branching
  on the `input` different contract instances can be instantiated from the same code.
  The contracts account id is derived deterministically:
  `hash(instantiating_account ++ code_hash ++ salt)`. Without the salt instantiating the same code
  from the same account would be impossible.
  - `call(account: AccountId, input: Vec<u8>)`: Call an existing contract. This will execute the
  `call` function exported by the contracts code.

---v

### RPCs

Notes:

- RPCs are functions exposed by a node via network
- Some of them are general functions exposed by any node: (e.G `get_storage`)
- `pallet-contracts` adds additional RPC which are essentially mirrors of its dispatchables
  to allow clients (wallets, dapps) to dry-run any contract execution before submitting it
  as an extrinsic
- The main reason to do dry runs to estimate gas usage and to extract data from a contract
- For read-only contract executions a client would only call the RPC without submitting
  an extrinsic as those can't return any data
- RPCs do cannot mutate any state because they are only executed by one node as opposed to every
  node as in the case of an extrinsic submission

---v

### Configuration

- TODO: put codebox with config trait here

Notes:

- As for every pallet there is a `Config` trait that allows the runtime author to configure
pallet contracts to their use case.

---v

### API Definition

- TODO: Add codebox with `define_evn!` macro invocation here

Notes:

- The set of functions a contract can call (imported functions in Wasm lingo) are defined in
  `wasm/runtime.rs` within the `define_env!` macro invocation.
- The macro generates a list of imports from its arguments: The identifier in square brackets
  becomes the `module` and the name of the functions becomes the `name`.
- Only primitives (`i32`, `i64`) can be used as arguments. Larger types are passed by pointer and are
  serialized using SCALE.
- This list of function can be extended by the runtime by a mechanism called chain extension.
  - This is a type implementing `trait ChainExtension` passed in via the `Config` trait.
- `gas` is a special import that is only called injected code in order to meter executed instructions.

---v

### Gas (weight)

- TODO: put code box with `call` weight annotation

Notes:

- Just as on ethereum we make use of gas metering in order to make sure a contract execution
  terminates and fee the sender accordingly.
- We don't need to do that for the runtime itself because that code is trusted to not use more
  computation that that it promises to. We can't trust contract code to do so because that code
  can be uploaded by users as opposed to the author of the chain's runtime.
- The concept of gas is unified with weight. The word gas is sometimes used when talking about
  smart contracts but it can be used interchangeably with weight.
- As a reminder: One weight is one picosecond of execution time on whatever hardware was defined
  as the reference for the runtime in question.
- Just as for any other pallet there is a weight value assigned to each dispatchable. However,
  for most dispatchables we can't know the a-priori weight and therefore we need to resort to metering:
  The pre-dispatch weight is set to whatever is passed as the `gas_limit`. After the execution we learn
  the exact weight (post-dispatch weight) through metering and refund the difference.
- Metering works by assigning a weight value to each Wasm instruction and each imported function
  and then dynamically keep track of what is used.

---

## Interpreter vs Compiler

Notes:

- After covering the structure of a contract and the pallet we have a look at the part which
  actually runs the Wasm code. Wasm is a virtual machine so we need some software to execute
  it on out real world computer.
- We call this part the "execution engine" and is the part that implements the Wasm instruction
  set and actually runs the code.
- Please note that this is often referred to as "VM" but this can be misleading because that
  definition is blurry: Often it also includes embedder which would be the whole `pallet-contracts`.
- We use the term "execution engine" to make this distinction clear.

- Interpreters
  - They run through the code instruction by instruction and update their internal
    as they go.
  - Slow to execute code when compared to a JIT compiler
  - Easy to write and understand.
  - No time is spent on compilation which is important as the compilation would happen
    on chain and would there contribute to weight fees.
  - Can be compiled as `no_std` and included into the runtime making iteration possible
    with only a runtime upgrade.
- (JIT) compilers
  - Convert Wasm module to native architecture of the host and then run this emitted code.
  - Running the
  - Only single pass compilers can be used for contracts as optimizing compilers use non
    linear algorithms which would be prone to DoS attacks.
  - Single pass compilers produce way slower code than optimizing compilers.
  - Factoring in compilation time it is not obvious if they break even with interpreters for
    typical contract use cases.
  - Need to have support in the client (native part of a node) because it is inherently platform
    depended. This prevents making changes with only a runtime upgrade.

---v

### pallet-contracts uses wasmi for now

Notes:

- We use an interpreter for now as it allows us to stay flexible and iterate with only
  an runtime upgrade until it becomes clear whether a JIT brings a real word improvement.+
- We have experimental support for wasmer singlepass in Substrate but the performance
  measurement are inconclusive.
- The runtime itself uses wasmtime but we can't use this for contracts because it doesn't include
  a singlepass compiler.
- In the future we intent to switch to a JIT.

---v

### Making gas meter independent of the executor

- TODO: Add code box with full contract including gas metering

Notes:

- In order to make out gas metering independed of our choice of execution engine we don't
  require the engine to provide support for gas metering.
- Instead, we have an instrumentation step when uploading code that injects the metering
  logic as Wasm code. This way it works consistently across every Wasm conformant
  execution engine without any modification.
- It works by injecting a call to the `gas` imported function for stream of uninterruptible
  instructions (basic block). This functionality is implemented by the `wasm-instrument`
  crate.
- We work on a [more performant solution](https://github.com/paritytech/wasm-instrument/issues/11) that doesn't call any imported functions as those carry significant overhead.

---

## Fixing Storage Bloat

### Storage on Ethereum

- TODO: some numbers on Ethereum state size

Notes:

- EVM doesn't continiously charge for storage. There is a one time cost of creating storage
  that cannot be fully reclaimed.
- There isn't a big incentive to write contracts in a way that unused storage is reclaimed.
- As a consequence Ethereum struggles with a bloated chain state.

---v

### Storage rent

Notes:

- One way to deal with this situation is to charge rent from a contracts balance per block
and remove the contract's state from the chain when it isn't topped up. It can be
reactivated re-uploading the state.
- This leaves the contract in full control of its financing model because no assumptions
are made of wo pays for the storage: A contract could include logic to make users pays
for it or rely on some interested third party to keep it alive.
- However, it turned out that the logic required to implement this logic dominated
  the actual logic of the contract. Hence we switched to a more opiniated model.

---v

### Storage deposit

Notes:

- Opiniated model where we dictate what whoever sends a transaction needs to pay for the
  storage it creates.
- `pallet-contracts` automatically charges a deposit from the sender of a transaction if that
  transaction creates storage. In case that transaction removes storage the sender will get
  a refund. This incentivizes developers to write contracts in way that users are able
  to remove unused storage.
- This model is not as flexible as the rent model but it frees contract authors from dealing
  with the potential threat of their contracts getting purged of their storage.

---

## Contracts on parachains

Notes:

- When development of `pallet-contracts` started parachains didn't exist, yet. When they
  arrived they introduced it turned out to be challenging to support them on a parachain.

---v

### Parachains present a challenge

- TODO: illustration of stateless validation

Notes:

- Every parachain block is re-excuted by a set of relaychain validators as part of
  the validation. This is necessary to learn the side effects (storage changes) of that
  block. Those validators do not hold any storage of the parachain hence all the required
  storage items needed for a block need to be sent to those validators along the block that
  is to be validated. We call that the storage proof or witness.
- If a parachain contains `pallet-contracts` then those contract executions
  (`call` extrinsics within a parachain block) also need to be re-executed by some
  relaychain validators. Those call extrinsics need the contract's code in order to be executed.
  This means that for every unique contract referenced by a `call` extrinsic in a parachain block
  this code needs to be send to the validator. This happens for every block. Wasm contracts tend
  to be much larger (in the range of kilobytes) than the usual storage items. This can make bandwith
  a bottleneck for the throughput of transactions: Sending around contract code during validation.
- Solving this seems to be hard problem: No other blockchain has true sharding and smart contract.
- We made a lot of progress with shrinking the contract sizes that ink! produces but it is still
  an open question how to address this issue. In the following we look into some planned solutions:

---v

### Shrink contract sizes

Notes:

- Probably the most obvious solution: Reduce the code sizes that our in-house programmiung language
  (ink!) produces. We made some great progress but we are still actively working on this.
- The main contributor to contract size is doing storage management inside the contract. We had some
  complex storage types that are removed now. We rely on a simple mapping type for now.
  More storage functionality is build into `pallet-contracts` instead of the contracts itself
  to save logic inside the contracts.
- Another contributer to contract sizes are some properties of Rust:
  - Code monomorphization
  - Passing large types by value
- Those Rust issues are largely unaddressed by now but will be taken care of eventually:
  - We will integrate optimizations into LLVM that can help with fallout of monomorphization.
  - We will refactor the code to pass large types by reference and split large generic functions
    so that only a small generic part will be duplicated by monomorphization.

---v

### Code merkelization

Notes:

- Many contract calls only touch a small part of a contracts call (think getter functions). Right
  now we still need to send the whole code to the validator in this case.
- Code merkelization will store the contract's code as a merkle tree which will allow us to send
  only the parts of a contract that where actually used by a specific contract call.
- The idea is to split the Wasm module on the function boundary. This will push the responsiblity
  of creating useful blocks of code (i.e that minimize amount of sent code per `call`) to contract authors: It is in their interest to make their contract cheap to execute.
- It is a hard task but it expected massively increase throughput for getter heavy contract calls. It is still [in the planning phase](https://github.com/paritytech/substrate/issues/9431).

---

## Conclusion

<!-- Summarize what we just learned, and put it in the bigger picture of what the Academy and Web3 are all about. -->

---

## Next steps

<!--
Compile a list of:
- topics not covered here but students should consider learning about independently
- examples of the concepts covered in this lesson applied to a project, to case-study
- useful resources related to the lesson

- Reference other slides/materials by relative directory in this repo, like the [copy-paste slide templates](../../content-templates/slides/copy-paste-reveal-template-slides.md)
-->

1. <!-- TODO: fill this in  -->
1. <!-- TODO: fill this in  -->
1. <!-- TODO: fill this in  -->

---

## References

<!--
Compile an **annotated** list of URLs to source material referenced in making these lessons.
Ideally this is exhaustive, it can be cleaned up before delivery to students, but must include _why_ a reference is used.
For example:

- [ss58-registry](https://github.com/paritytech/ss58-registry) - A list of known SS58 account types as an enum, typically used by the Polkadot, Kusama or Substrate ecosystems.
- [wiki on parathreads](https://wiki.polkadot.network/docs/learn-parathreads) - A description of the parathread model.
-->
