## Substrate Primitives

A random collection of things that you should probably know about.

These are relevant for coding in FRAME.

---

### `trait Get`

A very basic, yet very substrate-idiomatic way to pass values through types.

Generally, we love playing we *types* in substrate.

```rust
pub trait Get<T> {
  fn get() -> T;
}

impl<T: Default> Get<T> for () {
  fn get() -> T {
    T::default()
	}
}
```

---v

### `trait Get`

```rust
parameter_types! {
  pub const Foo: u32 = 10;
}

// expands to:
pub struct Foo;
impl Get<u32> for Foo {
  fn get() -> u32 {
    10;
  }
}
```

This 10 could be coming from a `const` context, which means it is one less value stored in the
stack/memory, nonetheless it could be coming from anywhere.

---

### `bounded`

- `BoundedVec`, `BoundedSlice`, `BoundedBTreeMap`, `BoundedSlice`

```rust
#[cfg_attr(feature = "std", derive(Serialize), serde(transparent))]
#[derive(Encode)]
pub struct BoundedVec<T, S: Get<u32>>(
	pub(super) Vec<T>,
	#[cfg_attr(feature = "std", serde(skip_serializing))] PhantomData<S>,
);
```

---v

### `bounded`

Food for your thought.

```rust
#[cfg_attr(feature = "std", derive(Serialize))]
#[derive(Encode)]
pub struct BoundedVec<T>(
	pub(super) Vec<T>,
  u32
);
```

---

### `trait Convert`

```rust
pub trait Convert<A, B> {
	fn convert(a: A) -> B;
}

pub struct Identity;
impl<T> Convert<T, T> for Identity {
	fn convert(a: T) -> T {
		a
	}
}
```

---

### Example of `Get` and `Convert`

```rust
/// Some configuration for my module.
trait InputConfig {
  /// Something that gives you a `usize`.
  type MaximumSize: Get<usize>
  /// Something that is capable of coverting `u64` to `u32`.
  type ImpossibleConvertor: Convertor<u64, u32>;
}

struct Module<T: Config> {
  fn foo() {
    let outcome: u32 = T::ImpossibleConvertor::convert(u64::max_value());
  }
}
```

---

### `trait Block`, `Header`, `Extrinsic`


..and you should be well versed in reading such type aliases:

```rust
/// Extract the hashing type for a block.
pub type HashFor<B> = <<B as Block>::Header as Header>::Hashing;
/// Extract the number type for a block.
pub type NumberFor<B> = <<B as Block>::Header as Header>::Number;
```

or..

```rust
type BalanceOf<T, I> = <
  <T as Config<I>>::Currency
  as
  Currency<<T as frame_system::Config>::AccountId>
>::Balance;
```

---

## The `std` Feature Paradigm

```rust
#[cfg(feature = "std")]
#[macro_export]
macro_rules! if_std {
	( $( $code:tt )* ) => {
		$( $code )*
	}
}

#[cfg(not(feature = "std"))]
#[macro_export]
macro_rules! if_std {
	( $( $code:tt )* ) => {};
}
```

```rust
sp_std::prelude::*;
```

---

### Logging And Prints In The Runtime.

---

### Arithmetic Helpers, and the `f32`, `f64` Story.

Floating point numbers have different standards, and (***slightly***) different implementations on
different architectures and vendors.

> If my balance is `10.000000000000001` DOT on one validator and `10.000000000000000` DOT on another
> validator, game over for your consensus.


---v

### PerThing.

```python
> .2 + .2 + .2 == .6
> false
```

```
> a = 10
> b = 0.1
> c = 0.2
> a*(b+c) == a*b + a*c
> false
```

Google "weird float behavior" fro more entertainment around this.

---v

### PerThing.

- We store ratios and such in the runtime with "Fixed-Point" arithmetic types.

```rust
implement_per_thing!(
  Percent,
  100u8,
  u8,
  "_Percent_"
);
implement_per_thing!(
	PerU16,
	65535_u16,
	u16,
	"_Parts per 65535_",
);
implement_per_thing!(
	Permill,
	1_000_000u32,
	u32,
	"_Parts per Million_",
);
implement_per_thing!(
	Perbill,
	1_000_000_000u32,
	u32,
	"_Parts per Billion_",
);
implement_per_thing!(
	Perquintill,
	1_000_000_000_000_000_000u64,
	u64,
	"_Parts per Quintillion_",
);
```

---v

### PerThing.

```
let p = Perbill::from_part_parts(1_000_000_000u32 / 4);
let p = Perbill::from_percent(25);
let p = Perbill::from_rational(1, 4);

> p * 100u32;
> 25u32;
```

Some precision concerns exist, but that's a story for another day.

---v

### Fixed Point Numbers

`Per-thing` is great for representing `[0, 1]` range.

What if we need more?

```
100 ~ 1
200 ~ 2
300 ~ 3
350 ~ 3.5
```

---v

### Fixed Point Numbers

```rust
implement_fixed!(
	FixedI64,
	i64,
	1_000_000_000,
	"_Fixed Point 64 bits signed, range = [-9223372036.854775808, 9223372036.854775807]_",
);

implement_fixed!(
	FixedU64,
	u64,
	1_000_000_000,
	"_Fixed Point 64 bits unsigned, range = [0.000000000, 18446744073.709551615]_",
);

implement_fixed!(
	FixedI128,
	i128,
	1_000_000_000_000_000_000,
	"_Fixed Point 128 bits signed, range = \
		[-170141183460469231731.687303715884105728, 170141183460469231731.687303715884105727]_",
);

implement_fixed!(
	FixedU128,
	u128,
	1_000_000_000_000_000_000,
	"_Fixed Point 128 bits unsigned, range = \
		[0.000000000000000000, 340282366920938463463.374607431768211455]_",
);

```

---v

### Fallibility

**Conversions** are very much fallible operations. So is things like addition, multiplication,
division (all in `std::ops`, if keen on reading some rustdocs).

- Panic

`u32::MAX * u32::MAX / 2` (in debug builds)

`100 / 0`

- Overflow

`u32::MAX * u32::MAX / 2` (in release builds)

---v

### Fallibility

1. `Checked` -- recover

`if let Some(outcome) = a.checked_mul(b) { ... } else { ... }`

2. `Saturating` -- soft recovery

`let certain_output = a.saturating_mul(b);`

<hr>

There's also `wrapping_op` and `carrying_op` etc on all rust primitives, but not quite relevant.

https://doc.rust-lang.org/std/primitive.u32.html


---v

### Fallibility

Luckily, rust is already pretty strict here.

- `TryInto` / `TryFrom` / `From<u32>` / `Into`


```rust
/// T is u32 or larger.
struct Foo<T: From<u32>>

/// T is u32 or smaller
struct Foo<T: Into<u32>>

/// It can maybe be converted to u32
struct Foo<T: TryInto<u32>>

/// It can be converted into u32 at the cost of loss of accuracy.
/// This is a substrate trait.
struct Foo<T: UniqueSaturatedInto<u32>>

assert_eq!(u128::MAX.saturating_into::<u32>(), u32::MAX);
```

---

## Larger Types

- `U256`, `U512`: battle-tested since the ethereum days.
- substrate-fixed: community project. Supercharged `PerThing` and `Fixed`.
- `big_uint.rs` (unaudited)

```rust
pub struct BigUint {
	/// digits (limbs) of this number (sorted as msb -> lsb).
	pub(crate) digits: Vec<Single>,
}
```

---

### Bonus: More Pages in History Page of Substrate:

- Rust didn't have u128 until not too long ago! https://github.com/paritytech/substrate/pull/163/files
- `TryFrom`/`TryInto` are also not too old! https://github.com/paritytech/substrate/pull/163/files#r188938077
- https://github.com/paritytech/substrate/pull/2602


