---
title: Substrate Folder Structure
description:
duration:
instructors: ["Kian Paimani"]
teaching-assistants: ["..."]
---

# Substrate Folder Structure

<widget-speaker name="Kian Paimani" position="FRAME/Staking Engineer" image="../../../assets/img/0-Shared/people/kian.png" github="kianenigma" twitter="kianenigma"></widget-speaker>

---

## Substrate Folder Structure

* 2 things to know:

1. How to look at substrate from ***within***.
2. How to look at substrate from ***without***.

---

## Substrate Internally

Substrate is roughly composed of 3 parts:

* Client: `sc-*`
* Primitives: `sp-*`
* FRAME: `frame-*`, `pallet-*`

> Primitives is the glue between the other two.

---

## Substrate Externally

Looking at substrate from outside, it is usually:

1. Some code to glue together the client
  * CLI
  * RPC
  * Consensus
  * ..
  * All heavily using `sc-*` crates.
2. A Runtime
  * All heavily using `frame-*` and `sp-*` crates.

---v

### Substrate Externally

* `bin/node`
* `bin/node-template`
* low and behold, the entire `polkadot` repo

---

## Activity: WASM Execution

* Substrate supports two types of WASM execution.
* Find the right crate in substrate repo to find the executors, then look them up online.
* Argue which type of executor should be used for runtimes, and which for smart contracts.
* Roughly 20 minutes.

Notes:

We want students to discover WASMI and Wasmtime, and reserch their differences.

So the key difference here is that the compilation of the code is unsafe because you can attack an
optimizing compiler. You can input some code for compilation that just takes forever to compile
(compiler bombs). There is no difference on safety in the actual execution apart from interpreters
being more simple and hence less likely to have bugs.

So compilation can be safe. But only if you can do it in linear time. And that prevents most
optimizations which makes the produced code slow. And it is questionable and surely depend on the
contract in question whether the compilation time can be recuperated if you need to compile it every
time it is run. When we have fuel metering we could port the code generation of wasmtime to the
runtime and cache the produced native code on-chain. Cause with fuel metering we are immune against
compiler bombs.

Then we could have near native speed for contracts.

Of course we could port the code generation of a linear time compiler to the runtime and have the
same without fuel metering. However, there is none except wasmer. And they were acquired by NEAR. It
was always a shady project but now I don't want to rely on it at all. Everything except wasmtime is
a huge liability.

---

## Activity: Node Template

This is your de-facto "substrate starter pack". Clone it, and try and find all the main components
of it, based on the material you have learned so far.

> I can rephrase this exercise as: reading-alien-code challenge. You have not been taught most of this, but still try to find these items:

* Which set of functions the runtime is exposing?
* Which RPC endpoints does this node have?
* Which consensus algorithm(s) is it using?
* You have 30 minutes!


---

## Activity: Compiling Rust to WASM

---v

### Activity: Compiling Rust to WASM

> A target triple consists of three strings separated by a hyphen, with a possible fourth string at the end preceded by a hyphen.
>
> The first is the **architecture**, the second is the **"vendor"**, the third is the **OS type**, and the optional fourth is environment type.

* `wasm32-unknown-emscripten`: Legacy, provides some kind of `std`-like environment
* `wasm32-unknown-unknown`	✓	WebAssembly: Can compile anywhere, can run anywhere, no `std`
* `wasm32-wasi`	✓	WebAssembly with WASI

---v

### Activity: Compiling Rust to WASM

> for each step, you can use `wasmtime-cli` to execute, and `wasm-gc` to trim your WASM files. For each step, try both `wasm32-unknown-unknown` and `wasm32-wasi`.

* First, write a WASM module that multiplies a number by 2.
* Then, write a WASM module that that returns the current timestamp.


NOTE:

https://rust-lang.github.io/rfcs/0131-target-specification.html
