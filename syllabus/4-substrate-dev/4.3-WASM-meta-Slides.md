---
title: Substrate WASM meta-protocol
description: A deeper dive into how the WASM is meta-protocol functions in substrate.
duration: 60 minutes
instructors: ["Kian Paimani"]
teaching-assistants: [""]
---

# Substrate WASM meta-protocol: Part 1

<widget-speaker name="Kian Paimani" position="Core Dev" image="../../../assets/img/0-Shared/people/kian.png" github="kianenigma" twitter="kianenigma"></widget-speaker>

---

# Part 1: WASM Meta-Protocol

---

## It All Began With a Runtime..

The Client / Runtime division is one of the most important design decisions in Substrate.

In some sense, this lecture is a deeper dive into substrate's architecture.


---v

## It All Began With a Runtime..

Personal opinion:

> Substrate technology stack will put "WASM stored onchain" on the map, the same way Ethereum put "smart contracts stored onchain" on the map.

Bold claim follows:

> It is only a matter of time until every blockchain is doing the same thing, one way or
> another.

---

## Substrate: a short recap

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-full.svg" />


---v

## Substrate: a short recap

Definitions:

1. Host Functions
2. Runtime API

---

## Example #1: State

* Let's explore with an example. The runtime wants to add 10 units to Kian's balance.

---v

### Example #1: State

```rust[1-2|4,5|7,8|10,11|13,14]
// The runtime decides what key stored kian's balance.
key: Vec<u8> = b"kian_balance".to_vec();

// the runtime reads the raw bytes form that key..
let current_kian_balance_raw: Vec<u8> = host_functions::get(key);

// and needs to know to which type they should be decoded.
let mut current_kian_balance: u128 = current_kian_balance_raw.decode();

// actual logic.
current_kian_balance += 10;

// write the encoded bytes again.
host_functions::put(key, next_kian_balance.encode());
```

---v

### Example #1: State

* ðŸ’¡ The runtime needs a host function to read/write to state.

```rust
/// a hypothetical set of host functions.
trait HostFunctions {
  fn get(key: Vec<u8>) -> Vec<u8>;
  fn set(key: Vec<u8>, value: Vec<u8>);
}
```

---v

### Example #1: State

> Can the client also mutate Kian's balance? if so, how?

---v

### Example #1: State

* ðŸ’¡ The client needs to explicitly ask the runtime, if it wants to read some application-specific
  key from storage, such as the validator set, or the price of some token on a DEX.

> A small number of well known keys are hardcoded between the substrate client and any runtime. Any
> guesses? Find these values in substrate!

---v

### Example #1: State

```rust [1-3|6-10]
/// The keys known to the client.
mod well_known_keys {
  const CODE: &[u8] = ...;
}

/// The APIs the runtime exposes
trait RuntimeAPIs {
  add_to_kian_balance(amount: u64);
  get_validator_set() -> Vec<[u8; 32]>;
}
```

* The client should know which data to pass into the runtime, and what return type to expect.

---

## Example #2: Block Import

Now, let's look at another example task that has functions in both client and runtime.


---v

### Example #2: Block Import

```rust
// fetch the block from the outer world. It is opaque.
let block: Vec<u8> = networking::import_queue::next_block();

// initialize a wasm runtime
let code = well_known_keys::CODE;
let runtime = wasm::Executor::new(code);

// call into this runtime.
runtime.api.execute_block(opaque_block);
```

---v

### Example #2: Block Import

* ðŸ’¡ The client needs a runtime API to ask the runtime to execute the block

```rust
/// Some known type in the runtime.
type Block = ...;

/// More host functions
trait RuntimeAPIs {
  /// Assume the block parameter is auto-decoded
  fn execute_block(block: Block) -> Result<_, _>;
}
```

---v

### Example #2: Block Import

But this is actually not an accurate depiction..

* which runtime `CODE` do we load?
* which state do we provide to the runtime?

---v

### Example #2: Block Import

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-full.svg" />

---v

### Example #2: Block Import

```rust
// fetch the block from the outer world. It is opaque.
let block: Vec<u8> = networking::import_queue::next_block();

// initialize a wasm runtime
let code = well_known_keys::CODE;
let runtime = wasm::Executor::new(code);

// get the latest state
let parent = block.header.parent_hash;
let state = database::state_at(parent);

// call into this runtime.
let changes = state.execute(|| {
  runtime.api.execute_block(opaque_block);
});

// create the state of the next_block
let next_state = state.apply_changes(changes);
database::store_state(next_state, block.header.number)
```

---v

### Example #2: Block Import

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-import.svg" />


---v

### Example #2: Block Import

* ðŸ’¡ A runtime API call is only meaningful when executed at a give block.

<br>

* Based on that:
* The correct runtime code is loaded.
* The correct state (and other host functions) is provided.


---

## Example #3: Transaction Validation

Let's figure this out together!

---v

### Example #3: Transaction Validation

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-validation.svg" />

---v

### Example #3: Transaction Validation

* ðŸ’¡ The client needs a runtime API to ask the runtime to validate the transaction.
* ðŸ’¡ The state changes are actually discarded.

```rust
trait RuntimeAPIs {
  fn validate_extrinsic(block: Block::Extrinsic) -> Result<_, _> { ... }
}
```

---

## Example #4: Block Authoring

Let's figure this out together!

---v

### Example #4: Block Authoring

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-validation.svg" />

---v

### Example #4: Block Authoring


```rust
trait RuntimeAPIs {
  fn initialize_block(..) { ... }
  fn apply_extrinsic(ext: Block::Extrinsic) -> Result<_, _> { ... }
  fn finalize_block(..) { ... }
}
```

---

## Example #5: Runtime Upgrade

Finally, a runtime upgrade is really just another transaction, that as a side-effect, updates that
hardcoded key where the code is supposed to be stored.

---v

### Example #5: Runtime Upgrade

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-upgrade.svg" />

---

## BUT WAIT A FUCKING MINUTE ðŸ˜±

* if the code changes, all of the generic definitions, such as:

1. what is the block/extrinsic format
2. what is the state layout

* can also change.


---v

### BUT WAIT A FUCKING MINUTE ðŸ˜±

Yes, it can, we're fucked.

---v

### BUT WAIT A FUCKING MINUTE ðŸ˜±

* Just kidding, two antidotes:
1. Every runtime API (and for a matter of fact, host function too) is only reasonable ON TOP OF A GIVEN BLOCK.

> All runtime APIs have an implicit `at: Option<BlockNumber>` parameter.

---v

### BUT WAIT A FUCKING MINUTE ðŸ˜±

Metadata ðŸŽ‰

NOTE:

Some personal rant: radical upgradability is the biggest advantage, and arguably one of the main
developability problems of the substrate ecosystem. Writing clients, such as block explorers,
scanners, and even exchange integration are orders of magnitude harder than a blockchain that has a
fixed format and only changes every 18 months at most. That being said, this is a battle that is to
me a no-brainer, and we simply HAVE to win. When ethereum first introduced smart contracts, everyone
probably had the same class of issues. This is the same matter, on a a different level.

---

## PHEW. That Was a Close One ðŸ˜®â€ðŸ’¨

---

## BUT WAIT A FUCKING MINUTE ðŸ˜±

What if any of the runtime calls, like `execute_block` or `apply_extrinsic` panics?

NOTE:

The rule of thumb is: A panic will cause the wasm execution environment to be immediately
terminated, and any state change is dropped aka. reverted.

While you might think the state revert is the good thing here, it is the main problem, and the main
reason you should not let a code-path that is accessible by arbitrary users to panic. Because, any
fees paid for the wasted execution of that runtime API call is also reverted.

In other words, a panic in the runtime typically allows everyone's time to be wasted, for free,
indefinitely. In other words, a DOS vector.

> A panic in `initialize_block` and `finalize_block` have even more catastrophic effects, which will
> be discussed further in the FRAME section.

TODO: workshop: make a panicing runtime, and DoS it out.
TODO: ask sergei to sanity check this.

---v

### BUT WAIT A FUCKING MINUTE ðŸ˜±

* Panic in a user-callable code path is typically abusable ðŸ˜ .
* Panic on "automatic" part of your blockchain like `initialize_block` are deadly ðŸ’€.

---

## Substrate: The Full Picture

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-full.svg" />

---

## Runtime APIs: The Full List

* look for `impl_runtime_apis! {...}` and `decl_runtime_apis! {...}` macro calls.
* **Core**, **TxQueue**, **BlockBuilder**, **OffchainWorker**, **Metadata**
* Sky's the limit! A runtime can expose any more functions through APIs.

> A good definition of an STF is something that implements `Core` API.

---

## Host Functions: The Full List

* Look for `#[runtime_interface]` macro.
* Including, but not limited to: cryptography, hashing, storage, memory allocation, threading..

---

## Workshop: Code Walkthrough

Let's have a brief look at `node-template` and `sp-io`.

---

# Part 2: Advance Topics

---

## Defining a Runtime API

```rust
// somewhere in common between client/runtime => substrate-primitive.
decl_runtime_apis! {
	pub trait Core {
		fn version() -> RuntimeVersion;
		fn execute_block(block: Block) -> bool;
	}
}

// somewhere in the runtime code.
impl_runtime_apis! {
  impl sp_api::Core<Block> for Runtime {
    fn version() -> RuntimeVersion { /* stuff */ }
    fn execute_block(block: Block) -> bool { /* stuff */ }
  }
}

// somewhere in the client code..
let block_hash = "0xffff...";
let block = Block { ... };
let outcome: Vec<u8> = api.execute_block(block_hash, block).unwrap();
```

---v

### Defining a Runtime API: Takeaways

- All runtime APIs are executed on top of a **specific block**. This is the implicit _at_ parameter.

- All runtime APIs return a `Result<Vec<u8>, _>`, where the inner `Vec<u8>` is the SCALE encoded
  value that we wanted to return. In some abstractions, they also auto-decode it, in some they
  don't.

> going through the runtime API, **everything** is encode/decode-ed **both-ways**.

---

## Defining a Host Function

```rust
// somewhere in substrate primitives, almost always `sp_io`.
#[runtime_interface]
pub trait Storage {
  fn get(&self, key: &[u8]) -> Option<Vec<u8>> {
    self.storage(key).map(|s| s.to_vec())
  }

  fn root() -> Vec<u8>
}

#[runtime_interface]
pub trait Hashing {
	fn blake2_128(data: &[u8]) -> [u8; 16] {
		sp_core::hashing::blake2_128(data)
	}
}

// somewhere in substrate runtime
let hashed_value = sp_io::storage::get(b"key")
  .and_then(sp_io::hashing::blake2_128)
  .unwrap();
```

---

## Considerations

---v

### Consideration: Native Runtime

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-native.svg" />

---v

### Consideration: Native Runtime

* Remember the `fn version()` in `Core` API!
* Types are no longer `SCALE` encoded.


---v

### Consideration: Native Runtime

```rust
pub enum ExecutionStrategy {
  /// Execute with native build (if available, WebAssembly otherwise).
  Native,
  /// Only execute with the WebAssembly build.
  Wasm,
  /// Execute with both native (where available) and WebAssembly builds.
  Both,
  /// Execute with the native build if possible; if it fails, then execute with WebAssembly.
  NativeElseWasm,
}
```

---v

### Consideration: Native Runtime

```rust
fn execute_native_else_wasm() {
  let native_version = runtime::native::api::version();
  let wasm_version = runtime::wasm::api::version();

  if native_version == wasm_version {
    runtime::native::execute();
  } else {
    runtime::wasm::execute();
  }
}
```

> The days of native runtime are numbered ðŸ’€.

---v

### Considerations: Speed

#### Native vs WASM

* Wasmtime is near native.
* WASMI is significantly slower.
* Native execution requires the additional version check


---v

### Considerations: Speed

TODO: Figure that shows going over the boundary is like doing IO in a CPU. Or, a syscall.

#### WASM / Host Boundary

* Going over the runtime boundary is analogous to your CPU needing to go to memory.
* Host is generally faster, but it has a one-time copy cost.

> Main reason why hashing and crypto is done as host functions.

Notes:

- cost of calling is parameter passing: memory copy: one should strive to reduce the number of call to host function.
- For instance in storage when calculating the root we do not build it in wasm and call the hash host
  function multiple times: we just have a host function doing the root calculation and state trie kept
  in client.

On the other hand things as `next_storage` are high cost (generally iteration on state from runtime
is expensive). This design is related to the memory location, there is alternative but this is
simple (simple as good design).

(iteration remains very costly: because each call to next is going through the host function boundaries (and historically caching is not supporting it : only get: trade off between code complexity and performance here)

- Question: we got host function for running computation intensive code in native, but when simd for
  wasm would be added, then will host function for a hashing be still useful:

A: wait and see, but is possible that simd optimization of the hash function in wasm is way faster.

Again using a host function for speed up needs to be reasoned, cost of transmitting parameter in
wasm can be bigger than the actual hashing cost.


---v

### Considerations: Determinism

- All about **context**, but generally crucial.

- `Core` must be **absolutely deterministic** ðŸ‘Š.
- `BlockBuilder`... ðŸ§
- `OffchainWorker`... ðŸ¤·

> Host functions that mutate state (`storage`) must be deterministic.

---v

### Consideration: Adding Host Function

Adding a host function that's not being used?

- nada ðŸ˜…

<!-- .element: class="fragment" -->

Runtime requiring a host function?

<!-- .element: class="fragment" -->

1. Runtime upgrades that demand new host functions cannot be fully forkless ðŸ¤”..

<!-- .element: class="fragment" -->

1. The old one must stay FOREVER! ðŸ˜±

<!-- .element: class="fragment" -->

---v

### Consideration: Adding Host Function

All Substrate PRs that have added new host functions:
https://github.com/paritytech/substrate/issues?q=label%3AE4-newhostfunctions+is%3Aclosed

All substrate PRs that have required the client to be update first: https://github.com/paritytech/substrate/issues?q=is%3Aclosed+label%3A%22E10-client-update-first+%F0%9F%91%80%22

---v

### Consideration: Runtime API Versioning

The runtime APIs of each runtime are explicitly defined.

The types (including the return types corresponding to that runtime API) are in the metadata.

It is _in principle_ solved.

Not always in practice.

Notes:

Unlike the host functions that are all dumped in `sp_io`.

---v

### Consideration: Runtime API Versioning

> Rule of thumb: Every time you change the signature of a host function / runtime API, i.e. change
> the input/output types, you need to think about this.

But what you have to do is dependent on the scenario.

---v

### Consideration: Runtime API Versioning

```rust
sp_api::decl_runtime_apis! {
	#[api_version(6)]
	pub trait BlockBuilder {
		/// Apply the given extrinsic.
		///
		/// Returns an inclusion outcome which specifies if this extrinsic is included in
		/// this block or not.
		fn apply_extrinsic(extrinsic: <Block as BlockT>::Extrinsic) -> ApplyExtrinsicResult;

		#[changed_in(6)]
		fn apply_extrinsic(
			extrinsic: <Block as BlockT>::Extrinsic,
		) -> sp_runtime::legacy::byte_sized_error::ApplyExtrinsicResult;
	}
}
```

---v

### Consideration: Runtime API Versioning

> Example in the code: `system_dryRun` RPC.

```rust
let result = if api_version < 6 {
  #[allow(deprecated)]
  let _ = api.apply_extrinsic_before_version_6(&at, uxt)
    .map(convert_old_error_to_new);
} else {
  let _ = api.apply_extrinsic(&at, uxt);
};
```

---

## Workshop: Inspecting Wasm Code

`wasm2wat polkadot_runtime.wasm > dump | rg export`

```
  (export "__indirect_function_table" (table 0))
  (export "Core_version" (func $Core_version))
  (export "Core_execute_block" (func $Core_execute_block))
  (export "Core_initialize_block" (func $Core_initialize_block))
  (export "Metadata_metadata" (func $Metadata_metadata))
  (export "BlockBuilder_apply_extrinsic" (func $BlockBuilder_apply_extrinsic))
  (export "BlockBuilder_finalize_block" (func $BlockBuilder_finalize_block))
  (export "BlockBuilder_inherent_extrinsics" (func $BlockBuilder_inherent_extrinsics))
  (export "BlockBuilder_check_inherents" (func $BlockBuilder_check_inherents))
  (export "TaggedTransactionQueue_validate_transaction" (func $TaggedTransactionQueue_validate_transaction))
  (export "OffchainWorkerApi_offchain_worker" (func $OffchainWorkerApi_offchain_worker))
  (export "ParachainHost_validators" (func $ParachainHost_validators))
  (export "ParachainHost_validator_groups" (func $ParachainHost_validator_groups))
  (export "ParachainHost_availability_cores" (func $ParachainHost_availability_cores))
  (export "ParachainHost_persisted_validation_data" (func $ParachainHost_persisted_validation_data))
  (export "ParachainHost_assumed_validation_data" (func $ParachainHost_assumed_validation_data))
  (export "ParachainHost_check_validation_outputs" (func $ParachainHost_check_validation_outputs))
  (export "ParachainHost_session_index_for_child" (func $ParachainHost_session_index_for_child))
  (export "ParachainHost_validation_code" (func $ParachainHost_validation_code))
  (export "ParachainHost_candidate_pending_availability" (func $ParachainHost_candidate_pending_availability))
  (export "ParachainHost_candidate_events" (func $ParachainHost_candidate_events))
  (export "ParachainHost_session_info" (func $ParachainHost_session_info))
  (export "ParachainHost_dmq_contents" (func $ParachainHost_dmq_contents))
  (export "ParachainHost_inbound_hrmp_channels_contents" (func $ParachainHost_inbound_hrmp_channels_contents))
  (export "ParachainHost_validation_code_by_hash" (func $ParachainHost_validation_code_by_hash))
  (export "ParachainHost_on_chain_votes" (func $ParachainHost_on_chain_votes))
  (export "ParachainHost_submit_pvf_check_statement" (func $ParachainHost_submit_pvf_check_statement))
  (export "ParachainHost_pvfs_require_precheck" (func $ParachainHost_pvfs_require_precheck))
  (export "ParachainHost_validation_code_hash" (func $ParachainHost_validation_code_hash))
  (export "ParachainHost_staging_get_disputes" (func $ParachainHost_staging_get_disputes))
  (export "BeefyApi_validator_set" (func $BeefyApi_validator_set))
  (export "MmrApi_generate_proof" (func $MmrApi_generate_proof))
  (export "MmrApi_verify_proof" (func $MmrApi_verify_proof))
  (export "MmrApi_verify_proof_stateless" (func $MmrApi_verify_proof_stateless))
  (export "MmrApi_mmr_root" (func $MmrApi_mmr_root))
  (export "MmrApi_generate_batch_proof" (func $MmrApi_generate_batch_proof))
  (export "MmrApi_verify_batch_proof" (func $MmrApi_verify_batch_proof))
  (export "MmrApi_verify_batch_proof_stateless" (func $MmrApi_verify_batch_proof_stateless))
  (export "GrandpaApi_grandpa_authorities" (func $GrandpaApi_grandpa_authorities))
  (export "GrandpaApi_current_set_id" (func $GrandpaApi_current_set_id))
  (export "GrandpaApi_submit_report_equivocation_unsigned_extrinsic" (func $GrandpaApi_submit_report_equivocation_unsigned_extrinsic))
  (export "GrandpaApi_generate_key_ownership_proof" (func $GrandpaApi_generate_key_ownership_proof))
  (export "BabeApi_configuration" (func $BabeApi_configuration))
  (export "BabeApi_current_epoch_start" (func $BabeApi_current_epoch_start))
  (export "BabeApi_current_epoch" (func $BabeApi_current_epoch))
  (export "BabeApi_next_epoch" (func $BabeApi_next_epoch))
  (export "BabeApi_generate_key_ownership_proof" (func $BabeApi_generate_key_ownership_proof))
  (export "BabeApi_submit_report_equivocation_unsigned_extrinsic" (func $BabeApi_submit_report_equivocation_unsigned_extrinsic))
  (export "AuthorityDiscoveryApi_authorities" (func $AuthorityDiscoveryApi_authorities))
  (export "SessionKeys_generate_session_keys" (func $SessionKeys_generate_session_keys))
  (export "SessionKeys_decode_session_keys" (func $SessionKeys_decode_session_keys))
  (export "AccountNonceApi_account_nonce" (func $AccountNonceApi_account_nonce))
  (export "TransactionPaymentApi_query_info" (func $TransactionPaymentApi_query_info))
  (export "TransactionPaymentApi_query_fee_details" (func $TransactionPaymentApi_query_fee_details))
  (export "__data_end" (global 1))
  (export "__heap_base" (global 2))
```

---v

### Workshop: Inspecting Wasm Code

`wasm2wat polkadot_runtime.wasm > dump | rg import`

```
  (import "env" "memory" (memory (;0;) 22))
  (import "env" "ext_offchain_index_set_version_1" (func $ext_offchain_index_set_version_1 (type 16)))
  (import "env" "ext_allocator_free_version_1" (func $ext_allocator_free_version_1 (type 1)))
  (import "env" "ext_allocator_malloc_version_1" (func $ext_allocator_malloc_version_1 (type 0)))
  (import "env" "ext_default_child_storage_clear_version_1" (func $ext_default_child_storage_clear_version_1 (type 16)))
  (import "env" "ext_default_child_storage_get_version_1" (func $ext_default_child_storage_get_version_1 (type 17)))
  (import "env" "ext_default_child_storage_next_key_version_1" (func $ext_default_child_storage_next_key_version_1 (type 17)))
  (import "env" "ext_default_child_storage_set_version_1" (func $ext_default_child_storage_set_version_1 (type 18)))
  (import "env" "ext_logging_log_version_1" (func $ext_logging_log_version_1 (type 19)))
  (import "env" "ext_logging_max_level_version_1" (func $ext_logging_max_level_version_1 (type 14)))
  (import "env" "ext_crypto_ed25519_generate_version_1" (func $ext_crypto_ed25519_generate_version_1 (type 20)))
  (import "env" "ext_crypto_ed25519_verify_version_1" (func $ext_crypto_ed25519_verify_version_1 (type 21)))
  (import "env" "ext_crypto_finish_batch_verify_version_1" (func $ext_crypto_finish_batch_verify_version_1 (type 14)))
  (import "env" "ext_crypto_secp256k1_ecdsa_recover_version_2" (func $ext_crypto_secp256k1_ecdsa_recover_version_2 (type 22)))
  (import "env" "ext_crypto_secp256k1_ecdsa_recover_compressed_version_2" (func $ext_crypto_secp256k1_ecdsa_recover_compressed_version_2 (type 22)))
  (import "env" "ext_crypto_sr25519_generate_version_1" (func $ext_crypto_sr25519_generate_version_1 (type 20)))
  (import "env" "ext_crypto_sr25519_public_keys_version_1" (func $ext_crypto_sr25519_public_keys_version_1 (type 4)))
  (import "env" "ext_crypto_sr25519_sign_version_1" (func $ext_crypto_sr25519_sign_version_1 (type 23)))
  (import "env" "ext_crypto_sr25519_verify_version_2" (func $ext_crypto_sr25519_verify_version_2 (type 21)))
  (import "env" "ext_crypto_start_batch_verify_version_1" (func $ext_crypto_start_batch_verify_version_1 (type 13)))
  (import "env" "ext_hashing_blake2_128_version_1" (func $ext_hashing_blake2_128_version_1 (type 24)))
  (import "env" "ext_hashing_blake2_256_version_1" (func $ext_hashing_blake2_256_version_1 (type 24)))
  (import "env" "ext_hashing_keccak_256_version_1" (func $ext_hashing_keccak_256_version_1 (type 24)))
  (import "env" "ext_hashing_twox_128_version_1" (func $ext_hashing_twox_128_version_1 (type 24)))
  (import "env" "ext_hashing_twox_64_version_1" (func $ext_hashing_twox_64_version_1 (type 24)))
  (import "env" "ext_storage_append_version_1" (func $ext_storage_append_version_1 (type 16)))
  (import "env" "ext_storage_clear_version_1" (func $ext_storage_clear_version_1 (type 25)))
  (import "env" "ext_storage_clear_prefix_version_2" (func $ext_storage_clear_prefix_version_2 (type 17)))
  (import "env" "ext_storage_commit_transaction_version_1" (func $ext_storage_commit_transaction_version_1 (type 13)))
  (import "env" "ext_storage_exists_version_1" (func $ext_storage_exists_version_1 (type 24)))
  (import "env" "ext_storage_get_version_1" (func $ext_storage_get_version_1 (type 26)))
  (import "env" "ext_storage_next_key_version_1" (func $ext_storage_next_key_version_1 (type 26)))
  (import "env" "ext_storage_read_version_1" (func $ext_storage_read_version_1 (type 27)))
  (import "env" "ext_storage_rollback_transaction_version_1" (func $ext_storage_rollback_transaction_version_1 (type 13)))
  (import "env" "ext_storage_root_version_2" (func $ext_storage_root_version_2 (type 4)))
  (import "env" "ext_storage_set_version_1" (func $ext_storage_set_version_1 (type 16)))
  (import "env" "ext_storage_start_transaction_version_1" (func $ext_storage_start_transaction_version_1 (type 13)))
  (import "env" "ext_misc_print_hex_version_1" (func $ext_misc_print_hex_version_1 (type 25)))
  (import "env" "ext_misc_print_utf8_version_1" (func $ext_misc_print_utf8_version_1 (type 25)))
  (import "env" "ext_misc_runtime_version_version_1" (func $ext_misc_runtime_version_version_1 (type 26)))
  (import "env" "ext_trie_blake2_256_ordered_root_version_2" (func $ext_trie_blake2_256_ordered_root_version_2 (type 28)))
  (import "env" "ext_offchain_is_validator_version_1" (func $ext_offchain_is_validator_version_1 (type 14)))
  (import "env" "ext_offchain_local_storage_clear_version_1" (func $ext_offchain_local_storage_clear_version_1 (type 29)))
  (import "env" "ext_offchain_local_storage_compare_and_set_version_1" (func $ext_offchain_local_storage_compare_and_set_version_1 (type 30)))
  (import "env" "ext_offchain_local_storage_get_version_1" (func $ext_offchain_local_storage_get_version_1 (type 11)))
  (import "env" "ext_offchain_local_storage_set_version_1" (func $ext_offchain_local_storage_set_version_1 (type 19)))
  (import "env" "ext_offchain_network_state_version_1" (func $ext_offchain_network_state_version_1 (type 15)))
  (import "env" "ext_offchain_random_seed_version_1" (func $ext_offchain_random_seed_version_1 (type 14)))
  (import "env" "ext_offchain_submit_transaction_version_1" (func $ext_offchain_submit_transaction_version_1 (type 26)))
  (import "env" "ext_offchain_timestamp_version_1" (func $ext_offchain_timestamp_version_1 (type 15)))
```

Notes:


---

## Lecture Recap

* Things like block format and state layout are ENTIRELY up to the runtime to decide.
* Since the runtime is itself part of the state and can change, so can these definitions.
* This is why METADATA is an important part of the substrate ecosystem.
* Avoid panics in the runtime as a general rule of thumb and best-practice.
* Main client tasks:
  * P2P networking + RPC
  * Block and State Database
  * Consensus Tasks (Block Authoring/Finality)
  * Wasm Executor
  * Native Runtime
* Main runtime tasks:
  * Consensus Logic
    * Execute blocks.
    * Author blocks.
  ...
  * Transaction validity while in tx-pool.
  * Dictate who is the next validator set.
  * Dictate how the entire blockchain state is to be interpreted.
* Everything over the runtime boundary (API or Host Function) are SCALE encoded, and relatively slow.


---

### Coding Activity 1 - Flipper Runtime

We have prepared a FRAME-less runtime. Let's walk over it a bit.

It does, by all means nothing.

try and do as many of the following, in the same order:

- make it a flipper: it stores one `bool` value, and per each transaction, flips that value.
- make it an adder: it stores one `u32` value, and each transaction specifies a number, which is
  added to this value and stored onchain again.
- extend your transaction so that the runtime can be either an adder or a multiplier.

---v

### Coding Activity 1 - Flipper Runtime

- add a kill-switch to this runtime. Look into `well_known_keys` to see which key you have to wipe.
- make this runtime upgradable! The upgrade operation can simply be protected by a "password" as you
  don't have any notion of accounts yet.
- Add a notion of accounts and nonces and signatures.
- Add a notion of balances
- Write a custom runtime API, and try to call it over the RPC.
- Implement a tx-pool api, implement tipping, priority, longevity etc.

.. you can virtually do endless experiments on top of the frameless runtime. Make good ues of it,
and you will learn a lot about the fundamentals of substrate!

Moreover, this is the perfect intro to FRAME. You feel the pain of how hard it is to code your own
blockchain from scratch ðŸ˜ˆ.

---

## Coding Activity 2 - Substrate StateMachine
