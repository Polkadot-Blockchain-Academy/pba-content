---
title: Database and Merklized Storage
description: Substrate Database and Merklized Storage for Web3 engineers
duration: 30 mins
instructors: ["Kian Paimani"]
teaching-assistants: ["..."]
---

# Substrate Storage

---

## Substrate Storage: Key Value

* Recall that at the `sp_io` layer, you have keys and values.

* `sp_io::storage::get(b"key")`;
* `sp_io::storage::get(b"key", b"value")`;


---v

### Substrate Storage: Key Value

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-storage-1.svg"></img>

---v

### Substrate Storage: Key Value

* In Substrate, a type needs to provide the environment in which host functions are provided, and
  can be executed.

> We call this an "externality environment", represented by `trait Externalities`.

By convention, an externality has a "backend" that is in charge of dealing with storage.


---v

### Substrate Storage: Key Value

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-storage-2.svg"></img>

---v

### Substrate Storage: Key Value

* How about a key-value storage externality? why not? ðŸ™ˆ

<br>

* O(1) Read and write.
* Hash all the data once to get a root.

---v

### Substrate Storage: Key Value

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-kv-backend.svg"></img>


---v

### Substrate Storage: Key Value

* If alice only has this root, how can I, how can I prove to her how much balance she has?

> Alice is representing a light client, I represent a full node.

THE WHOLE FUCKING DATABASE ðŸ˜±.

---

## Substrate Storage: Merklized

* This brings us again to why we like to "merkelize" things.
* We take the key, and make it be the path on a trie.
* Some nodes contain value, some nodes are just "connectors".

---v

### Substrate Storage: Merklized

#### Assumptions:

- let's we have this single node that's the root, assume we always have this available.
- assume this is a radix-26, patricia trie. english alphabet is the key-scope.
- If we want to store the same data as we did with the kv-ext, this is how it would look like.

---v


<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-trie-backend-unhashed.svg"></img>

NOTE:

1. walk over the process of retrieving "balances_alice".

---v

### Substrate Storage: Merklized

* If alice only has this root, how can I, how can I prove to her how much balance she has?

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-trie-backend-proof.svg"></img>

---

## WAIT A FUCKING MINUTE... ðŸ¤”

* What if there is a node with a very large value along the path of a proof?

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-trie-backend-proof-fat.svg"></img>
---

### Substrate Storage: *Real* Merklized

* The Trie-node format I showed was a massive over-simplification. See code or Shawn's talk for more.
* Instead of alphabet, we use the base-16 representation of the hashes.
  * The Patricia-aspect of the trie would be totally different because of this, different paths overlap.

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-trie-backend-hashed.svg"></img>

---

## Substrate Storage: The Updated Picture

<img style="width: 1000px;" src="../../../assets/img/4-Substrate/dev-storage-3.svg"></img>

---

## Substrate Storage: The Role of FRAME

* All FRAME does is hashing keys, really. No seriously, that's almost all it does.

<img style="width: 1000px;" src="../../../assets/img/4-Substrate/dev-storage-4.svg"></img>

---

## WAIT A FUCKING MINUTE... ðŸ¤”

* Most of the time, the domain at which we car about storage is within one runtime API call...
* We rarely care about state root before the end of the block, when importing..

> A runtime-api-scoped cache for storage.

---

## Substrate Storage: Overlay

* Is a cache layer.
* It works **based on key-values**, **not trie-format**.
  * Once you read a value, it stays here, and can be re-read for cheap.
  * Once you write a value, it will only be written here.
    * It can be read for cheap.
  * All writes are flushed at the end of the runtime api call.


---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-overlay.svg"></img>

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-overlay-1.svg"></img>

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-overlay-2.svg"></img>

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-overlay-3.svg"></img>

---v

### Substrate Storage: Overlay


* Cheap != Free

```rust
let temp = sp_io::storage::get(b"bar");

// is a lot faster!
let cached = sp_io::storage::get(b"bar");
// but not as fast as this!
let in_memory = temp;
```

* A deletion is basically a write.

---v

### Substrate Storage: Overlay

* The overlay is also able to spawn child-overlays, know as "*storage layer*".
* Useful for having a *transactional* block of code.

```rust
// spawn a new layer.
with_storage_layer(|| {
    // this is now cached in .
    let foo = sp_io::storage::read(b"foo");
    // this write is only done to the top
    sp_io::storage::set(b"bar", foo);

    if cond {
        Err("this will be reverted")
    } else {
        Ok("This will be commit to the top overlay")
    }
})
```

NOTE:

- implement with zero-copy. So, the size of values is not so important, it is more about the number.

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-overlay-nested.svg"></img>

---v

<img style="width: 1400px;" src="../../../assets/img/4-Substrate/dev-overlay-nested-1.svg"></img>

---v

### Substrate Storage: Overlay

* There is a limit to how many tested layers you can spawn
* It is not free, thus it is attack-able.

```rust
with_storage_layer(|| {
    let foo = sp_io::storage::read(b"foo");
    with_storage_layer(|| {
        sp_io::storage::set(b"foo", b"foo");
        with_storage_layer(|| {
            sp_io::storage::set(b"bar", foo);
            with_storage_layer(|| {
                sp_io::storage::set(b"foo", "damn");
                Err("damn")
            })
            Ok("what")
        })
        Err("the")
    });
    Ok("hell")
})
```

---v

### Substrate Storage: Overlay

> What if I call `sp_io::storage::root()` in the middle of the block?

* Can the overlay respond to this?

NOTE:

NO! overlay works on the level on key-values, ot knows nothing of trie nodes, and to compute the root we have to go to the trie layer and pull a whole lot of data back from the disk and build all the nodes etc. etc.

---v

### Substrate Storage: Word on Caches

* There are more caches in the trie layer as well.
* I am too afraid to talk about them though.

---

### Substrate Storage: Final Figure

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-storage-full.svg"></img>

---v

### Substrate Storage

There are multiple implementations of `Externalities`:

1. `TestExternalities`:
   1. `Overlay`
   2. `TrieDb` with `InMemoryBackend`
   3. Some extensions
2. `Ext` (the real thing ðŸ«¡)
   1. `Overlay`
   2. `TrieDb` with a real database being the backend
   3. All extensions.

---v

### Substrate Storage

* Recall

Any code accessing host functions needs to wrapped in something that implements `Externalities`

```rust
MyExternalities.execute_with(|| {
    let x = sp_io::storage::get(b"foo");
});
```

NOTE:

Remind them of the error message of if you forget about this.
