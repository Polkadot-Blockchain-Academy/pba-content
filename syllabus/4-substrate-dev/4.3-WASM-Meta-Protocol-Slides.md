---
title: Substrate WASM meta-protocol
description: A deeper dive into how the WASM is meta-protocol functions in substrate.
duration: 60 minutes
instructors: ["Kian Paimani"]
teaching-assistants: [""]
---

# Substrate WASM Meta Protocol

<widget-speaker name="Kian Paimani" position="Core Dev" image="../../../assets/img/0-Shared/people/kian.png" github="kianenigma" twitter="kianenigma"></widget-speaker>

---

# Part 1

* This is a big lecture, so I divided it into two small parts, that's all ü´µüèª

---

## It All Began With a Runtime..

* The Client / Runtime division is one of the most important design decisions in Substrate.

* In some sense, this lecture is a deeper dive into this decision, and its *tradeoffs*\*.


<div class="" style="font-size:calc(var(--size) / 2)">

> *Like any other decision, it is a tradeoff, not purely advantageous.

</div>

---v

## It All Began With a Runtime..

Personal opinion:

> Substrate technology stack will put "WASM stored onchain" on the map, the same way Ethereum put
> "smart contracts stored onchain" on the map.

Bold claim:

> It is only a matter of time until every blockchain is doing the same thing.

---

## Substrate: a short recap

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-full-comm.svg" />

---v

### Substrate: a short recap

* **Host Functions**: Means of a runtime communicating with its host environment, i.e. the Substrate client.
* **Runtime API**: The well-defined functions that a WASM substrate runtime is providing.

<br>

* Database is a *untyped*, *opaque*, **key-value** storage, stored **per-block**.

---v

### Substrate: a short recap

Let's have a deep look at how the client and runtime communicate with one another, both ways.

---

## Example #1: State

* The runtime wants to add 10 units to Kian's balance.

---v

### Example #1: State

```rust [1-2|4,5|7,8|10,11|13,14]
// The runtime decides what key stores kian's balance.
key: Vec<u8> = b"kian_balance".to_vec();

// the runtime reads the raw bytes form that key..
let current_kian_balance_raw: Vec<u8> = host_functions::get(key);

// and needs to know to which type they should be decoded.
let mut current_kian_balance: u128 = current_kian_balance_raw.decode();

// actual logic.
current_kian_balance += 10;

// write the encoded bytes again.
host_functions::put(key, next_kian_balance.encode());
```

---v

### Example #1: State

* üí° The runtime needs a host function to read/write to state.

```rust
/// a hypothetical set of host functions.
trait HostFunctions {
  fn get(key: Vec<u8>) -> Vec<u8>;
  fn set(key: Vec<u8>, value: Vec<u8>);
}
```

---v

### Example #1: State

> Can the client also mutate Kian's balance? if so, how?

---v

### Example #1: State

* üí° The client needs to explicitly ask the runtime, if it wants to read some application-specific
  key from storage, such as the validator set, or the price of some token on a DEX.

> A small number of well known keys are hardcoded between the substrate client and any runtime. Any
> guesses? Find these values in substrate!

---v

### Example #1: State

```rust
/// The keys known to the client.
mod well_known_keys {
  const CODE: &[u8] = ...;
}

/// APIs that the client can call into.
trait RuntimeApis {
  fn get_kian_balance() -> u64;
  fn get_validator_set() -> Vec<[u8; 32]>;
}
```

* Other application-specific functions needs to be part of a custom runtime-api!
* Also note that the runtime APIs are, unlike host functions, well typed. Why?

NOTE:

the runtime is the source of truth for all "application specific types". Then, the communication
form runtime to client will be untyped, and typed from runtime to client.

---

## Example #2: Block Import

Now, let's look at another example task that has functions in both client and runtime.


---v

### Example #2: Block Import

```rust [1-2|4-6|7-9|11-12]
// fetch the block from the outer world. It is opaque.
let opaque_block: Vec<u8> = networking::import_queue::next_block();

// maybe decode the block??
// let decoded_block: Block = block.decode()

// initialize a wasm runtime
let code = well_known_keys::CODE;
let runtime = wasm::Executor::new(code);

// call into this runtime.
runtime.execute_block(opaque_block);
```

> Question: where is the block decoded? in the client? Why?

NOTE:

for the most part, in the runtime. Why? Because the block encodes extrinsics/transaction.
Transactions, are part of the application logic of the blockchain and can change, when a runtime
changes. So, the same rules that apply to "storage keys" technically apply to transactions as well.
They can change at the same abstraction layer, every time that the runtime changes. Therefore,
neither are known to the client.

In reality, the block is partially decoded in the client (up to being splited into `header` and
`extrinsics`).

TODO: link to this point later in the "Blocks and  Extrinsics" lecture.


---v

### Example #2: Block Import

* üí° The client needs a runtime API to ask the runtime to execute the block

```rust
/// Some known type in the runtime.
type RuntimeBlock = ...;

/// More host functions
trait RuntimeApis {
  fn execute_block(block: OpaqueBlock) -> Result<_, _> {
    let block: RuntimeBlock = block.into();
    ...
  }
}
```

---v

### Example #2: Block Import

<div class="flex-container">

<div class="right">
<img style="width: 1000px" src="../../../assets/img/4-Substrate/dev-4-1-transition.svg"></img>
</div>

<div class="left">

* But this is actually not an accurate depiction üëé
* which state do we use to fetch the code?

</div>

</div>

---v

### Example #2: Block Import

```rust [9-100]
// fetch the block from the outer world. It is opaque.
let raw_block: Vec<u8> = networking::import_queue::next_block();
let block = OpaqueBlock = raw_block.into();

// get the latest state
let parent = block.header.parent_hash;
let state = database::state_at(parent);

// initialize a wasm runtime
let code = state::get(well_known_keys::CODE);
let runtime = wasm::Executor::new(code);

// call into this runtime.
let changes = state.execute(|| {
  runtime.execute_block(block);
});

// create the state of the next_block
let next_state = state.apply_changes(changes);
database::store_state(next_state, block.header.number)
```

---v

### Example #2: Block Import

* But this is even now, still not an accurate depiction üëé.
* Recall that anyone that imports the block should check its state root!
* Also, operations like hashing happen outside of the runtime for performance reasons..

---v

### Example #2: Block Import

```rust [13-20]
// fetch the block from the outer world. It is opaque.
let raw_block: Vec<u8> = networking::import_queue::next_block();
let block = OpaqueBlock = raw_block.into();

// get the latest state
let parent = block.header.parent_hash;
let state = database::state_at(parent);

// initialize a wasm runtime
let code = state::get(well_known_keys::CODE);
let runtime = wasm::Executor::new(code);

// call into this runtime.
let changes = state.execute(|| {
  runtime.execute_block(block);

  let new_state_root = host_functions::state_root();
  let claimed_state_root = block.header.state_root;
  assert_eq!(new_state_root, claimed_state_root);
});

// create the state of the next_block
let next_state = state.apply_changes(changes);
database::store_state(next_state, block.header.number)
```

---v

### Example #2: Block Import

* üí° A runtime API call is only meaningful **when executed at a give block**.
* Based on that:
  * The correct runtime code is loaded.
  * The correct state (and other host functions) is provided.

---v

### Example #2: Block Import

* In reality, you will stumble upon client code like this all the time:

```rust
let block_hash = "0x2134123..";
let input_data = "0x2134123..";

/// To call into a runtime API.
let result = client.api.function_name(input_data, block_hash);
```

* Similarly, almost all RPC operations have an `Option<Hash>` argument.
* I guess it should be clear by now what that means üòé.


---v

### Example #2: Block Import: Recap

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-import.svg" />

---

## Example #3: Block Authoring

---v

### Example #3: Block Authoring

* Let's first talk about this over the figure!

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-full.svg" />

---v

### Example #3: Block Authoring

```rust
// get the best-block, based on whatever consensus rule we have.
let (best_number, best_hash) = consensus::best_block();

// get the latest state
let state = database::state_at(best_hash);

// initialize a wasm runtime.
let code = state::get(well_known_keys::CODE);
let runtime = wasm::Executor::new(code);

// repeatedly apply transactions.
state.execute(|| {
    while let Some(next_ext) = transaction_pool_iter::next() {
        runtime.api.apply_extrinsic(next_ext);
    }
})
```

---v

### Example #3: Block Authoring

* But what the damn hell is an *extrinsic*??
* Relax, for now, assume it is just a transaction.

---v

### Example #3: Block Authoring

* Substrate based runtimes allow are allowed to perform some operations at the beginning and end of each block.

---v

### Example #3: Block Authoring

```rust [11-100]
// get the best-block, based on whatever consensus rule we have.
let (best_number, best_hash) = consensus::best_block();

// get the latest state
let state = database::state_at(best_hash);

// initialize a wasm runtime.
let code = state::get(well_known_keys::CODE);
let runtime = wasm::Executor::new(code);

state.execute(|| {
  // tell this runtime that you wish to start a new block.
  runtime.api.initialize_block(best_number + 1);

  // repeatedly apply transactions.
  while let Some(next_ext) = transaction_pool_iter::next() {
      runtime.api.apply_extrinsic(next_ext);
  }

  // tell the runtime that we are done.
  runtime.api.finalize_block();
})
```

---v

### Example #3: Block Authoring

```rust
trait RuntimeApis {
  fn initialize_block(..) { ... }
  fn apply_extrinsic(ext: Block::Extrinsic) -> Result<_, _> { ... }
  fn finalize_block(..) { ... }
}
```

---

## Example #4: Runtime Upgrade

* Finally, a runtime upgrade is really just another transaction, that as a side-effect, updates that
hardcoded key where the code is supposed to be stored.

---v

### Example #4: Runtime Upgrade

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-upgrade.svg" />

---

## Recap of Interactions Learned:

1. State Update
2. Block Import
3. Block Authoring
4. Code Upgrade

* A few items that you have not learned about, but worth a moment of explanation:

1. Transaction Pool Validation
2. Version!
3. Offchain Workers

---

## BUT WAIT A FUCKING MINUTE üò±

* if the code changes, all the following can also change:

1. What state key is kian's balance.
2. What block/extrinsic format is valid.

* How on earth is an application (i.e. a wallet) is supposed to survive?

---v

### BUT WAIT A FUCKING MINUTE üò±

* Metadata üéâ

```rust
trait RuntimeApis {
  fn metadata() -> Vec<u8> { ... }
}
```

* Combined with the fact that every runtime API is tied to the runtime code of a given block.
* Two different wasm blobs in block `N` and `N+1` return different values in this function.

NOTE:

Some personal rant: radical upgradability is the biggest advantage, and arguably one of the main
developability problems of the substrate ecosystem. Writing clients, such as block explorers,
scanners, and even exchange integration are orders of magnitude harder than a blockchain that has a
fixed format and only changes every 18 months at most. That being said, this is a battle that is to
me a no-brainer, and we simply HAVE to win. When ethereum first introduced smart contracts, everyone
probably had the same class of issues. This is the same matter, on a a different level.

---

## PHEW. That Was a Close One üòÆ‚Äçüí®

---

## BUT WAIT A FUCKING MINUTE üò±

* What if any of the runtime calls, like `execute_block` or `apply_extrinsic` panics?

NOTE:

The rule of thumb is: A panic will cause the wasm execution environment to be immediately
terminated, and any state change is dropped aka. reverted.

While you might think the state revert is the good thing here, it is the main problem, and the main
reason you should not let a code-path that is accessible by arbitrary users to panic. Because, any
fees paid for the wasted execution of that runtime API call is also reverted.

In other words, a panic in the runtime typically allows everyone's time to be wasted, for free,
indefinitely. In other words, a DOS vector.

> A panic in `initialize_block` and `finalize_block` have even more catastrophic effects, which will
> be discussed further in the FRAME section.

TODO: workshop: make a panicing runtime, and DoS it out.
TODO: ask sergei to sanity check this.

---v

### BUT WAIT A FUCKING MINUTE üò±

* Panic in a user-callable code path is typically abusable üò†.
* Panic on "automatic" part of your blockchain like `initialize_block` are deadly üíÄ.

---

## Substrate: The Full Picture

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-full.svg" />

---

## Runtime APIs: The Full List

* look for `impl_runtime_apis! {...}` and `decl_runtime_apis! {...}` macro calls.
* **Core**, **TxQueue**, **BlockBuilder**, **OffchainWorker**, **Metadata**
* Sky's the limit! A runtime can expose any more functions through APIs.

> A good definition of an STF is something that implements `Core` API.

---

## Host Functions: The Full List

* Look for `#[runtime_interface]` macro.
* Including, but not limited to: cryptography, hashing, storage, memory allocation, threading..

---

## Workshop: Code Walkthrough

Let's have a brief look at `node-template` and `sp-io`.

---

# Part 2: Advance Topics

* Optional, less abstract, more concrete.

---

## Defining a Runtime API

```rust
// somewhere in common between client/runtime => substrate-primitive.
decl_runtime_apis! {
	pub trait Core {
		fn version() -> RuntimeVersion;
		fn execute_block(block: Block) -> bool;
	}
}

// somewhere in the runtime code.
impl_runtime_apis! {
  impl sp_api::Core<Block> for Runtime {
    fn version() -> RuntimeVersion { /* stuff */ }
    fn execute_block(block: Block) -> bool { /* stuff */ }
  }
}

// somewhere in the client code..
let block_hash = "0xffff...";
let block = Block { ... };
let outcome: Vec<u8> = api.execute_block(block_hash, block).unwrap();
```

---v

### Defining a Runtime API: Takeaways

- All runtime APIs are executed on top of a **specific block**. This is the implicit _at_ parameter.

- All runtime APIs return a `Result<Vec<u8>, _>`, where the inner `Vec<u8>` is the SCALE encoded
  value that we wanted to return. In some abstractions, they also auto-decode it, in some they
  don't.

> going through the runtime API, **everything** is encode/decode-ed **both-ways**.

---

## Defining a Host Function

```rust
// somewhere in substrate primitives, almost always `sp_io`.
#[runtime_interface]
pub trait Storage {
  fn get(&self, key: &[u8]) -> Option<Vec<u8>> {...}
  fn get(&self, key: &[u8], value: &[u8]) -> Option<Vec<u8>> {...}
  fn root() -> Vec<u8> {...}
}

#[runtime_interface]
pub trait Hashing {
	fn blake2_128(data: &[u8]) -> [u8; 16] {
		sp_core::hashing::blake2_128(data)
	}
}

// somewhere in substrate runtime
let hashed_value = sp_io::storage::get(b"key")
  .and_then(sp_io::hashing::blake2_128)
  .unwrap();
```

---

## Considerations

---

### Consideration: Native Runtime

<img style="width: 1200px;" src="../../../assets/img/4-Substrate/dev-4-3-native.svg" />

---v

### Consideration: Native Runtime

* Remember the `fn version()` in `Core` API!
* Types are no longer `SCALE` encoded.


---v

### Consideration: Native Runtime

```rust
pub enum ExecutionStrategy {
  /// Execute with native build (if available, WebAssembly otherwise).
  Native,
  /// Only execute with the WebAssembly build.
  Wasm,
  /// Execute with both native (where available) and WebAssembly builds.
  Both,
  /// Execute with the native build if possible; if it fails, then execute with WebAssembly.
  NativeElseWasm,
}
```

---v

### Consideration: Native Runtime

```rust
fn execute_native_else_wasm() {
  let native_version = runtime::native::api::version();
  let wasm_version = runtime::wasm::api::version();

  if native_version == wasm_version {
    runtime::native::execute();
  } else {
    runtime::wasm::execute();
  }
}
```

> The days of native runtime are numbered üíÄ.

---

### Considerations: Speed

#### Native vs WASM

* Wasmtime is near-native üèéÔ∏è.
* WASMI is significantly slower üê¢.
* Potential native execution requires the additional version check.


---v

### Considerations: Speed

#### WASM / Host Boundary

<div class="flex-container">
<div class="right">

* Going over the runtime boundary is analogous to your CPU needing to go to memory.
* Host is generally faster, but it has a one-time copy cost.

> Main reason why hashing and crypto is done as host functions.
>
</div>
<div class="left">

<img style="width: 600px;" src="../../../assets/img/4-Substrate/dev-4-3-io.svg" />

</div>
</div>

Notes:

- cost of calling is parameter passing: memory copy: one should strive to reduce the number of call to host function.
- For instance in storage when calculating the root we do not build it in wasm and call the hash host
  function multiple times: we just have a host function doing the root calculation and state trie kept
  in client.

On the other hand things as `next_storage` are high cost (generally iteration on state from runtime
is expensive). This design is related to the memory location, there is alternative but this is
simple (simple as good design).

(iteration remains very costly: because each call to next is going through the host function
boundaries (and historically caching is not supporting it : only get: trade off between code
complexity and performance here)

- Question: we got host function for running computation intensive code in native, but when simd for
  wasm would be added, then will host function for a hashing be still useful:

A: wait and see, but is possible that simd optimization of the hash function in wasm is way faster.

Again using a host function for speed up needs to be reasoned, cost of transmitting parameter in
wasm can be bigger than the actual hashing cost.


---

### Considerations: Determinism

- All about **context**, but generally crucial.

- `Core` must be **absolutely deterministic** üëä.
- `BlockBuilder`... üßê
- `OffchainWorker`... ü§∑

---

### Consideration: Adding Host Function


* A runtime upgrade now requires a new `sp_io::new_stuff::foo()`. Can we do a normal runtime upgrade?

<div>

* üß† Clients need to upgrade first. No more fully forkless upgrade üò¢

</div>

<!-- .element: class="fragment" -->

---v

### Consideration: Breaking a Host Function

* Let's imagine we change `sp_io::storage::root` such that it calculates the root much faster, but
  in a non-compatible way (the final hashes are different). How about this?

<div>

* üß† Not only the clients have to upgrade first, they need to keep the old version around as well.

</div>

<!-- .element: class="fragment" -->

---v

### FOREVER üôä

---

### Consideration: Runtime API Versioning

* Same principle, but generally easier to deal with.
* A runtime API, unlike a host function, is usable by many different clients.
  * The runtime API is defined in the metadata (soon‚Ñ¢Ô∏è).
  * Those written in a dynamically typed languages are usually fine üòé.


---v

### Consideration: Runtime API Versioning

* Also, recall that any api call from any client is always called **on top of a block**.
* So if something *non-breaking* changed from block `A` to `B`, who cares? ü§∑

---v

### Consideration: Runtime API Versioning

* The Rust code (which is **statically** typed) in substrate client does care if the change *is breaking*.
* At times, when the return/argument (input/output) of a runtime API changes, we need to write code like:

---v

### Consideration: Runtime API Versioning

```rust
sp_api::decl_runtime_apis! {
    // latest version
    fn foo() -> u32;

    // old version
    #[changed_in(4)]
    fn foo() -> u64;
}

let new_return_type = if api.version < 4 {
    // this weird function name is generated by decl_runtime_apis!
    let old_return_type = api.foo_before_version_4();
    // somehow convert it. don't care
    old_return_type.try_into().unwrap()
} else {
    api.foo()
}
```

---v

### Consideration: Runtime API Versioning

> Rule of thumb: Every time you change the signature of a host function / runtime API, i.e. change
> the input/output types, you need to think about this.

But what you have to do is dependent on the scenario.

---v

### Optional Activity

* Look into substrate and find all instances of `#[changed_in(_)]` macro
* Then see if/how this is being used in the client code.

---

## Workshop: Inspecting Wasm Code

`wasm2wat polkadot_runtime.wasm > dump | rg export`

```
  (export "__indirect_function_table" (table 0))
  (export "Core_version" (func $Core_version))
  (export "Core_execute_block" (func $Core_execute_block))
  (export "Core_initialize_block" (func $Core_initialize_block))
  (export "Metadata_metadata" (func $Metadata_metadata))
  (export "BlockBuilder_apply_extrinsic" (func $BlockBuilder_apply_extrinsic))
  (export "BlockBuilder_finalize_block" (func $BlockBuilder_finalize_block))
  (export "BlockBuilder_inherent_extrinsics" (func $BlockBuilder_inherent_extrinsics))
  (export "BlockBuilder_check_inherents" (func $BlockBuilder_check_inherents))
  (export "TaggedTransactionQueue_validate_transaction" (func $TaggedTransactionQueue_validate_transaction))
  (export "OffchainWorkerApi_offchain_worker" (func $OffchainWorkerApi_offchain_worker))
  (export "ParachainHost_validators" (func $ParachainHost_validators))
  (export "ParachainHost_validator_groups" (func $ParachainHost_validator_groups))
  (export "ParachainHost_availability_cores" (func $ParachainHost_availability_cores))
  (export "ParachainHost_persisted_validation_data" (func $ParachainHost_persisted_validation_data))
  (export "ParachainHost_assumed_validation_data" (func $ParachainHost_assumed_validation_data))
  (export "ParachainHost_check_validation_outputs" (func $ParachainHost_check_validation_outputs))
  (export "ParachainHost_session_index_for_child" (func $ParachainHost_session_index_for_child))
  (export "ParachainHost_validation_code" (func $ParachainHost_validation_code))
  (export "ParachainHost_candidate_pending_availability" (func $ParachainHost_candidate_pending_availability))
  (export "ParachainHost_candidate_events" (func $ParachainHost_candidate_events))
  (export "ParachainHost_session_info" (func $ParachainHost_session_info))
  (export "ParachainHost_dmq_contents" (func $ParachainHost_dmq_contents))
  (export "ParachainHost_inbound_hrmp_channels_contents" (func $ParachainHost_inbound_hrmp_channels_contents))
  (export "ParachainHost_validation_code_by_hash" (func $ParachainHost_validation_code_by_hash))
  (export "ParachainHost_on_chain_votes" (func $ParachainHost_on_chain_votes))
  (export "ParachainHost_submit_pvf_check_statement" (func $ParachainHost_submit_pvf_check_statement))
  (export "ParachainHost_pvfs_require_precheck" (func $ParachainHost_pvfs_require_precheck))
  (export "ParachainHost_validation_code_hash" (func $ParachainHost_validation_code_hash))
  (export "ParachainHost_staging_get_disputes" (func $ParachainHost_staging_get_disputes))
  (export "BeefyApi_validator_set" (func $BeefyApi_validator_set))
  (export "MmrApi_generate_proof" (func $MmrApi_generate_proof))
  (export "MmrApi_verify_proof" (func $MmrApi_verify_proof))
  (export "MmrApi_verify_proof_stateless" (func $MmrApi_verify_proof_stateless))
  (export "MmrApi_mmr_root" (func $MmrApi_mmr_root))
  (export "MmrApi_generate_batch_proof" (func $MmrApi_generate_batch_proof))
  (export "MmrApi_verify_batch_proof" (func $MmrApi_verify_batch_proof))
  (export "MmrApi_verify_batch_proof_stateless" (func $MmrApi_verify_batch_proof_stateless))
  (export "GrandpaApi_grandpa_authorities" (func $GrandpaApi_grandpa_authorities))
  (export "GrandpaApi_current_set_id" (func $GrandpaApi_current_set_id))
  (export "GrandpaApi_submit_report_equivocation_unsigned_extrinsic" (func $GrandpaApi_submit_report_equivocation_unsigned_extrinsic))
  (export "GrandpaApi_generate_key_ownership_proof" (func $GrandpaApi_generate_key_ownership_proof))
  (export "BabeApi_configuration" (func $BabeApi_configuration))
  (export "BabeApi_current_epoch_start" (func $BabeApi_current_epoch_start))
  (export "BabeApi_current_epoch" (func $BabeApi_current_epoch))
  (export "BabeApi_next_epoch" (func $BabeApi_next_epoch))
  (export "BabeApi_generate_key_ownership_proof" (func $BabeApi_generate_key_ownership_proof))
  (export "BabeApi_submit_report_equivocation_unsigned_extrinsic" (func $BabeApi_submit_report_equivocation_unsigned_extrinsic))
  (export "AuthorityDiscoveryApi_authorities" (func $AuthorityDiscoveryApi_authorities))
  (export "SessionKeys_generate_session_keys" (func $SessionKeys_generate_session_keys))
  (export "SessionKeys_decode_session_keys" (func $SessionKeys_decode_session_keys))
  (export "AccountNonceApi_account_nonce" (func $AccountNonceApi_account_nonce))
  (export "TransactionPaymentApi_query_info" (func $TransactionPaymentApi_query_info))
  (export "TransactionPaymentApi_query_fee_details" (func $TransactionPaymentApi_query_fee_details))
  (export "__data_end" (global 1))
  (export "__heap_base" (global 2))
```

<!-- .element: class="fragment" -->

---v

### Workshop: Inspecting Wasm Code

* Why is there no versioning here in the runtime API level?

---v

### Workshop: Inspecting Wasm Code

`wasm2wat polkadot_runtime.wasm > dump | rg import`

```
  (import "env" "memory" (memory (;0;) 22))
  (import "env" "ext_offchain_index_set_version_1" (func $ext_offchain_index_set_version_1 (type 16)))
  (import "env" "ext_allocator_free_version_1" (func $ext_allocator_free_version_1 (type 1)))
  (import "env" "ext_allocator_malloc_version_1" (func $ext_allocator_malloc_version_1 (type 0)))
  (import "env" "ext_default_child_storage_clear_version_1" (func $ext_default_child_storage_clear_version_1 (type 16)))
  (import "env" "ext_default_child_storage_get_version_1" (func $ext_default_child_storage_get_version_1 (type 17)))
  (import "env" "ext_default_child_storage_next_key_version_1" (func $ext_default_child_storage_next_key_version_1 (type 17)))
  (import "env" "ext_default_child_storage_set_version_1" (func $ext_default_child_storage_set_version_1 (type 18)))
  (import "env" "ext_logging_log_version_1" (func $ext_logging_log_version_1 (type 19)))
  (import "env" "ext_logging_max_level_version_1" (func $ext_logging_max_level_version_1 (type 14)))
  (import "env" "ext_crypto_ed25519_generate_version_1" (func $ext_crypto_ed25519_generate_version_1 (type 20)))
  (import "env" "ext_crypto_ed25519_verify_version_1" (func $ext_crypto_ed25519_verify_version_1 (type 21)))
  (import "env" "ext_crypto_finish_batch_verify_version_1" (func $ext_crypto_finish_batch_verify_version_1 (type 14)))
  (import "env" "ext_crypto_secp256k1_ecdsa_recover_version_2" (func $ext_crypto_secp256k1_ecdsa_recover_version_2 (type 22)))
  (import "env" "ext_crypto_secp256k1_ecdsa_recover_compressed_version_2" (func $ext_crypto_secp256k1_ecdsa_recover_compressed_version_2 (type 22)))
  (import "env" "ext_crypto_sr25519_generate_version_1" (func $ext_crypto_sr25519_generate_version_1 (type 20)))
  (import "env" "ext_crypto_sr25519_public_keys_version_1" (func $ext_crypto_sr25519_public_keys_version_1 (type 4)))
  (import "env" "ext_crypto_sr25519_sign_version_1" (func $ext_crypto_sr25519_sign_version_1 (type 23)))
  (import "env" "ext_crypto_sr25519_verify_version_2" (func $ext_crypto_sr25519_verify_version_2 (type 21)))
  (import "env" "ext_crypto_start_batch_verify_version_1" (func $ext_crypto_start_batch_verify_version_1 (type 13)))
  (import "env" "ext_hashing_blake2_128_version_1" (func $ext_hashing_blake2_128_version_1 (type 24)))
  (import "env" "ext_hashing_blake2_256_version_1" (func $ext_hashing_blake2_256_version_1 (type 24)))
  (import "env" "ext_hashing_keccak_256_version_1" (func $ext_hashing_keccak_256_version_1 (type 24)))
  (import "env" "ext_hashing_twox_128_version_1" (func $ext_hashing_twox_128_version_1 (type 24)))
  (import "env" "ext_hashing_twox_64_version_1" (func $ext_hashing_twox_64_version_1 (type 24)))
  (import "env" "ext_storage_append_version_1" (func $ext_storage_append_version_1 (type 16)))
  (import "env" "ext_storage_clear_version_1" (func $ext_storage_clear_version_1 (type 25)))
  (import "env" "ext_storage_clear_prefix_version_2" (func $ext_storage_clear_prefix_version_2 (type 17)))
  (import "env" "ext_storage_commit_transaction_version_1" (func $ext_storage_commit_transaction_version_1 (type 13)))
  (import "env" "ext_storage_exists_version_1" (func $ext_storage_exists_version_1 (type 24)))
  (import "env" "ext_storage_get_version_1" (func $ext_storage_get_version_1 (type 26)))
  (import "env" "ext_storage_next_key_version_1" (func $ext_storage_next_key_version_1 (type 26)))
  (import "env" "ext_storage_read_version_1" (func $ext_storage_read_version_1 (type 27)))
  (import "env" "ext_storage_rollback_transaction_version_1" (func $ext_storage_rollback_transaction_version_1 (type 13)))
  (import "env" "ext_storage_root_version_2" (func $ext_storage_root_version_2 (type 4)))
  (import "env" "ext_storage_set_version_1" (func $ext_storage_set_version_1 (type 16)))
  (import "env" "ext_storage_start_transaction_version_1" (func $ext_storage_start_transaction_version_1 (type 13)))
  (import "env" "ext_misc_print_hex_version_1" (func $ext_misc_print_hex_version_1 (type 25)))
  (import "env" "ext_misc_print_utf8_version_1" (func $ext_misc_print_utf8_version_1 (type 25)))
  (import "env" "ext_misc_runtime_version_version_1" (func $ext_misc_runtime_version_version_1 (type 26)))
  (import "env" "ext_trie_blake2_256_ordered_root_version_2" (func $ext_trie_blake2_256_ordered_root_version_2 (type 28)))
  (import "env" "ext_offchain_is_validator_version_1" (func $ext_offchain_is_validator_version_1 (type 14)))
  (import "env" "ext_offchain_local_storage_clear_version_1" (func $ext_offchain_local_storage_clear_version_1 (type 29)))
  (import "env" "ext_offchain_local_storage_compare_and_set_version_1" (func $ext_offchain_local_storage_compare_and_set_version_1 (type 30)))
  (import "env" "ext_offchain_local_storage_get_version_1" (func $ext_offchain_local_storage_get_version_1 (type 11)))
  (import "env" "ext_offchain_local_storage_set_version_1" (func $ext_offchain_local_storage_set_version_1 (type 19)))
  (import "env" "ext_offchain_network_state_version_1" (func $ext_offchain_network_state_version_1 (type 15)))
  (import "env" "ext_offchain_random_seed_version_1" (func $ext_offchain_random_seed_version_1 (type 14)))
  (import "env" "ext_offchain_submit_transaction_version_1" (func $ext_offchain_submit_transaction_version_1 (type 26)))
  (import "env" "ext_offchain_timestamp_version_1" (func $ext_offchain_timestamp_version_1 (type 15)))
```

<!-- .element: class="fragment" -->

---

### Activity: Frame-less Runtime

* We have prepared a FRAME-less runtime. Let's walk over it a bit.
* It does, by all means nothing.
* try and do as many of the following, in the same order:

TODO..
