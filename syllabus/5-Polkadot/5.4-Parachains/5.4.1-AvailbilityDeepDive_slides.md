---
title: Parachains Architecture - Availbility Deep Dive
description: Polkadot Parachains for Web3 engineers
duration: 1 hour
instructors: ["Bernhard Schuster, Robert Klotzner"]
teaching-assistants: ["Dan Shields"]
---

# Parachains Architecture - Availability Deep Dive

---

## Lecture Goals

- Parachain consensus <!-- .element: class="fragment" -->

---

## Path of a parachain - birds eye

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/bs_birdseye_block_path.png" style="height: 300px">

- Backing <!-- .element: class="fragment" -->
- Availability <!-- .element: class="fragment" -->
- Approval <!-- .element: class="fragment" -->
- Disputes <!-- .element: class="fragment" -->

---

## Revisit

- What does availability mean? <!-- .element: class="fragment" -->
- Why do we need availability? <!-- .element: class="fragment" -->

- Why not to just distribute the PoV?

  - How large is a PoV?

  - Network Bandwidth
  - Storage on chain

## Compressed representation: Bitfields

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/bs_bitfields.png" style="height: 600px">

// TODO double check and reformulate

- Gossiped availability bitfields, the candidates that are available from the point of view of _one validator_ in the active set - number of bits equiv. to the number of `AvailabilityCore`s - submitted on-chain

- Accumulation of bitfields on-chain: `AvailabilityBitfields` - each bit determines if a candidate is available for the bit at validator's index position in the bitfield - number of bits is equiv. to the number of `AvailabilityCore`s

- chunk related bitfield, are there a sufficient number of chunks present to restore the data

---

## Availability Core

---

## Erasure Encoding

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/bs_erasure_abastract.png" style="height: 600px">

Goals:

- Allow to reconstruct the original data from `k` out of `n` chunks, losing `t` chunks at most.

## Proceedings

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/bs_erasure_zoom_1.png" style="height: 600px">

- Field (static, shared)
- Generator Polynomial (static, shared)

`$$p_x(a) = \sum^k_{i=1} x_i a^{i-1}`

`$$ C(x) = (p_x(a_1),.. p_x(a_n))`

`$$ C(x): F^k -> F^n`

```$$
A = [
    1 \cdots 1 \cdots 1;
    a_1 \cdots a_k \cdots a_n;
    a_1^2 \cdots a_k^2 \cdots a_n^2;
    \vdots \vdots \vdots
    a_1^{k-1} \cdots a_k^{k-1} \cdots a_n^{k-1};
    ]
```

Notes:

- `$$C(x)` is a linear mapping
- linear code
- `$$A` is the generator matrix
- non-systematic
- DFFT if `$$a_i` = `$$\alpha_i`


## Decoding

- Matrix inversion

Notes:

- DIFFT (only if `$$\alpha` is a primitve root of `$$\F/p` where `p` prime and no errors in the chunks received)

## Malicious Actors

- Altered chunk data?
- Would cause a PoV / PVF run to fail!

Solution: Supply a merkle proof with each chunk

## Erasure Encoding - Reality

- Matrix inversion / multiplication too slow `$$O(n^3)`


Polkadot Implementation: Novel Polynomial Basis (paper by Sian-Jheng Lin et. al.): <https://github.com/paritytech/reed-solomon-novelpoly>
