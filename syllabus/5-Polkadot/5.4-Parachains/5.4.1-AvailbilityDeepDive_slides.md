---
title: Parachains Architecture - Availbility Deep Dive
description: Polkadot Parachains for Web3 engineers
duration: 1 hour
instructors: ["Bernhard Schuster, Robert Klotzner"]
teaching-assistants: ["Dan Shields"]
---

# Parachains Architecture - Availability Deep Dive

---

## Lecture Goals

- Parachain consensus <!-- .element: class="fragment" -->

---

## Path of a parachain - birds eye

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/bs_birdseye_block_path.png" style="height: 300px">

- Backing <!-- .element: class="fragment" -->
- Availability <!-- .element: class="fragment" -->
- Approval <!-- .element: class="fragment" -->
- Disputes <!-- .element: class="fragment" -->

---

## Revisit

- What does availability mean? <!-- .element: class="fragment" -->
- Why do we need availability? <!-- .element: class="fragment" -->

- Why not to just distribute the PoV?

  - How large is a PoV?

  - Network Bandwidth
  - Storage on chain

## Compressed representation: Bitfields

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/bs_bitfields.png" style="height: 600px">

// TODO double check and reformulate

- Gossiped availability bitfields, the candidates that are available from the point of view of _one validator_ in the active set - number of bits equiv. to the number of `AvailabilityCore`s - submitted on-chain

- Accumulation of bitfields on-chain: `AvailabilityBitfields` - each bit determines if a candidate is available for the bit at validator's index position in the bitfield - number of bits is equiv. to the number of `AvailabilityCore`s

- chunk related bitfield, are there a sufficient number of chunks present to restore the data

---

## Availability Core

---

## Erasure Encoding

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/bs_erasure_abastract.png" style="height: 600px">

Goals:

- Allow to reconstruct the original data from `k` out of `n` chunks, losing `t` chunks at most.

## Proceedings

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/bs_erasure_zoom_1.png" style="height: 600px">

- Field (static, shared)
- Generator Polynomial (static, shared)

`$$p_x(a) = \sum^k_{i=1} x_i a^{i-1}`

`$$ C(x) = (p_x(a_1),.. p_x(a_n))`

`$$ C(x): F^k -> F^n`

```$$
A = [
    1 \cdots 1 \cdots 1;
    a_1 \cdots a_k \cdots a_n;
    a_1^2 \cdots a_k^2 \cdots a_n^2;
    \vdots \vdots \vdots
    a_1^{k-1} \cdots a_k^{k-1} \cdots a_n^{k-1};
    ]
```

Notes:

- `$$C(x)` is a linear mapping
- linear code
- `$$A` is the generator matrix
- non-systematic
- DFFT if `$$a_i` = `$$\alpha_i`


## Decoding

- Matrix inversion

Notes:

- DIFFT (only if `$$\alpha` is a primitve root of `$$\F/p` where `p` prime and no errors in the chunks received)

## Malicious Actors

- Altered chunk data?
- Would cause a PoV / PVF run to fail!

Solution: Supply a merkle proof with each chunk

## Erasure Encoding - Reality

- Matrix inversion / multiplication too slow `$$O(n^3)`


Polkadot Implementation: Novel Polynomial Basis (paper by Sian-Jheng Lin et. al.): <https://github.com/paritytech/reed-solomon-novelpoly>

---

## All good?

- Bad group - security? <!-- .element: class="fragment" -->
- Large groups - scalability? <!-- .element: class="fragment" -->
- Performance <!-- .element: class="fragment" -->
- Liveness <!-- .element: class="fragment" -->

Notes:

Large group: Make it statistically unlikely enough to have a majority malicious group.
Works, but:

→ Performance: relying on statistics: groups have to be relatively large ~40 validators.
→ Liveness: If nodes don't vote we have to assume the worst → escalate.

---

# Catch Bad Guys

---

## Wait .. Bad Guys?

What can malicious nodes actually do?

- No (faithfully) PVF execution <!-- .element: class="fragment" -->
- Manipulate messages <!-- .element: class="fragment" -->
- Fool Light Clients <!-- .element: class="fragment" -->

Notes:

Quick recap: What harm can a malicious validator actually do? What do we need to worry about?

Not (properly) executing the block, providing results that don't adhere to the rules of the PVF.
Such a block would likely be not accepted by other parachain nodes, but light clients might get fooled and more importantly other parachains can get fooled with manipulated messages.

---

## Catch Bad Guys

- and punish them <!-- when caught --> <!-- .element: class="fragment" -->
- gamblers ruin <!-- .element: class="fragment" -->

Notes:

- Eventually the system can be broken, but if attempts result in loss of significant funds any realistic attacker will go bankrupt way before.
- Purpose of backing checkers: Get skin in the game - collators are external.

---

## How do we do that?

- 2 (3) phase process <!-- .element: class="fragment" -->
- Validators get skin in the game (backing) <!-- .element: class="fragment" -->
- Check the checkers (approvals) <!-- .element: class="fragment" -->
- Punish (disputes) <!-- .element: class="fragment" -->

Notes:

How: Validators need to be known in advance so collator nodes can connect.
We need to be able to check the checkers.

---

## Two Phase Process

- Backing <!-- .element: class="fragment" -->
- Approval <!-- .element: class="fragment" -->

Does this work already? <!-- .element: class="fragment" -->

No <!-- .element: class="fragment" -->

What is the problem? <!-- .element: class="fragment" -->

Notes:

1. Approval checkers must not be guessable in advance - solvable via VRF.
2. Data must be guaranteed available, so backers cannot get away with not providing necessary data to approval checkers.

→ Not sufficient.

---

## Three Phase Process

- Backing <!-- .element: class="fragment" -->
- Inclusion/Availability <!-- .element: class="fragment" -->
- Approval <!-- .element: class="fragment" -->

Does this work already?
<!-- .element: class="fragment" -->

Yes! <!-- .element: class="fragment" -->

---

## But how?

- Backing group is untrusted <!-- .element: class="fragment" -->
- Collators are untrusted <!-- .element: class="fragment" -->
- Availability proof on chain? <!-- .element: class="fragment" -->

Notes:

How do we actually achieve availability?

---

## 1. Solution Attempt

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/Polkadot 6.png" style="height: 400px">

- Send PoV to all validators <!-- .element: class="fragment" -->

---

## 1. Solution Attempt

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/Polkadot 7.png" style="height: 400px">

- Send PoV to all validators
- Signed Statement

Works, but very costly: Performance! <!-- .element: class="fragment" -->

---

## 2. Solution Attempt

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/Polkadot 8.png" style="height: 400px">

Problems:

- Still inefficient! 40x overhead. <!-- .element: class="fragment" -->

---

## 2. Solution Attempt

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/Polkadot 9.png" style="height: 400px">

Problems:

- Still inefficient! 40x overhead.
- Relatively easy to DoS

---

## 3. Solution Attempt

<image src="../../../assets/img/5-Polkadot/Polkadot 5.4/Polkadot 10.png" style="height: 400px">

- Erasure coding <!-- .element: class="fragment" -->
- Distribute to all <!-- .element: class="fragment" -->
- Overhead only 3x <!-- .element: class="fragment" -->
- Hard to DoS <!-- .element: class="fragment" -->

---

## Recap

- Known backing group - get skin in the game <!-- .element: class="fragment" -->
- Make available <!-- .element: class="fragment" -->
- Reveal approval checkers <!-- .element: class="fragment" -->
- Catch bad guys <!-- .element: class="fragment" -->
- Punish them <!-- .element: class="fragment" -->

---

## Disputes

- Raised during approval checking <!-- .element: class="fragment" -->
- Escalation to all nodes: Performance!? <!-- .element: class="fragment" -->
- Slash Offenders - have them pay the bill! <!-- .element: class="fragment" -->
- Disputes are not expected to happen ... <!-- .element: class="fragment" -->
-   ... because they exist! <!-- .element: class="fragment" -->

---

## Summary

- Secure heterogenous sharding <!-- .element: class="fragment" -->
- Shared Security <!-- .element: class="fragment" -->
- Performance via Specialization <!-- .element: class="fragment" -->

Notes:

Relay chain validators act as light clients for all parachains and are responsible for making sure all state transactions are sound.
Therefore shards (parachains) don't have to run light clients for all other shards (parachains), but instead only for the relay chain.
