---
title: Parachains # Also update the h1 header on the first slide to the same name
description: Use the `---` delineated slides here in your content!
duration: 15 minuets
instructors: ["Bernhard Schuster", "Robert Klotzner"]
teaching-assistants: ["Dan Shields"]
---

## Parachains

### _Module 5, Lecture 4_

<widget-speaker small name="Bernhard Schuster" position="TODO" image="TODO"></widget-speaker>

<widget-speaker small name="Robert Klotzner" position="TODO" image="TODO"></widget-speaker>

---

<widget-columns>
<widget-column>

<widget-speaker name="Bernhard Schuster" position="TODO" image="TODO" github="TODO" twitter="TODO" linkedin="TODO" matrix="TODO:matrix.parity.io"></widget-speaker>

</widget-column>
<widget-column>

<widget-speaker name="Robert Klotzner" position="TODO" image="TODO" github="TODO" twitter="TODO" linkedin="TODO" matrix="TODO:matrix.parity.io"></widget-speaker>

</widget-column>
</widget-columns>

---

### Outline

1. [Parachains: Why & How](#parachains-why--how)
1. [Parachain consensus](#con)
1. [Proof of Validity]() (PoV)
1. Disputes

---

## Parachains: Why & How

---v

### Parachains: Why & How

#### Blockchain Challenges

- Performance
- Scalability
- Security
- Liveness
- Decentralization

TODO DESIGN: Picture of nodes to the right of the list, all doing the same (no grouping)

Note:

Scalability: In every aspect: Throughput, but also storage. Relay chain
validators are "light clients" to parachains. Parachains act as heterogenous
shards, both in terms of execution and data availability. In contrast to Ethereum
2, which will just offer shared data availability.

Performance via Specialization: Parachains operate independently via "collator" nodes, can do
whatever they want, as long as the provide a PoV to relay chain validators.
Relay chain validators don't have to bother about handling transaction pools and
such.

Parachains help with all of these, but let's focus on scalability first.

---v

### Parachains: Why & How

#### How to achieve scalability?

- Split the work
<!-- .element: class="fragment" -->
- But maintain (economic) security!
<!-- .element: class="fragment" -->
- Liveness?
<!-- .element: class="fragment" -->

Note:

Security: Defer solution to upcoming slides. (Also mention shared security.)
Liveness: Suggest rotation.

---v

### Parachains: Why & How

#### Split the Work

TODO DESIGN: Picture of grouped validators validating parachains.

Note:

Introduce split up work between validators.

---v

### Parachains: Why & How

#### Rotate Groups

TODO DESIGN: Same picture as above, but with arrows hinting roup rotation.

Note:
Problem: Imagine each group is its own shard/blockchain - that would mean each node, as we rotate, would need to keep state for all those shards/parachains -> Does not scale too well.

---v

### Parachains: Why & How

#### Introducing Collators

TODO: Same picture as above, but with collator nodes connecting to the validator groups, keeping storage for the parachain, handling transaction pools + transaction gossip.
Hint rotating groups via arrows.

Note:

From the perspective of the relay chain collators are completely untrusted and
even unknown, but can keep storage and take care of some of the heavy lifting,
like gossiping transactions, maintaining transaction pools, ...

---v

TODO Idea: Visualize how performance and scalability is achieved. For example that collators are responsible to keep state for the parachains, take care of lots of the nitty-gritty details of block production.
Validators don't have to worry about individual transactions, collecting & prioritizing them, keeping them in pools.

In ETH 2, version 1 nomenclature: Collators/Parachain provide shards for data availability, but also version 2 execution shards.

---

## Parachain Consensus

---v

### Parachain Consensus

#### How does this work - Recap PoV

- Collators - untrusted
<!-- .element: class="fragment" -->
- PoV ... Proof of Validity
<!-- .element: class="fragment" -->

TODO DESIGN: Schematic visualization of a PoV: Merkle Tree with accessed state elements and block data.

<!-- .element: class="fragment" -->

---v

### Parachain Consensus

#### All good?

- Bad group?
<!-- .element: class="fragment" -->
- Large groups?
<!-- .element: class="fragment" -->
- Performance
<!-- .element: class="fragment" -->
- Liveness
<!-- .element: class="fragment" -->

Note:

Large group: Make it statistically unlikely enough to have a majority malicious
group. Works, but:

-> Performance: relying on statistics: groups have to be relatively large ~40 validators.
-> Liveness: If nodes don't vote we have to assume the worst -> escalate.

---v

### Parachain Consensus

#### Catch Bad Guys (1)

> ....Wait... Bad Guys?

What can malicious nodes actually do?

- No (faithfully) PVF execution
<!-- .element: class="fragment" -->
- Manipulate messages
<!-- .element: class="fragment" -->

Note:

Quick recap: What harm can a malicious validator actually do? What do we need to
worry about?

Not (properly) executing the block, providing results that don't adhere to the
rules of the PVF. Such a block would likely be not accepted by other parachain
nodes, but light clients might get fooled and more importantly other parachains
can get fooled with manipulated messages.

---v

### Parachain Consensus

#### Catch Bad Guys (2)

- and punish them <!-- when caught -->
<!-- .element: class="fragment" -->
- gamblers ruin
<!-- .element: class="fragment" -->

Note:

- Eventually the system can be broken, but if attempts result in loss of
  significant funds any realistic attacker will go bankrupt way before.
- Purpose of backing checkers: Get skin in the game - collators are external.

---v

### Parachain Consensus

#### Catch Bad Guys (3)

- 2 (3) phase process
<!-- .element: class="fragment" -->
- Validators get skin in the game (backing)
<!-- .element: class="fragment" -->
- Check the checkers (approvals)
<!-- .element: class="fragment" -->
- Punish (disputes)
<!-- .element: class="fragment" -->

Note:

How: Validators need to be known in advance so collator nodes can connect. We
need to be able to check the checkers.

---v

### Parachain Consensus

TODO DESIGN: Two phase diagram (backing -> approvals)

Does this work already?

<!-- .element: class="fragment" -->

No

<!-- .element: class="fragment" -->

What is the problem?

<!-- .element: class="fragment" -->

Note:

1. Approval checkers must not be guessable in advance - solvable via VRF.
2. Data must be guaranteed available, so backers cannot get away with not
   providing necessary data to approval checkers.

-> Not sufficient.

---v

### Parachain Consensus

TODO DESIGN: Three phase diagram (backing -> inclusion/availability -> approvals)

approvals only after we have proof on chain that data is available.

Does this work already?

Yes

<!-- .element: class="fragment" -->

---v

### Parachain Consensus

#### How to achieve **availability**?

- Backing group is untrusted
- Collators are untrusted
<!-- .element: class="fragment" -->
- Availability proof on chain?
<!-- .element: class="fragment" -->

---v

### Parachain Consensus

#### Availability - Attempt #1

TODO DESIGN: Picture where backing group sends data to all validators and they have a green checkmark (they signed something). Maybe two pictures, one without check marks and one with, changing with the bullet points below.

- Send PoV to all validators
<!-- .element: class="fragment" -->
- Signed Statement
<!-- .element: class="fragment" -->

Works, but very costly.

<!-- .element: class="fragment" -->

---v

### Parachain Consensus

#### Availability - Attempt #2

TODO DESIGN: Picture where backing group sends POV only to a _random_ subset of
remaining validators - other than that, same above.

<!-- .element: class="fragment" -->

---v

### Parachain Consensus

#### Availability - Attempt #2

TODO Design: Zoom in on nodes which received the PoV, with subset of validators under attack (DoS) and some malicious
nodes and one/two which manages to get data out.

Problems:

- Still inefficient! 40x overhead.
<!-- .element: class="fragment" -->
- Relatively easy to DoS
<!-- .element: class="fragment" -->

---v

### Parachain Consensus

#### Availability - Attempt #3

TODO DESIGN: Illustrating picture?

- Erasure coding
<!-- .element: class="fragment" -->
- Distribute to all
<!-- .element: class="fragment" -->
- Overhead only 3x
<!-- .element: class="fragment" -->
- Hard to DoS
<!-- .element: class="fragment" -->

---v

### Parachain Consensus

#### Recap

- Known backing group - get skin in the game
<!-- .element: class="fragment" -->
- Make available
<!-- .element: class="fragment" -->
- Reveal approval checkers
<!-- .element: class="fragment" -->
- Catch bad guys
<!-- .element: class="fragment" -->
- ... What now?
<!-- .element: class="fragment" -->

---

## Disputes

---v

### Disputes

TODO more content :)

---

## Economic Security

---v

### Economic Security

TODO more content :)

Note:

Relay chain validators act as light clients for all parachains and are
responsible for making sure all state transactions are sound. Therefore shards
(parachains) don't have to run light clients for all other shards (parachains),
but instead only for the relay chain.
