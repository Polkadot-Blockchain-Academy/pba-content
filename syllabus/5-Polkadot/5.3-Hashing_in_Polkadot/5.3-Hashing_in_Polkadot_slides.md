The computational cost of hashing and how it drives polkadot design.

# first slide a plan (all slide that would be see)

# proof

Polkadot: Assessing that a parachain state transition is correct.

Cumulus: parachains uses a trie state and cumulus define a given proof
No proof system assumed. In context of cumulus there is one.

Notes:
In practice design of system is currently and was historically largely
driven by the merkle trie state ethereum like design targetting.


# Merkle trie and proof

single value proof

TODO schema from the db & merklized slide

multiple value proof

TODO schema from the db & merklized slide

Notes:

this was alrealy evoked in length before. Just a reminder

Notice that there is no notion of order or sequence

# State transition proof


Just prove by executing

Symetry of proof

Proof system for merkle trie is 

Notes:

we see that proof are just foot print of a state.

scalability from polkadot design not the proof system


# zk proof

Asymetry


Notes:

many are proposing very fast checking scalling the information level.
eg the eth zkrollup.

In this case the parachains geto a lot on his plate: heavy producing with 
lot of implication, quite challenging and all.
But putting this on parachain model is ok, just the light part would be runing
there: validator only check the zk proof.
So can think of it as a sub problem.


# Proof size

Polkadot limit

Can grow big

Notes:

TODO find size limit

# Runtime update

runtime is in state

an extrinsic of the block is calling `set_code` through sudo

what happen?

Notes:

this value runtime is big... usual issues around the question
chunk solution...
Old runtime in proof?
-> TODO add a slide on the new trie format or just show how old one was not proper.








