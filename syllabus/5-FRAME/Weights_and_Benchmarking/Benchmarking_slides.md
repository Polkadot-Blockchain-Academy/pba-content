---
title: FRAME Benchmarking
description: How to benchmark Pallets in FRAME.
duration: 2 hours
instructors: ["Shawn Tabrizi"]
---

# FRAME Benchmarking

---

## Overview

- Quick Recap of Weights
- Deep Dive Into Benchmarking
- Our Learnings Throughout Development
- Best Practices and Common Patterns

---

## Blockchains are Limited

Blockchain systems are extremely limited environments.

Limited in:

- Execution Time / Block Time
- Available Storage
- Available Memory
- Network Bandwidth
- etc...

---

## Performance vs Centralization

Nodes are expected to be decentralized and distributed.

Increasing the system requirements can potentially lead to centralization in who can afford to run that hardware, and where such hardware may be available.

---

## Why do we need benchmarking?

Benchmarking ensures that when users interact with our Blockchain, they are not using resources beyond what is available and expected for our network.

TODO: improve wording.

---

## What is Weight?

Weight is a general concept used to track consumption of limited blockchain resources.

---

## What is Weight in Substrate?

We currently track just two main limitations:

- Execution Time on "Reference Hardware"
- Size of Data Required to Create a Merkle Proof

```rust
pub struct Weight {
	/// The weight of computational time used based on some reference hardware.
	ref_time: u64,
	/// The weight of storage space used by proof of validity.
	proof_size: u64,
}
```

This was already expanded once, and could be expanded in the future.

---

## Weight limits are specific to each blockchain.

- 1 second of compute on different computers allows for different amounts of computation.
- Weights of your blockchain will evolve over time.
- Higher hardware requirements will result in a more performant blockchain (i.e. TXs per second), but will limit the kinds of validators that can safely participate in your network.

---

## What can affect relative Weight?

<pba-cols>

<pba-col>

- Processor
- Memory
- Hard Drive
	- HDD vs. SSD vs. NVME
- Operating System
- Drivers

</pba-col>
<pba-col>

- Rust Compiler
- Runtime Execution Engine
	- compiled vs. interpreted
- Database
	- RocksDB vs. ParityDB vs. ?
- and more!

</pba-col>
</pba-cols>

---

## Block Import Weight Breakdown

<img style="height: 500px;" src="../../../assets/img/6-FRAME/benchmark/block-import.svg" />

---

# The Benchmarking Framework

---

## The Benchmarking Plan

<div class="flex-container">
<div class="left-large">

- Use empirical measurements of the runtime to determine the time it takes to execute extrinsics and other runtime logic.
- Run benchmarks using worst case scenario conditions.
	- Primary goal is to keep the runtime safe.
	- Secondary goal is to be as accurate as possible to maximize throughput.

</div>
<div class="right">

<img style="height: 600px;" src="../../../assets/img/6-FRAME/benchmark/benchmarking.svg" />

</div>
</div>

---

## The `benchmarks!` Macro

```rust
benchmarks! {
   extrinsic_name {
       /* setup initial state */
   }: _{ /* execute extrinsic or function */ }
   verify {
       /* verify final state */
   }
}
```

---

## Multiple Linear Regression Analysis

<div class="flex-container">
<div class="left-small">

<img style="height: 600px;" src="../../../assets/img/6-FRAME/benchmark/linear-regression.svg" />

</div>
<div class="right">

- We require that no functions in Substrate have superlinear complexity.
- Ordinary least squared linear regression.
	- linregress crate
- Supports multiple linear coefficients.
	- Y = Ax + By + Cz + k
- For constant time functions, we simply use the median value.


</div>
</div>

---

## The `benchmark` CLI

Compile your node with `--features runtime-benchmarks`.

```bash
âžœ  ~ substrate benchmark --help
Sub-commands concerned with benchmarking.
The pallet benchmarking moved to the `pallet` sub-command

Usage: polkadot benchmark <COMMAND>

Commands:
  pallet     Benchmark the extrinsic weight of FRAME Pallets
  storage    Benchmark the storage speed of a chain snapshot
  overhead   Benchmark the execution overhead per-block and per-extrinsic
  block      Benchmark the execution time of historic blocks
  machine    Command to benchmark the hardware
  extrinsic  Benchmark the execution time of different extrinsics
  help       Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help information
  -V, --version  Print version information
```

---

## `pallet` Subcommand

- Benchmark the weight of functions within pallets.
	- Any arbitrary code can be benchmarked.
- Outputs Autogenerated Weight files.

```rust
pub trait WeightInfo {
   fn transfer() -> Weight;
   fn transfer_keep_alive() -> Weight;
   fn set_balance_creating() -> Weight;
   fn set_balance_killing() -> Weight;
   fn force_transfer() -> Weight;
}
```

---

# Deep Dive

---

## The Benchmarking Process

TODO

---

## Benchmarks Evaluated Over Components

<img style="height: 600px;" src="../../../assets/img/6-FRAME/benchmark/components.svg" />
