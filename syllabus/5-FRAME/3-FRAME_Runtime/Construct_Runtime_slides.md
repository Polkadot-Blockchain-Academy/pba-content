---
title: Construct Runtime
description: Deep dive into the Construct Runtime macro
duration: 1 hour
---

# Runtime Construction

... And testing

---

<image src="../../../assets/img/6-FRAME/frame1.svg" style="height: 600px">

---v

### From a Pallet ..to the Runtime

- What is a runtime anyway? Anything that implements the aforementioned Runtime APIs.
- Most often fulfilled by the `Executive`.

---

## `construct_runtime`

```rust
frame_support::construct_runtime!(
  pub struct Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic,
  {
    System: frame_system,
    Timestamp: pallet_timestamp,
    Balances: pallet_balances,
    Aura: pallet_aura,
    Dpos: pallet_dpos,
  }
);
```

---v

### `construct_runtime`

```rust [2]
frame_support::construct_runtime!(
  pub struct Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic,
  {
    System: frame_system,
    Timestamp: pallet_timestamp,
    Balances: pallet_balances,
    Aura: pallet_aura,
    Dpos: pallet_dpos,
  }
);
```

---v

### `construct_runtime`

- `struct Runtime` is autogenerated for you.
- It implements [A LOT OF STUFF](https://paritytech.github.io/substrate/master/kitchensink_runtime/struct.Runtime.html)!
- But most importantly, the `Config` trait of all of your pallets ü´µüèª.

```rust
impl frame_system::Config for Runtime { .. }
impl pallet_timestamp::Config for Runtime { .. }
impl pallet_dpos::Config for Runtime { .. }
```

---v

### `construct_runtime`

```rust
// ‚úÖ
pallet_dpos::Pallet::<Runtime>::force_change_authorities(..);

// a normal pub function defined in
frame_system::Pallet::<Runtime>::block_number();
// a storage getter of a map.
frame_system::Pallet::<Runtime>::account(42u32);
frame_system::Account::<Runtime>::get(42u32);
```

---v

### `construct_runtime`

- The old syntax of this line was `pub enum Runtime` ü§¶‚Äç‚ôÇÔ∏è.
- In many tests, the convention is to write it as `pub enum Test` ü§Æ.

```rust
// üëÄ
pallet_dpos::Pallet::<Test>::force_change_authorities(..);

```

---v

### `construct_runtime`

```rust [3-5]
frame_support::construct_runtime!(
  pub struct Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic,
  {
    System: frame_system,
    Timestamp: pallet_timestamp,
    Balances: pallet_balances,
    Aura: pallet_aura,
    Dpos: pallet_dpos,
  }
);
```

---v

### `construct_runtime`

- Specify some types that are useful further down the road.
- `Block` vs `NodeBlock`?

Notes:

`UncheckedExtrinsic` is the final extrinsic type. What we called `BasicExtrinsic` in the week 2 assignment.

---v

### `construct_runtime`

```rust [7-11|7-12]
frame_support::construct_runtime!(
  pub struct Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic,
  {
    System: frame_system,
    Timestamp: pallet_timestamp,
    Balances: pallet_balances,
    Aura: pallet_aura,
    Dpos: pallet_dpos,
    <NameYouChoose>: path_to_crate,
  }
);
```

---v

### `construct_runtime`

- Crucially, under the hood, this generates:

<div>

```rust
type System = frame_system::Pallet<Runtime>;
type Balances = pallet_balances::Pallet<Runtime>;
..
type DPos = pallet_dpos::Pallet<Runtime>;
```

- Recall that `Runtime` implements `<T: Config>` of all pallets.

</div>
<!-- .element: class="fragment" -->

---v

### `construct_runtime`

```rust
// we can now simplify this:
pallet_dpos::Pallet::<Runtime>::force_change_authorities(..);
// into:
Dpos::force_change_authorities(..);

// ‚úÖ Similarly:
System::block_number();
System::account(42u32);
```

---v

### `construct_runtime`

- Next crucial piece of information that is generated is:

```rust
type AllPallets = (System, Balances, ..., Dpos);
```

- This is used in `Executive` to dispatch pallet hooks.

```rust
<AllPallets as OnInitialize>::on_initialize();
<AllPallets as OnInitialize>::on_finalize();
```

Question: What will be the order of `fn on_initialize()`?

Notes:

There's also `type AllPalletsWithoutSystem` and some other variants that are no longer

---v

### `construct_runtime`

- Generates some outer types:

  - `RuntimeCall` (see calls lecture)
  - `RuntimeEvent`
  - `RuntimeOrigin`
  - `GenesisConfig` (see hooks lecture)

- More about these in the Friday deep dive lecture!

---v

### `construct_runtime`

```rust
// somewhere in your pallet, called `my_pallet`
#[pallet::call]
impl<T: Config> Pallet<T> {
  fn transfer(origin: OriginFor<T>, from: T::AccountId, to: T::AccountId, amount: u128);
  fn update_runtime(origin: OriginFor<T>, new_code: Vec<u8>);
}
```

```rust
// expanded in your pallet
enum Call {
  transfer { from: T::AccountId, to: T::AccountId, amount: u128 },
  update_runtime { new_code: Vec<u8> },
}
```

<!-- .element: class="fragment" -->

```rust
// in your outer runtime
enum RuntimeCall {
  System(frame_system::Call),
  MyPallet(my_pallet::Call),
}
```

<!-- .element: class="fragment" -->

---v

### `construct_runtime`

```rust [7-9]
frame_support::construct_runtime!(
  pub struct Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic,
  {
    System: frame_system::{Pallet, Call, Config, Storage, Event<T>},
    Balances: pallet_balances::{Pallet, Call, Storage, Config<T>, Event<T>},
    Dpos: pallet_dpos,
  }
);
```

- Pallet parts, optional by default, can be made explicit.
- Omitting them will exclude them from the metadata, or the "outer/runtime types"

---v

### `construct_runtime`

```rust [7-9]
frame_support::construct_runtime!(
  pub struct Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic,
  {
    System: frame_system = 1,
    Balances: pallet_balances = 0,
    Dpos: pallet_dpos = 2,
  }
);
```

---v

### `construct_runtime`

Final thoughts:

- Order in the `construct_runtime` matters!
- Recall `integrity_test()` is called upon `construct_runtime`.

```sh
test mock::__construct_runtime_integrity_test::runtime_integrity_tests ... ok
```

---

# Part 2: Testing

---

## Testing and Mocks

A test requires a mock runtime, so we need to do a full `construct_runtime`..

.. but luckily, most types can be mocked üòÆ‚Äçüí®.

<!-- .element: class="fragment" -->

---v

### Testing and Mocks

- Let's look at the almighty system pallet to get some inspiration.

---v

### Testing and Mocks

```rust
impl frame_system::Config for Runtime {
  // type SS58Prefix: Get<u16>;
  type SS58Prefix = ();

  // type BaseCallFilter: Contains<Self::RuntimeCall>;
  type BaseCallFilter = frame_support::traits::Everything;

  // type RuntimeOrigin: Into<Result<RawOrigin<Self::AccountId>, Self::RuntimeOrigin>>
  type RuntimeOrigin = RuntimeOrigin; // <-- comes from construct_runtime

  // type RuntimeCall: Dispatchable<RuntimeOrigin = Self::RuntimeOrigin>
  type RuntimeCall = RuntimeCall; // <-- comes from construct_runtime

  // type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
  type RuntimeEvent = RuntimeEvent; // <-- comes from construct_runtime

  // type Version: Get<RuntimeVersion>;
  type Version = ();

  // type OnNewAccount: OnNewAccount<Self::AccountId>;
  type OnNewAccount = ();

  // type OnSetCode: SetCode<Self>;
  type OnSetCode = ();

  // type BlockHashCount: Get<Self::BlockNumber>;
  type BlockHashCount = frame_support::traits::ConstU32<128>;

  type Hashing = sp_runtime::traits::BlakeTwo256;
  type Hash = sp_core::H256;
  type Lookup = sp_runtime::traits::IdentityLookup<Self::AccountId>;
  type Header = sp_runtime::testing::Header;
  // This is rather detailed, come ask us if you want to know more!
  type AccountData = pallet_balances::AccountData<Balance>;

  type Index = u32;
  type BlockNumber = u32;
  type AccountId = u32;

  type DbWeight = (); // Get<_>
  type BlockLength = (); // Get<_>
  type BlockWeights = (); // Get<_>
  type PalletInfo = PalletInfo;
  type OnKilledAccount = ();
  type SystemWeightInfo = ();
  type MaxConsumers = frame_support::traits::ConstU32<16>;
}
```

---v

### Testing and Mocks

- Types can be mocked to something reasonable:

* `u32` account id.
* `u128` balance.
* `u32` block number.
* ...

---v

### Testing and Mocks

- Next, we want to supply some value to those `Get<_>` associated types.
- Assume:

```rust
#[pallet::config]
pub trait Config: frame_system::Config + pallet_aura::Config {
  type Currency: ...
  type MinimumDelegation: Get<BalanceOf<Self>>;
}
```

---v

### Testing and Mocks

```rust
impl pallet_balances::Config for Runtime {
  type Balance = u128;
  ...
}
```

```rust
parameter_types! {
  pub const MinimumDelegationValue: u128 = 100;
}
```

<!-- .element: class="fragment" -->

```rust
impl pallet_dpos::Config for Runtime {
  type MinimumDelegation = MinimumDelegationValue;
  ...
}
```

<!-- .element: class="fragment" -->

---v

### Testing and Mocks

- Or, if your value is always constant:

```rust
impl pallet_dpos::Config for Runtime {
  type MinimumDelegation = frame_support::traits::ConstU128<100>;
  ...
}
```

---v

### Testing and Mocks

- Or, if you want to torture yourself:

```rust
pub struct MinimumDelegationValue;
impl Get<u32> for MinimumDelegationValue {
  fn get() -> u32 {
    100
  }
}

impl pallet_dpos::Config for Runtime {
  type MinimumDelegation = MinimumDelegationValue;
  ...
}
```

---v

### Testing and Mocks

- Next, if you want to feed some data into your pallet's genesis state, we must first setup the
  genesis config correctly.

```rust
#[pallet::genesis_config]
pub struct GenesisConfig<T: Config> {
  initial_validators: Vec<T::AccountId>
}

#[pallet::genesis_build]
impl<T: Config> GenesisBuild<T> for GenesisConfig<T> {
  fn build(&self) {
    for validator in self.initial_validator {
      // bond them, stuff, blah blah
    }
  }
}
```

---v

### Testing and Mocks

- Then, we build a builder pattern to construct the genesis config.

```rust
// assuming:
type AccountId = u32;

#[derive(Default)]
pub struct Builder {
  initial_validators: Vec<AccountId>,
}
```

```rust
impl Builder {
  fn add_validator(mut self, v: AccountId) -> Self {
    self.initial_validators.push(v);
    self
  }
}
```

<!-- .element: class="fragment" -->

---v

### Testing and Mocks

- Finally, we provide a `fn build(self) -> TestExternalities`.

```rust
impl Builder {
  fn build(self) -> sp_io::TestExternalities {
    let mut storage =
      frame_system::GenesisConfig::default().build_storage::<Runtime>().unwrap();

    let _ = pallet_dpos::GenesisConfig::<Runtime> {
      initial_validators: self.initial_validators,
    }
    .assimilate_storage(&mut storage);

    // assimilate_storage the genesis of other pallets if needed...

    let mut ext = sp_io::TestExternalities::from(storage);
  }
}
```

---v

### Testing and Mocks

- Finally, this allows you to write a test like this:

```rust
#[test]
fn test_stuff() {
  let mut ext = Builder::default()
    .add_validator(1)
    .add_validator(2)
    .build();
  ext.execute_with(|| {
    // do stuff
  });
}
```

---v

### Testing and Mocks

- What if you want to change that `MinimumDelegation`?

<div>

```rust
parameter_types! {
  pub static MinimumDelegation: u128 = 100;
}
```

- Gives us:

```rust
MinimumDelegation::set(200);
MinimumDelegation::get();
```

</div>

---v

### Testing and Mocks

- With that in mind:

```rust
impl Builder {
  fn set_minimum_delegation(self, v: u128) -> Self {
    MinimumDelegation::set(v);
    self
  }
}
```

---v

### Testing and Mocks

```rust
#[test]
fn test_stuff() {
  let mut ext = Builder::default()
    .add_validator(1)
    .set_minimum_delegation(200)
    .build();
  ext.execute_with(|| {
    // do stuff
  });
}
```

---v

### Testing and Mocks

- If you want to run some code post-every test? no worries!

```rust
pub(crate) fn build_and_execute(self, test: impl FnOnce() -> ()) {
  self.build().execute_with(|| {
    test();
    // now check that your pallet's state is sane!
    assert!(true);
  })
}
```

---

### Progressing Blocks

- Often times, in your test, you want mimic the progression of an empty block.
- De-nada!
  - Set the block number in system.
  - call into `on_finalize(now)` of any pallet in your mock runtime.
  - (and perhaps `on_idle` etc.)
  - call into `on_initialize`(now+1)` of any pallet in your mock runtime.
  - Now your pallet is in a state to call into its transactions.

---v

### Progressing Blocks

```rust
#[test]
fn test() {
  let mut ext = Builder::default()
    .add_validator(1)
    .set_minimum_delegation(200)
    .build();
  ext.execute_with(|| {
    // initial stuff
    next_block();

    // dispatch some call
    assert!(some_condition);

    next_block();

    // repeat..
  });
}
```

---v

### Progressing Blocks

```rust
pub fn next_block() {
  let now = System::block_number();
  Dpos::on_finalize(now);
  System::on_finalize(now);
  ...
  System::set_block_number(now + 1);
  System::on_initialize(now + 1)
  Dpos::on_initialize(now + 1);
}
```

---v

### Progressing Blocks

```rust
pub fn next_block() {
  let now = System::block_number();
  AllPallets::on_finalize(now);
  System::set_block_number(now + 1);
  AllPallets::on_initialize(now + 1)
}
```

---

# Additional Resources üòã

Notes:

- This PR was actually an outcome Cambridge PBA: https://github.com/paritytech/substrate/pull/11932
- https://github.com/paritytech/substrate/pull/11818
- https://github.com/paritytech/substrate/pull/10043
- On usage of macros un Substrate: https://github.com/paritytech/substrate/issues/12331
- Reserve topic: Reading events.
- Reserve-topic: try-state.

### Original Lecture Script

this is your bridge from a pallet into a runtime.

a runtime amalgamator is composed of the following:

1. all pallet's `Config` implemented by a `struct Runtime`;
2. construct `Executive` and use it to implement all the runtime APIs
3. Optionally, some boilerplate to setup benchmarking.
4. invoke `construct_runtime!`.
5. Alias for each pallet.

The `construct_runtime!` itself does a few things under the hood:

1. crate `struct Runtime`.
2. amalgamate `enum RuntimeCall`; // passed inwards to some pallets that want to store calls.
3. amalgamate `enum RuntimeEvent`; // passed inwards to all pallets.
4. amalgamate `enum RuntimeOrigin` (this is a fixed struct, not an amalgamation);
5. Create a very important type alias:

- `type AllPallets` / `type AllPalletsWithoutSystem`

6. run `integrity_test()`.

> Note that there is no such thing as `RuntimeError`. Errors are not amalgamated, they just are. This should be in the error lecture.

- Ordering in `construct_runtime` matters.
- Pallet parts can be optional in `construct_runtime!`.
