<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Introduction to Polkadot</title>
  <link rel="icon" href="./../../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../../dist/reset.css" />
  <link rel="stylesheet" href="./../../../dist/reveal.css" />
  <link rel="stylesheet" href="./../../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

<!-- .slide: data-background-color="#000" -->

# Introduction to Polkadot
</script></section><section  data-markdown><script type="text/template">
## What is Polkadot?

> Polkadot is a scalable, heterogeneous, sharded, multi-chain network.

> Polkadot is a permissionless and ubiquitous computer

> Polkadot is a decentralized open-source community

> Polkadot is a digital-native sovereign network
</script></section><section  data-markdown><script type="text/template">
## Environment

Polkadot has many faces, both technical and social.

It is the real-world instantiation of the technology described within this module.

These technologies only define the limits of the environment.
Polkadot is everything which happens within it.
</script></section><section  data-markdown><script type="text/template">
### Agents

Within the environment, various types of agents may take action according to its rules.

These may be human users, silicon users, governments, or legal entities.

They likely have different agendas and activity levels, and may be located anywhere in the world.

Polkadot is an online economy for smart agents.
</script></section><section  data-markdown><script type="text/template">
### Games

Polkadot fulfills its goals with a combination of mechanisms and games which provide incentives and disincentives for nodes to work together and construct this environment.
</script></section><section  data-markdown><script type="text/template">
### All Together

<img rounded width="1200px" src="../assets/gav_header_photo.jpg" />

<aside class="notes"><p>source: banner image from <a href="https://twitter.com/gavofyork">https://twitter.com/gavofyork</a> <!-- markdown-link-check-disable-line --></p>
</aside></script></section><section  data-markdown><script type="text/template">
## Goals of the Environment

1. Real-time, secure, global consensus on system state
1. Trustless, censorship-resistant, and permissionless transaction at scale
1. Explicit network-wide governance and co-evolution
1. General programmable computation with full security
1. Secure and trust-minimized interoperability between processes
</script></section><section  data-markdown><script type="text/template">
## Goals: Breakdown

> (1) Real-time, secure, global consensus on system state

Polkadot's state should update as close to real-time as possible.

A global, unique history of everything that has happened is maintained.

<aside class="notes"><p>State consisting of account balances, chains, governance votes, etc.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Goals: Breakdown

> (2) Trustless, censorship-resistant, and permissionless transaction at scale

Only a private key and a balance is needed to interact with the network, and without trusting any single third party.

It aims to do so at high scale.
</script></section><section  data-markdown><script type="text/template">
## Goals: Breakdown

> (3) Explicit network-wide governance and co-evolution

Polkadot stakeholders explicitly govern and evolve the network,<br/>with the ability to set new rules.
</script></section><section  data-markdown><script type="text/template">
## Goals: Breakdown

> (4) General programmable computation with full security

Polkadot is extended by general programs, usually taking the form of blockchains which themselves may be programmable environments.

Generalized computation allows the capabilities of the network to be extended arbitrarily, while inheriting the full security of the network.
</script></section><section  data-markdown><script type="text/template">
## Goals: Breakdown

> (5) Secure and trust-minimized interoperability between processes

Processes deployed on Polkadot need to:

<pba-flex center>

- Communicate with each other.
- "Trade" with each other without entirely trusting them.
- Protect trade routes and enforced trade agreements.

</pba-flex >
</script></section><section  data-markdown><script type="text/template">
## Validators

Validators decide to participate in the upkeep of the network.

Validators participate in the core **games** of Polkadot.
</script></section><section  data-markdown><script type="text/template">
## Validators

Validators are _incentivized_ to do things like put user transactions in blocks or contribute to other activities, but may opt out of many of these tasks.

Validators are strongly punished for explicitly doing their job wrongly.

The games work as long as enough validators are doing their job<br/>and also not misbehaving.
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#000" -->

# Polkadot Architecture

<aside class="notes"><p>A high level look into the architecture of Polkadot and the actors which maintain the network.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Polkadot: Major Systems

<img rounded width="800px" src="../assets/polkadot-components.svg" />
</script></section><section  data-markdown><script type="text/template">
Validators are made to provide accurate execution for processes deployed on top of Polkadot.

These processes, defined as WebAssembly Code, are colloquially known as **parachains**.

Polkadot scales by sharing the load of validating these parachains across many validators.
</script></section><section  data-markdown><script type="text/template">
<img rounded width="700px" src="../assets/polkadot-architecture.svg" />
</script></section><section  data-markdown><script type="text/template">
<img rounded width="900px" src="../assets/polkadot-architecture-simple.png" />

<aside class="notes"><p>Simplified Polkadot Architecture (Parachains)</p>
</aside></script></section><section  data-markdown><script type="text/template">
## The Relay Chain

The relay chain is the "hub" of Polkadot, providing the main games which validators play.
It is built with Substrate.

Notably, the functionality of the relay chain is minimized,<br/>with the expectation that more complex functionalities will be pushed to less critical parts of the system.
</script></section><section  data-markdown><script type="text/template">
## Relay Chain Functionality:

<pba-flex center>

- Governance (moving to parachain)
- Staking
- Registration, scheduling,<br/>and advancement of parachains
- Communication between parachains
- Consensus Safety
- Balance Transfers

</pba-flex>
</script></section><section  data-markdown><script type="text/template">
## Relay Chain Games:

The Relay Chain consists of two key games:

<pba-flex center>

- Relay Chain Consensus
- Parachain Consensus

</pba-flex>

These games are the enablers of all activity within Polkadot.
</script></section><section  data-markdown><script type="text/template">
## Game: Relay Chain Consensus (simplified)

<div style="font-size: 0.8em">

<pba-flex left>

**Goal:**

- Grow and finalize the relay chain, comprised of only valid blocks

</pba-flex>
<pba-flex left>

**Rules:**

</pba-flex>

- Validators put skin in the game in the form of tokens.
- Validators are incentivized to make new relay chain blocks (BABE)
- Validators are incentivized to vote to finalize recent relay chain blocks (GRANDPA)
- Validators are incentivized to include user transactions in their relay chain blocks.
- Validators get nothing for building bad blocks or building on top of them.
- Validators are slashed for making blocks out of turn.

</div>

<br/>

**The game works whenever <1/3 of validators misbehave.**
</script></section><section  data-markdown><script type="text/template">
## Game: Parachain Consensus (simplified)

<div style="font-size: 0.8em">

<pba-flex left>

**Goal:**

- Grow registered parachains and post only valid updates to the Relay Chain

</pba-flex>
<pba-flex left>

**Rules:**

</pba-flex>

- Validators are incentivized to attest to new parachain updates
- Whichever Validator makes the next Relay Chain block includes some attested parachain updates
- Validators are slashed if they attest to incorrect parachain updates
  - incorrect means "not according to the parachain's Wasm code"
- Validators check each others' work to initiate the slashing procedure

</div>

<br/>

**The game works whenever <1/3 of validators misbehave.**
</script></section><section  data-markdown><script type="text/template">
All other functionalities of the relay chain (staking, governance, balances, etc.) are just baked into the definition of **valid block** and **valid transaction**.
</script></section><section  data-markdown><script type="text/template">
## Staking: Nominated Proof-of-Stake

As the Relay Chain progresses, it operates a system for selecting and accruing capital behind validators.

Accounts on Polkadot may issue a "nominate" transaction to select validators they support.
Every day, an automated election selects the validators for the next 24 hours.

Nominators share in both the reward and slashing of their nominees.
</script></section><section  data-markdown><script type="text/template">
## Message Passing: Trustless Communication

The Relay Chain manages message queues and channels between parachains, as well as between each parachain and the Relay Chain itself.

Part of the Validators' job is to ensure that message queues are properly maintained and updated.
</script></section><section  data-markdown><script type="text/template">
## Registering Parachains

In 1.0: this is done via Slot Auctions to get a large bulk allocation

In the future: this will be done on a more granular / ad-hoc basis
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#000" -->

## Governance & Evolution
</script></section><section  data-markdown><script type="text/template">
## OpenGov

Polkadot has on-chain governance by stakeholder referendum, voting on subjects such as:

<pba-flex center>

- Forkless upgrades of the network
- Administration of the Treasury funds
- Configuration of the Parachains protocol
- Configuration of fees
- Rescue & recovery operations
- All other mechanisms of control over the platform

</pba-flex>

<aside class="notes"><p><a href="https://polkadot.network/features/opengov/">https://polkadot.network/features/opengov/</a></p>
</aside></script></section><section  data-markdown><script type="text/template">
## Treasury

<pba-flex center>

- Polkadot ensures that a portion of network fees are collected treasury.
- The treasury is managed by governance.
- Tokens are burned if they are not spent.

</pba-flex>
<br/>

The intention of the treasury is to pay people to help grow Polkadot itself.
As tokens are burned, this creates pressure to fund public projects.
</script></section><section  data-markdown><script type="text/template">
### The Fellowship

A collective of developers, coordinated through on-chain activities.

These are node maintainers, developers, or researchers.

They set the technical direction for the network through RFCs.
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#111" -->

<pba-cols>

<img rounded width="400px" src="../assets/rfc_1.png" />
<img rounded width="400px" src="../assets/rfc_3.png" />
<img rounded width="400px" src="../assets/rfc_10.png" />

</pba-cols>
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#000" -->

## Revisiting Goals
</script></section><section  data-markdown><script type="text/template">
> (1) Real-time, secure, global consensus on system state

This is provided by the validators participating in **Relay Chain Consensus**.
Every block they make and finalize advances the system state.
</script></section><section  data-markdown><script type="text/template">
> (2) Trustless and permissionless transaction at scale

"at scale" is the caveat that drives most of the engineering in Polkadot.

Polkadot scales by virtue of the **Parachain Consensus** game, where the parachains themselves process most of the transactions in the network.

The more efficiently this game is implemented, the more Polkadot scales.
</script></section><section  data-markdown><script type="text/template">
> (3) Explicit network-wide governance and co-evolution

This is handled by OpenGov and the Treasury.
Polkadot is a "meta-protocol" where OpenGov can update anything in the network, including the network's own rules.
</script></section><section  data-markdown><script type="text/template">
> (4) General programmable computation with full security

This is provided by the **Parachain Consensus** game, as most parachains are registered by users and validators are on the hook for valid updates.

Parachains themselves may also provide generalized computational functionality, e.g. EVM contracts.
</script></section><section  data-markdown><script type="text/template">
> (5) Secure and trust-minimized interoperability between processes

The Relay Chain maintains message queues between chains to provide interoperability (protected trade routes), however, full trust-minimization (enforced trade agreements) requires future protocol features to land.
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#000" -->

## At Scale: Polkadot's Value Proposition
</script></section><section  data-markdown><script type="text/template">
## From This

<img rounded width="600px" src="../assets/terrarium_bottle.jpg" />
</script></section><section  data-markdown><script type="text/template">
## To This

<img rounded width="800px" src="../assets/amazon_terrarium.jpg" />
</script></section><section  data-markdown><script type="text/template">
## Blockchain Scalability Trilemma

<pba-cols>
<pba-col>
<pba-flex center>

1. Security: how much does it _cost_ to attack the network?
1. Scalability: how much work can the network do?
1. Decentralization: how decentralized is the network?

</pba-flex>
</pba-col>
<pba-col>

<img rounded width="800px" src="../assets/scalability-trilemma.svg" />

</pba-col>
</pba-cols>

Challenge: Scale while navigating the trilemma.
</script></section><section  data-markdown><script type="text/template">
## Scaling vs. Scheduling

Scaling is important, but resources must be _allocated_ efficiently to make best use of that.

Polkadot allocates its resources to parachains through **Execution Cores**.
</script></section><section  data-markdown><script type="text/template">
## Execution Cores

Just like a decentralized CPU, Polkadot multiplexes many processes across cores.

When a parachain is assigned to a core, it can advance.<br/>
Otherwise, it lies dormant.

Execution Cores enable efficient allocation through _Coretime_ trading.
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#000000" -->

## One Chain Per Core

<img rounded width="1000px" src="../assets/dumb_coretime.png" />

Time -->
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#000000" -->

## Execution Cores: Endgame

<img rounded width="1000px" src="../assets/smart_coretime.png" />

Time -->
</script></section><section  data-markdown><script type="text/template">
## Coretime: Polkadot's Product

Coretime is what applications buy to build on Polkadot.<br/>
Goal: be like cloud.

Primary and secondary markets are key enablers.

Scalability + Scheduling
</script></section><section  data-markdown><script type="text/template">
## Full Circle

> Polkadot is a scalable, heterogeneous, sharded, multi-chain network.

> Polkadot is a permissionless and ubiquitous computer

> Polkadot is a decentralized open-source community

> Polkadot is a digital-native sovereign network
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#4A2439" -->

# Questions
</script></section>
    </article>
  </main>

  <script src="./../../../dist/reveal.js"></script>

  <script src="./../../../plugin/markdown/markdown.js"></script>
  <script src="./../../../plugin/highlight/highlight.js"></script>
  <script src="./../../../plugin/zoom/zoom.js"></script>
  <script src="./../../../plugin/notes/notes.js"></script>
  <script src="./../../../plugin/math/math.js"></script>

  <script src="./../../../assets/plugin/mermaid.js"></script>
  <script src="./../../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../../assets/plugin/chart/chart.js"></script>
  <script src="./../../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
