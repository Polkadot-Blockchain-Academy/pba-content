<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Dealing with real-time data</title>
  <link rel="icon" href="./../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../dist/reset.css" />
  <link rel="stylesheet" href="./../../dist/reveal.css" />
  <link rel="stylesheet" href="./../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section ><section data-markdown><script type="text/template">

# Real-Time Data
</script></section><section data-markdown><script type="text/template">
## Why Concurrency is Hard

- We're used to think synchronously
- Combining synchronous code with async code is harder
- Things to look for
  - Race conditions
  - Data overwrites
  - Backpressure
- ~9% of bugs are due to concurrency
  - Hard to reproduce
  - Hard to debug

<aside class="notes"><p><a href="https://arxiv.org/abs/2103.12447">https://arxiv.org/abs/2103.12447</a></p>
</aside></script></section><section data-markdown><script type="text/template">
## Why Real-Time Data is Hard

- Concurrency is everywhere
- More things to look for
  - Missed updates
  - Multiple sources of truth
  - Even more backpressure and resource limits
</script></section><section data-markdown><script type="text/template">
## Find the bug

```tsx
const Balance: FC<{ address: string }> = ({ address }) => {
  const [balance, setBalance] = useState(null);

  useEffect(() => {
    // Set to loading
    setBalance(null);
    // Load and display the balance
    loadBalance(address, result => setBalance(result));
  }, [address]);

  if (balance == null) {
    return <div>Loadingâ€¦</div>;
  }

  return (
    <div>
      Balance of {address}: {balance}
    </div>
  );
};
```

<aside class="notes"><p>Notice how reproducing this bug is hell.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Concepts

### Synchronous code

```ts
function calculateAverage(winnings: number) {
  const sum = winnings.reduce((a, b) => a + b, 0);
  return sum / winnings.length;
}
```

### Asynchronous code

```ts
function getAverage() {
  return fetch("/winnings").then(winnings => {
    return calculateAverage(winnings);
  });
}

// Or
async function getAverage() {
  const winnings = await fetch("/winnings");
  return calculateAverage(winnings);
}
```
</script></section><section data-markdown><script type="text/template">
## Concepts

<pba-cols style="font-size: 0.8em">
<pba-col>

### Concurrency

- Multiple tasks to execute simultaneously
- One single thread of execution
- Pause at specific points to work on another task
- No shared-memory races

</pba-col>
<pba-col>

### Parallelism

- Multiple threads execute tasks simultaneously
- Shared memory access
- Locks/mutexes
- Message passing

</pba-col>
</pba-cols>
</script></section></section><section ><section data-markdown><script type="text/template">
## JavaScript Concurrency Model
</script></section><section data-markdown><script type="text/template">
### Single-Threaded Event Loop

- JS uses event loop
  - Macrotasks: I/O, `setTimeout`
  - Microtasks: `Promise.then`, `queueMicrotask`
- No multithreading by default
  - Available through WebWorkers
</script></section><section data-markdown><script type="text/template">
### Event Loop in Action

```ts
console.log("start");

setTimeout(() => console.log("timeout"), 0);

Promise.resolve().then(() => console.log("promise.then"));

console.log("end");

// Logs: ?
```

```ts
// start
// end
// promise.then
// timeout
```

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Event Loop in Action

```ts
const promiseSomewhereElse = Promise.resolve(123);

async function doStuff() {
  console.log("doStuff");

  const value = await promiseSomewhereElse;

  console.log("result", value);
}

setTimeout(() => console.log("timeout"), 0);
Promise.resolve().then(() => console.log("promise.then"));
doStuff();

// Logs: ?
```

```ts
// doStuff
// promise.then
// result 123
// timeout
```

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Re-entrant calls

```ts
function createCounter(onFirstIncrement: () => void) {
  let count = 0;
  return () => {
    count++;
    if (count === 1) {
      onFirstIncrement();
    }
    console.log("incremented to " + count);
  };
}

const increment = createCounter(() => {
  // Trigger another increment when the first one happens;
  increment();
});
increment();
```

Everything is synchronous, yet it can also have unexpected effects.
</script></section><section data-markdown><script type="text/template">
### Key take-_awaits_

- Synchronous blocks are not interrupted
  - Watch out for re-entrant calls!
- JS uses the event loop to schedule the tasks
  - Macrotasks: I/O, `setTimeout`
  - Microtasks: Promises
- The event loop runs all microtasks before starting a new macrotask
</script></section></section><section ><section data-markdown><script type="text/template">
## Let's dive Async
</script></section><section data-markdown><script type="text/template">
### Pull vs Push

<pba-cols style="font-size: 0.8em">
<pba-col>

<!-- prettier-ignore -->
```ts
let lastValue = null;
while (keepWatching) {
  const value = await typedApi
    .query.System.Account
    .getValue(ACCOUNT_ID);

  if (value !== lastValue) {
    console.log("new value", value);
  }
  lastValue = value;

  await waitMs(1000);
}
```

</pba-col>
<pba-col>

<!-- prettier-ignore -->
```ts
typedApi
  .query.System.Account
  .watchValue(ACCOUNT_ID)
  .subscribe(value => {
    console.log("new value", value);
  })
```

</pba-col>
</pba-cols>
</script></section><section data-markdown><script type="text/template">
<pba-cols style="font-size: 0.8em">
<pba-col>

### Pull

Consumer decides when to get the value

</pba-col>
<pba-col>

### Push

Producer notifies of new changes

</pba-col>
</pba-cols>
</script></section><section data-markdown><script type="text/template">
### JSON-RPC Spec

- ChainHead Events: <span class="fragment">Push-based</span>
- Operations: <span class="fragment">Push/pull?</span>
  - Low-level: Push <!-- .element: class="fragment" --->
  - High-level: Pull <!-- .element: class="fragment" --->
  - Higher-level: Push ðŸ¤¯ <!-- .element: class="fragment" --->

<aside class="notes"><p>Events (new block, finalized, etc) are push-based, the node notifies us when a new block is produced
Operations depend on the level we&#39;re looking at.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Working Async

- Push is asynchronous
- Pull can be sync or async
- Ancient JS (2014-) used callbacks for async code

```ts
// Ancient JS Pull
api.query.System.Account.getValue(ACCOUNT_ID, (error, result) => {
  if (error) {
    return console.error("oh no!");
  }
  console.log("Result", result);
});

// Ancient JS Push
api.query.System.Account.watchValue(
  ACCOUNT_ID,
  value => {
    console.log("Value", value);
  },
  error => console.error("oh no!")
);
```

<aside class="notes"><p>In our context, pull is async. If you need the storage, you have to make a request to the node to pull it out for you.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Enter Promises ðŸŒˆ

- Technically still using callbacks.
- Common interface, allows composability.
- Removes "callback hell"
- 2017+ enhanced language: async/await
- Works great for pull operations: fetch
</script></section><section data-markdown><script type="text/template">
### And for push?

ðŸ˜ž <!-- .element: class="fragment" --->

<div class="fragment">

Async generators?

```ts
// async generator API
const account = api.query.System.Account.watchValue(ACCOUNT_ID);

for await (const value of account) {
  console.log(value);
}
```

But that's pull!

</div>
</script></section><section data-markdown><script type="text/template">
### Enter Observables ðŸŒˆ

- Promise but for multiple values
- Common interface, composable
- Removes "callback hell"
- Convertible to promises
- TC-39 Stage 1 <span style="color: darkgray" class="fragment">(big copium)</span>
- Meanwhile rxjs <!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Observables 101

```ts
import { Observable } from "rxjs";

// Emit one value every second up to 10
const observable$ = new Observable<number>(subscriber => {
  let v = 0;

  const token = setInterval(() => {
    const valueToEmit = v;
    v++;
    subscriber.next(valueToEmit);
    if (valueToEmit === 10) {
      subscriber.complete();
    }
  }, 1000);

  return () => clearInterval(token);
});
```
</script></section><section data-markdown><script type="text/template">
### Observables 101

```ts
observable$.subscribe(value => {
  console.log(value);
});

observable$.subscribe({
  next: value => console.log(value),
  error: error => console.error(error),
  complete: () => console.log("completed"),
});
```

<aside class="notes"><p>Showcase / demo how observables are cold by default</p>
<p>Notice how the cold behaviour also helps avoid re-entrant subscriptions by design. They become relevant only when creating shared observables.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Composing Observables

Operator: `(source: Observable<T>) => Observable<R>`

<!-- prettier-ignore -->
```ts
const map =
  <T, R>(mapFn: (value: T) => R) =>
  (source: Observable<T>) =>
    new Observable<R>(subscriber => {
      const subscription = source.subscribe({
        next: v => subscriber.next(mapFn(v)),
        error: e => subscriber.error(e),
        complete: () => subscriber.complete(),
      });

      return subscription;
    });

const multipliedBy2$ = observable$.pipe(
  map(v => v * 2)
);
// Same as map(v => v * 2)(multipliedBy2$)
```
</script></section><section data-markdown><script type="text/template">
### Composing Observables

Pipe-ing

```ts
import { interval, map, take } from "rxjs";

// Create an observable of the first 10 even numbers, one second at a time.
const even$ = interval(1000).pipe(
  map(v => v * 2),
  take(10)
);
```
</script></section><section data-markdown><script type="text/template">
### Operators

- `combineLatest`, `merge`, `switchMap`, etc.
- Endless list: https://rxjs.dev/guide/operators#creation-operators-1
- Good resource: https://www.learnrxjs.io/learn-rxjs/operators
</script></section><section data-markdown><script type="text/template">
### Operators

```ts
const take =
  <T, R>(amount: number) =>
  (source: Observable<T>) =>
    new Observable<R>(subscriber => {
      // TODO

      const subscription = source.subscribe({
        next: v => {
          // TODO
        },
        error: e => subscriber.error(e),
        complete: () => subscriber.complete(),
      });

      return () => {
        // TODO
      };
    });
```

<aside class="notes"><p>&quot;firehose&quot; problem.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Observable â†” Promise

```ts
import { firstValueFrom, lastValueFrom, from, defer } from "rxjs";
const firstValue = await firstValueFrom(observable$);
const lastValue = await lastValueFrom(observable$);

const observable$ = from(fetch("â€¦"));
const observable$ = defer(() => fetch("â€¦"));
```

<aside class="notes"><p>It&#39;s important to keep in mind what these functions do: both firstValueFrom and lastValueFrom subscribe to the observable, and then unsubscribe.</p>
<p>Difference between from and defer.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Polkadot Chains

- Pull
  - Constants (metadata)
  - Runtime APIs
  - Storage query
- Push
  - Blocks
  - Storage watch
  - Transactions

<aside class="notes"><p>Pull operations: Easier to offer promises
Push: Observables all the way.</p>
<ul>
<li>Blocks: finalized$</li>
</ul>
<p>Why transactions are &quot;push&quot;?</p>
</aside></script></section><section data-markdown><script type="text/template">
### Flattening observables

`switchMap` vs `mergeMap` vs `concatMap` vs `exhaustMap`

<aside class="notes"><p>Another practice, with simulated scenarios:</p>
<ul>
<li>Live search<ul>
<li>A new input change should cancel the previous request</li>
</ul>
</li>
<li>Image upload<ul>
<li>Images can be uploaded in parallel</li>
<li>Simplify: Just track how many were sent and how many were confirmed</li>
</ul>
</li>
<li>Publish a post<ul>
<li>Avoid sending new posts while it&#39;s being saved.</li>
</ul>
</li>
<li>Send transactions one after the other<ul>
<li>Made-up scenario is that only one transaction can be active at a moment.</li>
</ul>
</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
### Common Pain Points

- Repeated computations
  - With `combineLatest`
- Value-not-yet-there
  - With `withLatestFrom`
- Backpressure
  - Handling fast producers

<aside class="notes"><p>exercise with case <a href="https://github.com/ReactiveX/rxjs/discussions/6605">https://github.com/ReactiveX/rxjs/discussions/6605</a></p>
</aside></script></section></section>
    </article>
  </main>

  <script src="./../../dist/reveal.js"></script>

  <script src="./../../plugin/markdown/markdown.js"></script>
  <script src="./../../plugin/highlight/highlight.js"></script>
  <script src="./../../plugin/zoom/zoom.js"></script>
  <script src="./../../plugin/notes/notes.js"></script>
  <script src="./../../plugin/math/math.js"></script>

  <script src="./../../assets/plugin/mermaid.js"></script>
  <script src="./../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../assets/plugin/chart/chart.js"></script>
  <script src="./../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
