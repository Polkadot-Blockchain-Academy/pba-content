<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Cross-Chain Message Passing (XCMP)</title>
  <link rel="icon" href="./../../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../../dist/reset.css" />
  <link rel="stylesheet" href="./../../../dist/reveal.css" />
  <link rel="stylesheet" href="./../../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# XCMP: Cross Chain Message Passing
</script></section><section  data-markdown><script type="text/template">
Previous lectures discussed how Polkadot provides a secure environment for general code execution, and how it scales.
</script></section><section  data-markdown><script type="text/template">
This lecture is about how processes communicate within that environment.
</script></section><section  data-markdown><script type="text/template">
<img rounded width="1200px" src="../assets/large_environment.svg" />
</script></section><section  data-markdown><script type="text/template">
<img rounded width="1200px" src="../assets/small_environment.svg" />
</script></section><section  data-markdown><script type="text/template">
<img rounded width="1200px" src="../assets/small_environment_movement.svg" />
</script></section><section  data-markdown><script type="text/template">
<img rounded width="1200px" src="../assets/large_environment_movement.svg" />
</script></section><section  data-markdown><script type="text/template">
The Relay Chain Runtime maintains messaging queues for parachains.

It acts as a bridge for parachains to each other and to itself.
</script></section><section  data-markdown><script type="text/template">
To do this, it adds additional limitations to candidates to ensure messaging rules are respected.
</script></section><section  data-markdown><script type="text/template">
## XCMP in Practice
</script></section><section  data-markdown><script type="text/template">
## XCMP vs XCM

XCMP is the data layer, while XCM is the language.

XCMP only focuses on the transmission of raw bytes between chains.<br/>
In this lesson we will focus only on XCMP.

<img rounded width="400px" src="../assets/people-talking.jpg" />

<aside class="notes"><p>Communication requires a medium and a language to convey semantic meaning.
XCMP is the medium, like sound or writing, rather than the language.</p>
</aside></script></section><section  data-markdown><script type="text/template">
<img rounded width="1300px" src="../assets/messaging-kinds.svg" />
</script></section><section  data-markdown><script type="text/template">
Downward and Upward channels are implicitly available.

XCMP Channels must be explicitly opened.
</script></section><section  data-markdown><script type="text/template">
XCMP Channels are one-way, and for two-way communication two channels must be opened.
</script></section><section  data-markdown><script type="text/template">
## Using Messaging in Practice

This lesson is meant to communicate the underlying protocols and mechanics by which messages are sent and received.

In practice, these mechanisms are abstracted by the libraries you work with.
</script></section><section  data-markdown><script type="text/template">
## Revisiting PVFs and Outputs

<img rounded width="800px" src="../assets/PVF.svg" />

```rust
fn validate_block(ValidationParams) -> Result<ValidationResult, ValidationFailed>;
```
</script></section><section  data-markdown><script type="text/template">
## Validation Inputs

```rust
/// Parameters provided to a PVF for validation
pub struct ValidationParams {
	/// The parent parachain block's Head Data
	pub parent_head: HeadData,
	/// The Proof-of-Validity.
	pub pov: PoV,
	/// The current relay-chain block number.
	pub relay_parent_number: RelayChainBlockNumber,
	/// The relay-chain block's storage root.
	pub relay_parent_storage_root: Hash,
}
```

Here, note that the `relay_parent_storage_root` allows us to handle **Merkle Proofs** of the Relay Chain state within the parachain.
</script></section><section  data-markdown><script type="text/template">
## Validation Outputs

```rust
/// Outputs of _successful_ validation of a parachain block.
pub struct ValidationResult {
	/// The head-data produced as a result of execution.
	pub head_data: HeadData,
	/// Upward messages sent by the Parachain.
	pub upward_messages: Vec<UpwardMessage>,
	/// Outbound horizontal messages sent by the parachain.
	pub horizontal_messages: Vec<OutboundHrmpMessage>,
	/// Number of downward messages that were processed by the Parachain.
	///
	/// It is expected that the Parachain processes them from first to last.
	pub processed_downward_messages: u32,
	/// The mark which specifies the block number up to which all inbound HRMP messages are processed.
	pub hrmp_watermark: RelayChainBlockNumber,

	// ... more fields
}
```
</script></section><section  data-markdown><script type="text/template">
The `ValidationResult` is the output of successful PVF execution.

Validators are responsible for checking that the outputs are correct.
</script></section><section  data-markdown><script type="text/template">
## Unpacking Candidates
</script></section><section  data-markdown><script type="text/template">
Candidates are posted to the relay chain in their entirety - everything except for the PoV.
</script></section><section  data-markdown><script type="text/template">
## Candidate Breakdown

<pba-flex center>

1. Descriptor: defines inputs to the validation function
1. Commitments: expected outputs from the validation function

</pba-flex>
</script></section><section  data-markdown><script type="text/template">
```rust
pub struct CandidateDescriptor {
  /// Relay chain block hash
  pub relay_parent: RelayChainBlockHash,
  /// The hash of the PoV
  pub pov_hash: Hash,
  /// Parent head data hash.
  pub parent_hash: Hash,
  /// The unique ID of the parachain.
  pub para_id: ParaId,

  // .. a few more fields
}
```
</script></section><section  data-markdown><script type="text/template">
```rust
pub struct CandidateCommitments {
  /// Messages destined to be interpreted by the Relay chain itself.
  pub upward_messages: UpwardMessages,
  /// Horizontal messages sent by the parachain.
  pub horizontal_messages: HorizontalMessages,
  /// The head-data produced as a result of execution.
  pub head_data: HeadData,
  /// The number of messages processed from the DMQ.
  pub processed_downward_messages: u32,
  /// The mark which specifies the block number up to which all inbound HRMP messages are processed.
  pub hrmp_watermark: RelayChainBlockNumber,
}
```
</script></section><section  data-markdown><script type="text/template">
Notice the similarities to `ValidationOutputs`?
</script></section><section  data-markdown><script type="text/template">
<img rounded style="width: 1000px" src="../assets/block_contents.svg" />
</script></section><section  data-markdown><script type="text/template">
(Polkadot runtime, simplified)

```rust
// Relay chain drains, parachain posts
UpwardMessages: StorageMap<ParaId, Deque<Message>>;

// Relay chain posts, parachain drains
DownwardMessages: StorageMap<ParaId, Deque<Message>>;

// (sender, receiver)
// Sender posts, receiver drains
HrmpChannels: StorageMap<(ParaId, ParaId), Deque<Message>>;

```
</script></section><section  data-markdown><script type="text/template">
(in Polkadot runtime, simplified, inclusion pallet)

```rust
fn process_backed_candidate(CandidateDescriptor, CandidateCommitments) {
  let para_id = descriptor.para_id;

  assert!(is_scheduled_on_empty_core(para_id));
  assert!(descriptor.parent_hash == current_parachain_head);
  assert!(is_in_this_chain_recently(descriptor.relay_parent));

  // fails if too many
  assert!(check_upward(para_id, commitments.upward_messages).is_ok());

  // fails if too many or sending to a chain without a channel open.
  assert!(check_hrmp_out(para_id, commitments.hrmp_messages).is_ok());

  // fails if attempting to process more messages than exist.
  assert!(check_downward(para_id, commitments.processed_downward_messages).is_ok());

  // fails if the watermark is lower than the previous one.
  // updates all channels where this is a _receiver_.
  assert!(check_hrmp_in(para_id, commitments.hrmp_watermark).is_ok());
}
```
</script></section><section  data-markdown><script type="text/template">
Candidates can't be _backed_ unless they pass all these checks.

The relay chain block author is responsible for selecting candidates which pass these checks.
</script></section><section  data-markdown><script type="text/template">
Messages are not added to queues until the candidate is included (available).

This allows messages to be passed and acted upon before finality.
</script></section><section  data-markdown><script type="text/template">
If the candidate turns out to be bad, the whole relay chain is forked to a point before messages were queued or acted upon.
</script></section><section  data-markdown><script type="text/template">
## Parachain Host Configuration

```rust
pub struct HostConfiguration {
  // ... many many fields
}

// In Polkadot runtime storage:
CurrentConfiguration: StorageValue<HostConfiguration>;
```

These variables are updated by governance.
</script></section><section  data-markdown><script type="text/template">
The host configuration specifies things like:

- How many messages can be in the upward, downward, or HRMP queues for a parachain
- How many bytes can be in the upward, downward, or HRMP queues for a parachain
- How large a single message can be in the upward, downward, or HRMP queues.
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#000" -->

## What are messages?
</script></section><section  data-markdown><script type="text/template">
Messages are just `Vec<u8>` byte strings.
</script></section><section  data-markdown><script type="text/template">
The Relay Chain interprets upward messages as XCM.

The main takeaway for now is that it allows parachains to execute `Call`s on the Relay Chain.
</script></section><section  data-markdown><script type="text/template">
```rust
// Act as a regular account with a deterministic ID based
// on the Para ID.
Origin::Signed(AccountId),
// Act as the parachain itself, for calls which may be made by parachains.
// Custom origin type added to the Relay Chain.
Origin::Parachain(ParaId),
```

<aside class="notes"><p>When parachains execute <code>Call</code>s on the Relay Chain, they have access to two origin kinds.</p>
<p>Note that this is only the case for the Relay Chain and parachains messages may be interpreted differently on other chains.</p>
</aside></script></section><section  data-markdown><script type="text/template">
Parachains are free to interpret their incoming downward or HRMP messages however they like.
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#000" -->

## Respecting Limits
</script></section><section  data-markdown><script type="text/template">
Problem: Parachain candidates can't be backed unless they respect the constraints on sending & receiving messages. How do they ensure this?
</script></section><section  data-markdown><script type="text/template">
Solution: PVFs can _read relay chain state_ to find out these limits. They include these proofs in the PoV.
</script></section><section  data-markdown><script type="text/template">
```rust
/// Parameters provided to a PVF for validation
pub struct ValidationParams {
	/// The relay-chain block's storage root.
	pub relay_parent_storage_root: Hash,
	pub pov: PoV,

	// ...
}
```
</script></section><section  data-markdown><script type="text/template">
```rust
fn validate_block(ValidationParams) -> Result<ValidationResult, ValidationFailed> {
  // simplified
  let storage_proof = extract_storage_proof(pov);

  // state of queues, and subset of `HostConfiguration`.
  let (message_queues, current_config) = check_storage_proof(
    relay_parent_storage_proof,
    storage_proof,
  )?;

  // process incoming messages and send outgoing while respecting limits in config.
}
```
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#000" -->

## Opening Channels
</script></section><section  data-markdown><script type="text/template">
The protocol for opening an HRMP channel is as follows:

<pba-flex center>

1. Chain A sends an upward message requesting a channel to Chain B
1. Chain B receives a downward message notifying of the channel request
1. Chain B sends an upward message accepting or rejecting the channel
1. The channel is either opened or rejected in the Relay Chain as a result

</pba-flex>
</script></section><section  data-markdown><script type="text/template">
There are no fees for XCMP messages, but every channel comes with a `max_capacity` and `max_message_size`.

Each channel comes with a corresponding _deposit_ of DOT tokens to pay for the relay chain state utilization.

This deposit is returned when the channel is closed.
</script></section><section  data-markdown><script type="text/template">
<img rounded width="1000px" src="../assets/hrmp-channel.svg" />
</script></section><section  data-markdown><script type="text/template">
## Message Queue Chains (MQC)

Let's take a small detour into a data structure used in DMP and XCMP.

**Problem**: Parachains should be able to cheaply determine the state of the entire message queue.

**Problem**: Relay Chain state proofs are expensive and should be minimized.

Solution: Message Queue Chains (MQC)
</script></section><section  data-markdown><script type="text/template">
## MQC Architecture

<img rounded width="700px" src="../assets/mqc.svg" />
</script></section><section  data-markdown><script type="text/template">
With MQCs, learning about all incoming messages for a single queue requires only one storage proof and one MQC entry (70 bytes) per incoming message.
</script></section><section  data-markdown><script type="text/template">
## UMP Configuration

```rust
pub struct HostConfiguration {
	/// Total number of individual messages allowed in the
	/// parachain -> relay-chain message queue.
	pub max_upward_queue_count: u32,
	/// Total size of messages allowed in the
	/// parachain -> relay-chain message queue.
	pub max_upward_queue_size: u32,
	/// The maximum size of an upward message that can be sent by a candidate.
	///
	/// This parameter affects the size upper bound of the `CandidateCommitments`.
	pub max_upward_message_size: u32,
	/// The maximum number of messages that a candidate can contain.
	///
	/// This parameter affects the size upper bound of the `CandidateCommitments`.
	pub max_upward_message_num_per_candidate: u32,
	// ... more fields
}
```
</script></section><section  data-markdown><script type="text/template">
## Validation Outputs for UMP

```rust
/// Outputs of _successful_ validation of a parachain block.
pub struct ValidationResult {
	/// Upward messages sent by the Parachain.
	pub upward_messages: Vec<UpwardMessage>,
	// ... more fields
}
```
</script></section><section  data-markdown><script type="text/template">
## DMP Configuration

```rust
pub struct HostConfiguration {
	/// The maximum size of a message that can be put in a downward message queue.
	pub max_downward_message_size: u32,
}
```
</script></section><section  data-markdown><script type="text/template">
## Validation Outputs for DMP

```rust
/// Outputs of _successful_ validation of a parachain block.
pub struct ValidationResult {
	/// Number of downward messages that were processed by the Parachain.
	///
	/// It is expected that the Parachain processes them from first to last.
	pub processed_downward_messages: u32,
	// ... more fields
}
```

<aside class="notes"><p>Parachains can &quot;process&quot; messages simply by ignoring them.
The Relay Chain doesn&#39;t care what parachains do with the messages.
They can just be thrown out.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Validation Outputs for HRMP

```rust
/// Outputs of _successful_ validation of a parachain block.
pub struct ValidationResult {
	/// Outbound horizontal messages sent by the parachain.
	pub horizontal_messages: Vec<OutboundHrmpMessage>,
	/// The mark which specifies the block number up
	/// to which all inbound HRMP messages are processed.
	pub hrmp_watermark: RelayChainBlockNumber,

	// ... more fields
}

pub struct OutboundHrmpMessage {
	/// The para that will get this message in its downward message queue.
	pub recipient: ParaId,
	/// The message payload.
	pub data: sp_std::vec::Vec<u8>,
}

```
</script></section><section  data-markdown><script type="text/template">
## HRMP Configuration

```rust
pub struct HostConfiguration {
	pub hrmp_max_parachain_outbound_channels: u32,

	pub hrmp_sender_deposit: Balance,
	pub hrmp_recipient_deposit: Balance,

	pub hrmp_channel_max_capacity: u32,
	pub hrmp_channel_max_total_size: u32,

	pub hrmp_max_parachain_inbound_channels: u32,
	pub hrmp_channel_max_message_size: u32,

  // more fields...
}
```
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#4A2439" -->

# Questions
</script></section>
    </article>
  </main>

  <script src="./../../../dist/reveal.js"></script>

  <script src="./../../../plugin/markdown/markdown.js"></script>
  <script src="./../../../plugin/highlight/highlight.js"></script>
  <script src="./../../../plugin/zoom/zoom.js"></script>
  <script src="./../../../plugin/notes/notes.js"></script>
  <script src="./../../../plugin/math/math.js"></script>

  <script src="./../../../assets/plugin/mermaid.js"></script>
  <script src="./../../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../../assets/plugin/chart/chart.js"></script>
  <script src="./../../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
