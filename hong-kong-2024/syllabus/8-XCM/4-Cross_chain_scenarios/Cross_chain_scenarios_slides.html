<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Cross-chain scenarios</title>
  <link rel="icon" href="./../../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../../dist/reset.css" />
  <link rel="stylesheet" href="./../../../dist/reveal.css" />
  <link rel="stylesheet" href="./../../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section ><section data-markdown><script type="text/template">

# Cross-chain scenarios
</script></section><section data-markdown><script type="text/template">
## What we've seen so far

<pba-flex center>

- What XCM is and its main concepts
- How XCM programs are written and executed
- The interface between FRAME and XCM
</script></section><section data-markdown><script type="text/template">
## What we'll look into now

<pba-flex center>

- Cross-chain examples
- Cross-chain composability
- Attack scenarios
</script></section><section data-markdown><script type="text/template">
## At the end of this lecture, you will be able to:

<pba-flex center>

- Build existing or new cross-chain use-cases
- Leverage services offered by the broader Polkadot ecosystem for your apps
- Mitigate risk during cross-chain interactions
</script></section></section><section ><section data-markdown><script type="text/template">
# Cross-chain DEX

<aside class="notes"><p>Let&#39;s start with a cross-chain DEX.
Say we have a DEX chain working, with liquidity pools and users.
It&#39;s only working for accounts on that chain, but we&#39;d like to extend it to the broader Polkadot ecosystem.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Requirements

<pba-flex center>

- Accounts on other chains can transfer tokens to our chain
- They can do swaps without an account on our chain
- They can add/remove liquidity without an account on our chain
</script></section><section data-markdown><script type="text/template">
## Diagram

<diagram class="mermaid">
graph LR
A(A) --"Transfer"--> DEX(DEX)
DEX --"Swap/Liquidity"--> DEX
</diagram>

<aside class="notes"><p>Swaps and liquidity exist on our DEX chain.
However, we want an end user that already has an account on the A chain to simply use the funds it has there to interact with our chain.
No need for them to create an account on our chain.
How do we do that?</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Configuring XCM

The XCM configuration translates the XCVM instructions into actual native runtime functionality of our chain.

<aside class="notes"><p>The first step is to add the XCM executor to our chain.</p>
<p>The executor is highly configurable, we need to make sure to tailor it to our use-case.</p>
</aside></script></section><section data-markdown><script type="text/template">
## AssetTransactor

<pba-flex center>

```rust
type AssetTransactor = FungiblesAdapter<
  Assets,
  Matcher,
  LocationToAccountId,
  ...
>;
```

<aside class="notes"><p>This is a type that exists in <code>xcm-builder</code> to help adapt existing FRAME pallets to the XCVM.
<code>Assets</code> is the assets pallet as configured in <code>construct_runtime</code>.
<code>Matcher</code> is a type that can convert from XCM <code>Location</code>s into the actual asset IDs our chain works with.
<code>LocationToAccountId</code> converts from XCM <code>Location</code>s to account ids on our local chain.</p>
<p>There are other adapters ready for other pallets, like:</p>
<ul>
<li><code>FungibleAdapter</code> for the balances pallet</li>
<li><code>NonFungiblesAdapter</code> for the uniques pallet</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Teleports or reserve asset transfers?

<pba-flex center>

```rust
type IsReserve = ();
type IsTeleporter = ();
```

<aside class="notes"><p>We can either use teleports or reserve asset transfers for moving assets between chains.
Which one should we use here?
In general we want reserve asset transfers since the real asset stays on the reserve and we just get a derivative of it, requires less trust.
Once we configure the locations we trust as reserves, we can start receiving transfers from them.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Reserve asset transfers

<pba-flex center>

```rust
Xcm(vec![
  WithdrawAsset(withdraw_amount),
  DepositReserveAsset {
    assets: All.into(),
    dest: (Parent, Parachain(dex_para_id)).into(),
    xcm: Xcm(vec![
      DepositAsset { assets, beneficiary },
    ]),
  },
])
```

<aside class="notes"><p>We could also use the XCM pallet&#39;s <code>transfer_assets</code> extrinsic, or <code>limited_reserve_asset_transfer</code>, to transfer assets over to our DEX chain.
<code>transfer_assets</code> will use our configuration to realize if it should use a teleport or a reserve asset transfer.
However, with this custom approach, we can add the rest of our program afterwards.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Sovereign account

<diagram class="mermaid">
graph LR
A(A) --"XCM"-->DEX(DEX)
A -.- ALocation("AccountId32(0x...)")
DEX -.- DEXLocation("../Parachain(A)/AccountId32(0x...)")
</diagram>

<aside class="notes"><p>The XCM Location on A is just a wrapper around the account on that chain.
The Location of the message that our DEX chain receives references the A chain.
Where do the funds go?</p>
</aside></script></section><section data-markdown><script type="text/template">
## XCM Location -> AccountId

<pba-flex center>

```rust
type LocationToAccountId = (
  AccountId32Aliases<Network, AccountId>,
  HashedDescription<
    AccountId,
    DescribeFamily<DescribeAccountId32Terminal>
  >,
);
```

<aside class="notes"><p>The funds arrive to the sovereign account of the account that sent them.
<code>LocationToAccountId</code> transforms the location to an account id.
<code>AccountId32Aliases</code> just removes the wrapper for local accounts.</p>
<p><code>HashedDescription</code> is more interesting.
Given an arbitrary location, it calculates the account by hashing the description of the parents and junctions.
This is used for figuring out the sovereign account.</p>
<p>Once the sovereign account over on the DEX chain is funded, we can use it for swapping.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Swaps

<pba-flex center>

```rust
enum Instruction<Call> {
  // ...snip...
  ExchangeAsset {
    give: AssetFilter,
    want: Assets,
    maximal: bool,
  },
  // ...snip...
}
```

<aside class="notes"><p>This instruction can be used to express a swap.
You specify how much you&#39;re willing to give and how much you want in return.
If <code>maximal</code>, you use up all the <code>give</code> and accordingly receive more than <code>want</code>.
If not, you use the least amount of <code>give</code> and get at least <code>want</code>.
This can be paired up with other instructions to send the XCM we want.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Make the swap

<pba-flex center>

```rust
Xcm(vec![
  WithdrawAsset(withdraw_amount),
  BuyExecution { fees, weight_limit },
  ExchangeAsset { give, want, maximal },
  DepositAsset { assets, beneficiary },
])
```

<aside class="notes"><p>A program like this sent to the DEX chain will:</p>
<ul>
<li>take the assets from our sovereign account</li>
<li>pays for execution</li>
<li>swap the tokens we specified</li>
<li>deposit them back into the sovereign account</li>
</ul>
<p>What if we didn&#39;t include the <code>BuyExecution</code> instruction? We&#39;d be able to exchange for more tokens.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Denial of Service attack

Imagine a million of these:

<pba-flex center>

```rust
Xcm(vec![
  WithdrawAsset(assets),
  DepositAsset { assets, beneficiary },
])
```

<aside class="notes"><p>If we don&#39;t enforce fee payment, then someone could send a ton of small messages to our chain, forcing our chain to execute a lot of work for free.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Barriers to the rescue

<pba-flex center>

```rust
type Barrier: ShouldExecute;
```

<aside class="notes"><p>The executor can be configured with barriers that are run for each message that wants to be executed.
The barriers determine whether the message can be executed or whether it&#39;s dropped.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Requiring fees to be paid

<pba-flex center>

```rust
type Barrier = AllowTopLevelPaidExecutionFrom<Everything>;
```

<aside class="notes"><p>This barrier is in <code>xcm-builder</code> and will reject any message that doesn&#39;t intend to pay fees.
This translates to not including the <code>BuyExecution</code> instruction.
With this, we exclude the messages that don&#39;t pay fees.</p>
<p>The <code>Everything</code> specifies we don&#39;t actually filter any origin of the messages, as long as they pay for their own execution.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Up until now

```rust
Xcm(vec![
  WithdrawAsset(withdraw_amount),
  DepositReserveAsset {
    assets: All.into(),
    dest: (Parent, Parachain(dex_para_id)).into(),
    xcm: Xcm(vec![
      BuyExecution { fees, weight_limit },
      ExchangeAsset { give, want, maximal },
      DepositAsset { assets, beneficiary },
    ]),
  },
])
```

<aside class="notes"><p>Until now, we do the transfer to the DEX, do the swap, and deposit the tokens in the sovereign account.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Getting the tokens back

<pba-flex center>

- We've sent the tokens
- We made a swap
- Now how do we get them back into our chain?
</script></section><section data-markdown><script type="text/template">
## Message to get them back

<pba-flex center>

```rust
InitiateReserveWithdraw {
  assets: All.into(),
  reserve: (Parent, Parachain(a_para_id)).into(),
  xcm: Xcm(vec![
    BuyExecution { fees, weight_limit },
    DepositAsset { assets, beneficiary },
  ]),
}
```

<aside class="notes"><p>The message is different because the reserve is not where it&#39;s executed, it&#39;s the destination.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Putting it all together

<pba-flex center>

```rust
Xcm(vec![
  WithdrawAsset(withdraw_amount),
  BuyExecution { fees, weight_limit },
  DepositReserveAsset {
    assets: All.into(),
    dest: (Parent, Parachain(dex_para_id)).into(),
    xcm: Xcm(vec![
      BuyExecution { fees, weight_limit },
      ExchangeAsset { give, want, maximal },
      InitiateReserveWithdraw {
        assets: All.into(),
        reserve: (Parent, Parachain(a_para_id)).into(),
        xcm: Xcm(vec![
          BuyExecution { fees, weight_limit },
          DepositAsset { assets, beneficiary },
        ]),
      }
    ]),
  },
])
```
</script></section></section><section  data-markdown><script type="text/template">
## Summary

<pba-flex center>

In this lecture, we learnt:

- How chains interpret locations and turn them to accounts and FRAME origins
- How to set a barrier to protect our chain from attacks
- What adapters are available to translate XCM `Assets` to FRAME assets
</script></section>
    </article>
  </main>

  <script src="./../../../dist/reveal.js"></script>

  <script src="./../../../plugin/markdown/markdown.js"></script>
  <script src="./../../../plugin/highlight/highlight.js"></script>
  <script src="./../../../plugin/zoom/zoom.js"></script>
  <script src="./../../../plugin/notes/notes.js"></script>
  <script src="./../../../plugin/math/math.js"></script>

  <script src="./../../../assets/plugin/mermaid.js"></script>
  <script src="./../../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../../assets/plugin/chart/chart.js"></script>
  <script src="./../../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
