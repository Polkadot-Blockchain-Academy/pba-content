<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Introduction to XCM</title>
  <link rel="icon" href="./../../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../../dist/reset.css" />
  <link rel="stylesheet" href="./../../../dist/reveal.css" />
  <link rel="stylesheet" href="./../../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# XCM
</script></section><section  data-markdown><script type="text/template">
## On this module, we'll see

<pba-flex center>

- What XCM is
- What primitives make up XCMs
- How XCMs are executed
- The XCM Pallet
- How to configure systems to work with XCM
- How to craft XCMs
</script></section><section ><section data-markdown><script type="text/template">
# The problem

Substrate and FRAME encourage an ecosystem of many blockchains.

We don't want every chain to have to do everything.
</script></section><section data-markdown><script type="text/template">
## Specialization

Specialization allows chains to focus on their particular value proposition and do it well.
</script></section></section><section ><section data-markdown><script type="text/template">
# The solution

Messaging.

<aside class="notes"><p>In order for chains to use functionality from other chains,
we need to pass messages from one chain to another.</p>
</aside></script></section><section data-markdown><script type="text/template">
## How?

<pba-flex center>

- UMP/DMP: Relay <-> Parachains
- HRMP: Parachain <-> Parachain
- Bridges: Polkadot <-> Ethereum and more

<aside class="notes"><p>UMP/DMP stands for Upward/Downward Message Passing.
HRMP piggybacks on UMP and DMP to send messages to sibling parachains, so it uses the relay chain as a relayer.
These are the current transport protocols we have in Polkadot.
An upgrade to HRMP is XCMP which won&#39;t use the relay chain at all.
It&#39;s not live yet, still being researched and prototyped.</p>
</aside></script></section><section data-markdown><script type="text/template">
## What?

What messages do we actually send?
</script></section><section data-markdown><script type="text/template">
### Native messages

The messages could just be the native transactions of each chain.

<aside class="notes"><p>If we have a message passing protocol, we can just allow one chain
to post transactions to another chain.</p>
<p>This is very simple and useful, but it has some disadvantages.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Native messages: disadvantages

- Format changes from system to system, it could also change within the same system, e.g. on a runtime upgrade.
- Common cross-consensus use-cases don't map one-to-one to a single transaction.
- Different consensus systems have different assumptions e.g. fee payment.

<aside class="notes"><ul>
<li>A system which intends to send messages to more than one destination would need to understand how to author a message for each.
On that note, even a single destination may alter its native transaction/message format over time.
Smart contracts might get upgrades, blockchains might introduce new features or alter existing ones and in doing so change their transaction format.</li>
<li>Special tricks may be required to withdraw funds, exchange them and then deposit the result all inside a single transaction.
Onward notifications of transfers, needed for a coherent reserve-asset framework, do not exist in chains unaware of others.
Some use-cases don&#39;t require accounts.</li>
<li>Some systems assume that fee payment had already been negotiated, while some do not.</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
### A better solution

- A domain-specific language that is agnostic to the underlying chain implementing it.
- Able to express multiple actions in a single message.
- Flexible enough to accomodate multiple different paradigms.
</script></section></section><section ><section data-markdown><script type="text/template">
# XCM

> XCM is a **language** for communicating **intentions** between **consensus systems**.
</script></section><section data-markdown><script type="text/template">
## Language

Cross-chain DSL.

Each message is a script that allows expressing multiple actions.
</script></section><section data-markdown><script type="text/template">
## Intentions

Blockchains are sovereign entities, the language only expresses what we _want_
the receiver to do, it can't enforce it.

Verification can be done on another layer, e.g. checking the expected result with a light client.

<aside class="notes"><p>It&#39;s up to the receiver to interpret the message and execute the corresponding actions.</p>
<p>Not every chain might implement every intention, for example swaps.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Consensus systems

We extend the actors to be consensus systems, not only chains.

This includes smart contracts and any system that achieves consensus in some way.

<aside class="notes"><p>Proof-of-authority web2 systems can also be considered consensus systems.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Versioned

XCM is a **versioned** language.

Each system declares what version they support.

The latest is version 5.

What goes in each version is defined via an RFC process.

<aside class="notes"><p>This protects against runtime upgrades breaking everything.</p>
</aside></script></section></section><section  data-markdown><script type="text/template">
# XCM vs Message Passing

<img src="img/XCM Post truck.png">

<aside class="notes"><p>XCM is akin to the post card from the post office.</p>
<p>It is <em>not</em> a transport protocol.</p>
<p>A post card doesn&#39;t send itself!</p>
<p>As we mentioned, XCM != {UMP, DMP, HRMP, XCMP, Bridges}.</p>
<p>It cannot be used to actually &quot;send&quot; any message between systems; its utility is only in expressing what should be done by the receiver.
Like many aspects core to Substrate, this separation of concerns empowers us to be far more generic and enable much more.
A post card relies on the postal service to get itself sent towards its receivers, and that is what a messaging protocol does.</p>
<p>The transport layer concerns itself with sending arbitrary blobs, it doesn&#39;t care about the format.</p>
</aside></script></section><section  data-markdown><script type="text/template">
### Terminology: XCMs

**XCM**, Cross-Consensus Messaging, is the format.

**An XCM** is a Cross-Consensus Message.

It's not called an XCM message,

the same way it's not called an ATM machine.

We can also call them XCM programs, since they are executable.

<aside class="notes"><p>More about their executable nature later.</p>
</aside></script></section><section  data-markdown><script type="text/template">
# Summary

<pba-flex center>

- We learned what XCM is and why it's useful.
- We learned what transport protocols exist in Polkadot.
</script></section><section  data-markdown><script type="text/template">
# Questions?
</script></section><section  data-markdown><script type="text/template">
# Example Flow

<img src="img/Example Flow - Introduction.png">

<aside class="notes"><p>We&#39;ll build towards this during this module.</p>
</aside></script></section><section  data-markdown><script type="text/template">
# Next steps

We'll learn about the primitives that make up any XCM.
</script></section>
    </article>
  </main>

  <script src="./../../../dist/reveal.js"></script>

  <script src="./../../../plugin/markdown/markdown.js"></script>
  <script src="./../../../plugin/highlight/highlight.js"></script>
  <script src="./../../../plugin/zoom/zoom.js"></script>
  <script src="./../../../plugin/notes/notes.js"></script>
  <script src="./../../../plugin/math/math.js"></script>

  <script src="./../../../assets/plugin/mermaid.js"></script>
  <script src="./../../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../../assets/plugin/chart/chart.js"></script>
  <script src="./../../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
