<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Polkadot Architecture</title>
  <link rel="icon" href="./../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../dist/reset.css" />
  <link rel="stylesheet" href="./../../dist/reveal.css" />
  <link rel="stylesheet" href="./../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# Polkadot Architecture

<aside class="notes"><p>Intro<br>Today we&#39;ll explore Polkadot’s blockchain architecture in depth. We&#39;ll cover blockchain scalability, parachain and relay chain design, coretime resource allocation, cross-chain interoperability (XCM), and contextualize with comparisons to web2 distributed systems and common scaling limits faced historically by vertical architectures.</p>
</aside></script></section><section  data-markdown><script type="text/template">
# The Blockchain Scalability Challenge

Early blockchains (Ethereum L1, Bitcoin) have faced scalability issues:

- Ethereum: ~15–30 TPS
- Bitcoin: ~7 TPS

High demand quickly congests these blockchains, causing increased costs and poor UX.

Current-gen blockchains like Solana and Ethereum L2s/rollups) achieve higher TPS but introduce notable trade-offs:

- Solana: Thousands of TPS (uhh.. kinda), but higher node hardware requirements.
- Rollups (Base, Optimism): Lower fees, but sequencer centralization and delayed finality (still not that many TPS).

<aside class="notes"><ul>
<li>Explain TPS (transactions per second) clearly.</li>
<li>Highlight practical examples of network congestion (CryptoKitties, NFT events, hyped launches).</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
## Web2 Vertical Scaling: History

Traditional web2 applications initially used vertical scaling (scale-up):

- Single powerful servers (monolithic databases, Oracle DB, SQL Server).
- Upgrade hardware (CPU, RAM) to improve capacity.

Vertical scaling limits:

- Diminishing returns quickly encountered (hardware upgrades increasingly expensive, minimal performance gains).
- Centralization risks (single points of failure, limited redundancy).

These limits motivated widespread adoption of horizontal scaling (scale-out) strategies in web2:

- Apache Cassandra, MongoDB (distributed databases).
- Kubernetes, AWS EC2 auto-scaling (cloud infrastructure).

<aside class="notes"><ul>
<li>Clearly illustrate historical progression from vertical to horizontal scaling in web2.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Scaling Architectures Compared: Horizontal vs Vertical

## Horizontal Scaling

Multiple parallel nodes increase throughput capacity.

- Analogy: Multiple lanes on a highway.
- Examples: Kubernetes clusters, Cassandra database nodes.
- Complexity: Coordinating node communication, state synchronization.

## Vertical Scaling

Single node improved through hardware/software optimization.

- Analogy: Upgrading a single-lane road.
- Examples: Large Oracle DB instances on powerful hardware.
- Limitations: Increasingly costly hardware upgrades, inherent physical constraints, centralization risks.

Blockchain analogies clearly evident in Solana's vertical optimization versus Polkadot/Ethereum sharding horizontal strategies.

<aside class="notes"><ul>
<li>Clearly contrast horizontal and vertical scaling principles.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Sharding

Sharding partitions data/workloads into smaller subsets ("shards"), processed in parallel:

- Web2 distributed databases (MongoDB, Cassandra) extensively utilize sharding.
- Blockchain equivalents: Ethereum Blobspace, Polkadot parachains.

Sharding complexity: cross-shard communication, liquidity fragmentation, transaction atomicity/synchronicity.

<aside class="notes"><ul>
<li>Clearly explain traditional sharding concepts and connect to blockchain sharding.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Polkadot's Horizontal Scaling

Polkadot implements sharding horizontally via parachains:

- Relay chain: Central minimal chain handling consensus/security ONLY - no execution!
- Parachains: Independent specialized blockchains handling transactions simultaneously.

Parachains closely resemble microservices architectures - specialized, isolated components with clear roles.

<aside class="notes"><ul>
<li>Clearly differentiate relay chain versus parachain roles.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
## Relay chain: Minimalism & Security

Relay chain principles:

- Security via validators/nominators.
- BABE (block production) & GRANDPA (finality) consensus.
- No complex application logic, maximizing efficiency and scalability.

In Web2: Kubernetes control plane—manages orchestration/coordination without running direct user workloads.

<aside class="notes"><ul>
<li>Clearly explain minimalist approach benefits.</li>
<li>Mention Kubernetes analogy explicitly.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
## Coretime: Efficient Blockspace

Coretime resource allocation:

- Parachains buy processing resources ("blockspace/coretime") via a marketplace.
- Efficient, fair allocation prevents resource underutilization (dutch auction model).

In Web2: Cloud computing resource allocation (AWS spot instances) - allocating finite compute resources efficiently via dynamic pricing mechanisms.

<aside class="notes"><ul>
<li>Talk more about the concept of blockspace in the industry.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
## Appchains: Specialization Benefits

Each parachain specialized for particular functions:

- DeFi parachains: Optimized security, settlement assurance.
- Gaming parachains: Optimized low latency, rapid interactions, low cost.

In web2: Microservices - specialized, optimized services with clearly defined responsibilities, avoiding monolithic inefficiencies.

<aside class="notes"><ul>
<li>Clearly connect appchains to relatable web2 concepts.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
## System Parachains: Infrastructure Foundations

System parachains provide foundational ecosystem infrastructure:

- Asset Hub (asset issuance), bridge parachains (external ecosystem interaction), identity parachains.
- Critical shared services analogous to DNS, authentication, load balancing in web2 infrastructure.

<aside class="notes"><ul>
<li>Clearly explain practical value of system parachains and relatable web2 parallels.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Cross-Chain Interoperability (XCM)

XCM enables secure communication between independent parachains:

- Asset/token transfers.
- Cross-chain smart contract interactions.

In web2: Message-passing systems like Kafka, RabbitMQ, RPC protocols - enabling communication among independent services.

<aside class="notes"></aside></script></section><section  data-markdown><script type="text/template">
## XCM Practical Examples

- Cross-chain decentralized finance (DeFi): aggregating liquidity across financial parachains.
- Multi-chain governance: synchronized voting, decisions across ecosystem.
- Shared identity verification across multiple parachains.

<aside class="notes"><ul>
<li>Clearly illustrate practical XCM benefits.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Polkadot vs Ethereum Blobspace: Scaling Strategy Comparison

Ethereum and Polkadot employ different scaling strategies:

- Ethereum Blobspace:
  - Optimized data availability layer supporting rollups.
  - Off-chain computation focus, minimal state on-chain.
- Polkadot Coretime/Parachains:
  - Optimized compute resource allocation via coretime purchases.
  - Specialized application chains (parachains).
  - Built-in interoperability via XCM.

Tradeoffs clearly evident: Ethereum emphasizes general rollup-driven scalability, Polkadot emphasizes specialized interoperable shards.

<aside class="notes"><ul>
<li>Blobspace vs coretime economic approaches differ wildly, explain this.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Summary: Polkadot’s Architectural Strengths

Polkadot uniquely combines:

- Effective horizontal scalability (parachains).
- Minimalist central security via relay chain.
- Efficient resource allocation via Coretime.
- Specialized chains tailored per use-case (appchain model).
- Native, standardized cross-chain interoperability (XCM).

Together these design choices enable practical blockchain scalability solutions.

<aside class="notes"><ul>
<li>Clearly summarize key strengths succinctly.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# The Future

Polkadot represents a mature, realistic scaling solution acknowledging trade-offs inherent in any distributed system. Its architecture—parachains, relay chain minimalism, coretime allocation, and XCM interoperability—positions it well for the next phase of blockchain scaling (JAM).

Future roadmap includes increased parachain capacity, enhanced interoperability, and ever-increasing DevEx.

<aside class="notes"><ul>
<li>Basically tease JAM :).</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Q&A Session

Open session for questions.

<aside class="notes"></aside></script></section><section  data-markdown><script type="text/template"></script></section>
    </article>
  </main>

  <script src="./../../dist/reveal.js"></script>

  <script src="./../../plugin/markdown/markdown.js"></script>
  <script src="./../../plugin/highlight/highlight.js"></script>
  <script src="./../../plugin/zoom/zoom.js"></script>
  <script src="./../../plugin/notes/notes.js"></script>
  <script src="./../../plugin/math/math.js"></script>

  <script src="./../../assets/plugin/mermaid.js"></script>
  <script src="./../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../assets/plugin/chart/chart.js"></script>
  <script src="./../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
