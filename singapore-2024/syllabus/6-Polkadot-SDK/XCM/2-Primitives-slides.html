<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>XCM primitives</title>
  <link rel="icon" href="./../../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../../dist/reset.css" />
  <link rel="stylesheet" href="./../../../dist/reveal.css" />
  <link rel="stylesheet" href="./../../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section ><section data-markdown><script type="text/template">

# XCM Primitives
</script></section><section data-markdown><script type="text/template">
## What you'll learn

<pba-flex center>

- Locations
- Assets
- Instructions

<aside class="notes"><p>Locations: how an XCM references various entities in the network.
Assets: how an XCM can specify fungible and non-fungible assets.
Instructions: how an XCM expresses what actions it wants the receiver to perform.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
# Locations

Way of referencing any entity in the network, for example, the recipient of the message.

<diagram class="mermaid limit size-50">
graph LR
    Message(Message)
    Alice(Alice)--"?"-->Bob(Bob)
    Alice--"?"-->AssetHub(Asset Hub)
    Alice--"?"-->Pallet(Pallet)
    Alice--"?"-->SmartContract(Smart Contract)
</diagram>

<aside class="notes"><p>The <code>Location</code> is sort of the URL for consensus systems.
A Location can be a scalable multi-shard blockchain such as Polkadot, an ERC-20 asset account on a parachain, a smart contract, etc.
They can be relative or absolute.
They don&#39;t need to correspond with the actual path the message will take, that&#39;s the job of the transport protocol.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Interior Locations

> Given two consensus systems, A and B. A is **interior** to B if a state change in A implies a state change in B.

<aside class="notes"><p>An example, a smart contract in Ethereum would be interior to Ethereum itself.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Location hierarchy

<diagram class="mermaid">
graph TD;
    Relay(Relay)-->A(Parachain A)
    Relay-->B(Parachain B)
    B-->Alice(Account A)
    B-->Bob(Account B)
    A-->Pallet(Pallet Contracts)
    Pallet-->SCA(Smart Contract A)
    Pallet-->SCB(Smart Contract B)
</diagram>

<aside class="notes"><p>Locations form a hierarchy using the interior relation.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Location Representation

<pba-flex center>

```rust
struct Location {
    parents: u8,
    junctions: Junctions,
}
```

<div style="margin-bottom: 2rem;"></div>

```rust
enum Junction {
    Parachain(u32),
    AccountId32 { id: [u8; 32], network: Option<NetworkId> },
    PalletInstance(u8),
    GeneralIndex(u128),
    GlobalConsensus(NetworkId),
    ...
}
```

<aside class="notes"><p>Right now Junctions are limited to 8 because of stack space.
We also don&#39;t expect Junctions being more than 8 levels deep.</p>
<p>It&#39;s perfectly possible to create locations that don&#39;t point anywhere.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Network Id

<pba-flex center>

```rust
enum NetworkId {
    ByGenesis([u8; 32]),
    ByFork { block_number: u64, block_hash: [u8; 32] },
    Polkadot,
    Kusama,
    Westend,
    Rococo,
    Wococo,
    Ethereum { chain_id: u64 },
    BitcoinCore,
    BitcoinCash,
}
```

</pba-col>

</pba-cols>

<aside class="notes"><p>Junctions are ways to descend the location hierarchy</p>
</aside></script></section><section data-markdown><script type="text/template">
## Text notation

<pba-flex center>

<pba-cols>

<pba-col>

```rust
Location {
    parents: 1,
    interior: Parachain(50)
}
```

</pba-col>
<pba-col>

-->

</pba-col>
<pba-col>

```
../Parachain(50)
```

</pba-col>

<aside class="notes"><p>This notation comes from an analogy to a file system.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Universal Location

> The Universal Location is a **theoretical** location. It's the parent of all locations which generate their own consensus. It itself has no parents.
</script></section><section data-markdown><script type="text/template">
## Universal Location

<diagram class="mermaid limit size-50">
graph TD;
    UniversalLocation(Universal Location)-->Polkadot(Polkadot)
    UniversalLocation-->Kusama(Kusama)
    UniversalLocation-->Ethereum(Ethereum)
    UniversalLocation-->Bitcoin(Bitcoin)
</diagram>

<aside class="notes"><p>We can imagine a hypothetical location that contains all top-level consensus systems.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Absolute locations

<pba-flex center>

```rust
pub type InteriorLocation = Junctions;
```

Sometimes, absolute locations are necessary, e.g. for bridges.

They don't have parents.

The first junction has to be a `GlobalConsensus`.

<aside class="notes"><p>To write an absolute location, we need to know our location relative to the Universal Location.</p>
</aside></script></section><section data-markdown><script type="text/template">
## What are `Location`s used for?

<pba-flex center>

- Addressing
- Origins
- Assets
- Fees
- Bridging
</script></section><section data-markdown><script type="text/template">
## Cross-Chain Origins

When a receiver gets an XCM, a `Location` specifies the sender.

This `Location` is _relative_ to the receiver.

Can be converted into a pallet origin in a FRAME runtime

Used for determining privileges during XCM execution.

<aside class="notes"><p>Reanchoring:</p>
<p>Since <code>Location</code>s are relative, when an XCM gets sent over to another chain, the origin location needs to be rewritten from the perspective of the receiver, before the XCM is sent to it.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Location Examples
</script></section><section data-markdown><script type="text/template">
### Sibling parachain

`../Parachain(1001)`

<diagram class="mermaid">
graph TD
    Polkadot(Polkadot)-->AssetHub("📍 AssetHub (1000)")
    Polkadot-->Collectives("Collectives (1001)")
</diagram>

<aside class="notes"><p>What does the location resolve to if evaluated on Parachain(1000)?</p>
</aside></script></section><section data-markdown><script type="text/template">
### Sibling parachain

`../Parachain(1001)`

<diagram class="mermaid">
graph TD
    Polkadot(Polkadot)-->AssetHub("📍 AssetHub (1000)")
    Polkadot-->Collectives("Collectives (1001)")
    AssetHub-->Polkadot
    linkStyle 0 opacity:0.3
    linkStyle 2 stroke-dasharray:5
</diagram>
</script></section><section data-markdown><script type="text/template">
### Parachain account

`Parachain(1000)/AccountId32(0x1234...cdef)`

<diagram class="mermaid">
graph TD
    Polkadot("📍 Polkadot")-->AssetHub("AssetHub (1000)")
    Polkadot-->Collectives("Collectives (1001)")
    AssetHub-->Account("AccountId32 (0x1234...cdef)")
</diagram>

<aside class="notes"><p>What does the location resolve to if evaluated on the relay chain?</p>
</aside></script></section><section data-markdown><script type="text/template">
### Parachain account

`Parachain(1000)/AccountId32(0x1234...cdef)`

<diagram class="mermaid">
graph TD
    Polkadot("📍 Polkadot")-->AssetHub("AssetHub (1000)")
    Polkadot-->Collectives("Collectives (1001)"):::disabled
    AssetHub-->Account("AccountId32 (0x1234...cdef)")
    linkStyle 1 opacity:0.3
    classDef disabled opacity:0.3
</diagram>
</script></section><section data-markdown><script type="text/template">
### Bridge

`../../GlobalConsensus(Kusama)/Parachain(1000)`

<diagram class="mermaid">
graph TD
    Universe(Universal Location)-->Polkadot(Polkadot)
    Universe-->Kusama(Kusama)
    Polkadot-->PolkaA("📍 Asset Hub (1000)")
    Polkadot-->PolkaB(Bridge Hub)
    PolkaA-->Alice(Alice)
    PolkaA-->AssetsPallet(Pallet Assets)
    AssetsPallet-->Asset(USDT)
    Kusama-->KusamaA("Asset Hub (1000)")
    Kusama-->KusamaB(Bridge Hub)
</diagram>

<aside class="notes"><p>Speak to an example of non-parachain multi-location that would use a bridge
XCM reasons about addressing (as in a postal address) that must include understanding where you are, not just where you are going!
This will be very powerful later on (Origins)</p>
</aside></script></section><section data-markdown><script type="text/template">
### Bridge

`../../GlobalConsensus(Kusama)/Parachain(1000)`

<diagram class="mermaid">
graph TD
    Universe(Universal Location)-->Polkadot(Polkadot)
    Universe-->Kusama(Kusama)
    Polkadot-->PolkaA("📍 Asset Hub (1000)")
    Polkadot-->PolkaB(Bridge Hub):::disabled
    PolkaA-->Alice(Alice):::disabled
    PolkaA-->AssetsPallet(Pallet Assets):::disabled
    AssetsPallet-->Asset(USDT):::disabled
    Kusama-->KusamA("Asset Hub (1000)")
    Kusama-->KusamB(Bridge Hub):::disabled
    PolkaA-->Polkadot
    Polkadot-->Universe
    linkStyle 0 opacity:0.3
    linkStyle 2 opacity:0.3
    linkStyle 3 opacity:0.3
    linkStyle 4 opacity:0.3
    linkStyle 5 opacity:0.3
    linkStyle 6 opacity:0.3
    linkStyle 8 opacity:0.3
    linkStyle 9 stroke-dasharray:5
    linkStyle 10 stroke-dasharray:5
    classDef disabled opacity:0.3
</diagram>

<aside class="notes"><p>Even with Bridge Hubs, the relative location is what you&#39;d expect.
Bridge Hubs are just a way for routing messages.
They are an implementation detail of the transport layer.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Bridge (actual routing)

<diagram class="mermaid limit size-50">
graph TD
    Universe(Universal Location):::disabled-->Polkadot(Polkadot):::disabled
    Universe-->Kusama(Kusama)
    Polkadot-->PolkaA("📍 Asset Hub (1000)")
    Polkadot-->PolkaB(Bridge Hub)
    PolkaA-->Alice(Alice):::disabled
    PolkaA-->AssetsPallet(Pallet Assets):::disabled
    AssetsPallet-->Asset(USDT):::disabled
    Kusama-->KusamB(Bridge Hub)
    Kusama-->KusamA("Asset Hub (1000)")
    PolkaA-->PolkaB
    PolkaB--"Bridge"-->KusamB
    KusamB-->Kusama
    linkStyle 0 opacity:0.3
    linkStyle 1 opacity:0.3
    linkStyle 2 opacity:0.3
    linkStyle 3 opacity:0.3
    linkStyle 4 opacity:0.3
    linkStyle 5 opacity:0.3
    linkStyle 6 opacity:0.3
    linkStyle 7 opacity:0.3
    linkStyle 11 stroke-dasharray:5
    classDef disabled opacity:0.3
</diagram>

<aside class="notes"><p>The actual message is routed through Bridge Hub.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Sovereign Accounts

Locations external to the local system can be represented by a local account.

We call this the **sovereign account** of that location.

They are a mapping from a `Location` to an account id.
</script></section><section data-markdown><script type="text/template">
<diagram class="mermaid">
graph TD
    Polkadot(Polkadot)-->A(A) & B(B)
    A-->Alice(Alice)
    B-->AliceSA("Alice's sovereign account")
</diagram>

<aside class="notes"><p>A sovereign account is an account on one system that is controlled by another on a different system.
A single account on a system can have multiple sovereign accounts on many other systems.
In this example, Alice is an account on AssetHub, and it controls a sovereign account on Collectives.</p>
<p>When transferring between consensus systems, the sovereign account is the one that gets the funds on the destination system.</p>
</aside></script></section><section data-markdown><script type="text/template">
<diagram class="mermaid">
graph TD
    Polkadot(Polkadot)-->A(A) & B(B)
    A-->Alice(Alice)
    B-->AliceSA("Alice's sovereign account")
    B-->ASA("Asset Hub's sovereign account")
    A-->BSA("Collective's sovereign account")
</diagram>
</script></section></section><section ><section data-markdown><script type="text/template">
# Assets

Most messages will deal with assets in some way.

How do we reference these assets?
</script></section><section data-markdown><script type="text/template">
### Asset Representation

<pba-flex center>

```rust
struct Asset {
    pub id: AssetId,
    pub fun: Fungibility,
}

struct AssetId(Location); // <- We reuse the location!

enum Fungibility {
    Fungible(u128),
    NonFungible(AssetInstance),
}
```

<aside class="notes"><p>We use locations, which we&#39;ve already discussed, to refer to assets.</p>
<p>A Asset is composed of an asset ID and an enum representing the fungibility of the asset.
Asset IDs are the location that leads to the system that issues it, this can be just an index in an assets pallet, for example.</p>
<p>Assets can also either be fungible or non-fungible:
Fungible - each token of this asset has the same value as any other
NonFungible - each token of this asset is unique and cannot be seen as having the same value as any other token under this asset</p>
</aside></script></section><section data-markdown><script type="text/template">
### Asset filtering and wildcards

<pba-flex center>

```rust
enum AssetFilter {
    Definite(Assets),
    Wild(WildAsset),
}

enum WildAsset {
    All,
    AllOf { id: AssetId, fun: WildFungibility },
    // Counted variants
}

enum WildFungibility {
    Fungible,
    NonFungible,
}
```

<aside class="notes"><p>Sometimes we don&#39;t want to specify an asset, but rather filter a collection of them.
In this case, we can either list all the assets we want or use a wildcard to select all of them.
In reality, it&#39;s better to use the counted variant of the wildcards, for benchmarking.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
# Instructions

Every XCM is a sequence of instructions.
</script></section><section data-markdown><script type="text/template">
## Kinds of instructions

<pba-flex center>

- Command
- Trusted Indication
- Information
- System Notification
</script></section><section data-markdown><script type="text/template">
## Example: WithdrawAsset

An instruction used to get assets from an account to use them during the execution of the message.

<pba-flex center>

```rust
WithdrawAsset(Assets)
```

<aside class="notes"><p>This instruction is a command.
It takes the assets from the account specified in the origin register and puts them in the holding register.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Example: ReceiveTeleportedAsset

<pba-flex center>

Used for teleporting assets between two systems.

```rust
ReceiveTeleportedAsset(Assets)
```

<aside class="notes"><p>This instruction is a trusted indication.
It tells the receiver that the sender has burnt some assets and they should be minted here.
This is used for teleports, which we&#39;ll look into in the next lecture.
A lot of trust is needed between both systems.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Example: QueryResponse

Used for reporting information back to another system.

<pba-flex center>

```rust
QueryResponse {
    #[codec(compact)]
    query_id: QueryId,
    response: Response,
    max_weight: Weight,
    querier: Option<Location>,
}
```

<aside class="notes"><p>This instruction is reporting back information.
Different things can be reported, like a certain pallet, the result of an operation, etc.</p>
</aside></script></section></section><section  data-markdown><script type="text/template">
# Summary

<pba-flex center>

- Locations
- Assets
- Instructions
</script></section><section  data-markdown><script type="text/template">
# Questions?
</script></section><section  data-markdown><script type="text/template">
# Workshop

We'll play around with these primitives.
</script></section><section  data-markdown><script type="text/template">
# Next steps

How do these primitives get together to perform cross-consensus execution?
</script></section>
    </article>
  </main>

  <script src="./../../../dist/reveal.js"></script>

  <script src="./../../../plugin/markdown/markdown.js"></script>
  <script src="./../../../plugin/highlight/highlight.js"></script>
  <script src="./../../../plugin/zoom/zoom.js"></script>
  <script src="./../../../plugin/notes/notes.js"></script>
  <script src="./../../../plugin/math/math.js"></script>

  <script src="./../../../assets/plugin/mermaid.js"></script>
  <script src="./../../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../../assets/plugin/chart/chart.js"></script>
  <script src="./../../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
