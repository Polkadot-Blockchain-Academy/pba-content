<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>FRAME/Pallet Hooks</title>
  <link rel="shortcut icon" href="./../../../assets/favicon.ico" />
  <link rel="stylesheet" href="./../../../dist/reset.css" />
  <link rel="stylesheet" href="./../../../dist/reveal.css" />
  <link rel="stylesheet" href="./../../../assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# ü™ù FRAME/Pallet Hooks ü™ù
</script></section><section ><section data-markdown><script type="text/template">
## Hooks: All In One

- Onchain / STF
  - `on_runtime_upgrade`
  - `on_initialize`
  - `poll` (WIP)
  - `on_finalize`
  - `on_idle`
- Offchain:
  - `genesis_build`
  - `offchain_worker`
  - `integrity_test`
  - `try_state`

<aside class="notes"><p><a href="https://paritytech.github.io/substrate/master/frame_support/traits/trait.Hooks.html">https://paritytech.github.io/substrate/master/frame_support/traits/trait.Hooks.html</a></p>
</aside></script></section><section data-markdown><script type="text/template">
### Hooks: All In One

```rust
#[pallet::hooks]
impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
  fn on_runtime_upgrade() -> Weight {}
  fn on_initialize() -> Weight {}
  fn on_finalize() {}
  fn on_idle(remaining_weight: Weight) -> Weight {}
  fn offchain_worker() {}
  fn integrity_test() {}
  #[cfg(feature = "try-runtime")]
  fn try_state() -> Result<(), &'static str> {}
}

#[pallet::genesis_build]
impl<T: Config> BuildGenesisConfig for GenesisConfig<T> {
	fn build(&self) {}
}
```

<aside class="notes"><p>Many of these functions receive the block number as an argument, but that can easily be fetched from
<code>frame_system::Pallet::&lt;T&gt;::block_number()</code></p>
</aside></script></section></section><section  data-markdown><script type="text/template">
## Hooks: `on_runtime_upgrade`

- Called every time the `spec_version`/`spec_name` is bumped.
- Why would might you be interested in implementing this?

<aside class="notes"><p>Because very often runtime upgrades needs to be accompanied by some kind of state migration.
Has its own lecture, more over there.</p>
</aside></script></section><section ><section data-markdown><script type="text/template">
## Hooks: `on_initialize`

- Useful for any kind of **automatic** operation.
- The weight you return is interpreted as `DispatchClass::Mandatory`.
</script></section><section data-markdown><script type="text/template">
### Hooks: `On_Initialize`

- `Mandatory` Hooks should really be lightweight and predictable, with a bounded complexity.

```rust
fn on_initialize() -> Weight {
  // any user can create one entry in `MyMap` üò±üî´.
  <MyMap<T>>::iter().for_each(do_stuff);
}
```

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Hooks: `On_Initialize`

- &shy;<!-- .element: class="fragment" --> Question: If you have 3 pallets, in which order their `on_initialize` are called?
- &shy;<!-- .element: class="fragment" --> Question: If your runtime panics `on_initialize`, how can you recover from it?
- &shy;<!-- .element: class="fragment" --> Question: If your `on_initialize` consumes more than the maximum block weight?

<aside class="notes"><ul>
<li>The order comes from <code>construct_runtime!</code> macro.</li>
<li>Panic in mandatory hooks is fatal error. You are pretty much done.</li>
<li>Overweight blocks using mandatory hooks, are possible, ONLY in the context of solo-chains. Such a
block will take longer to produce, but it eventually will. If you have your eyes set on being a
parachain developer, you should treat overweight blocks as fatal as well.</li>
</ul>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Hooks: `on_finalize`

- Extension of `on_initialize`, but at the end of the block.
- Its weight needs to be known in advance. Therefore, less preferred compared to `on_initialize`.

```rust
fn on_finalize() {} // ‚úÖ
fn on_finalize() -> Weight {} // ‚ùå
```

<!-- .element: class="fragment" -->

- Nothing to do with _finality_ in the consensus context.

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Hooks: `on_finalize`

> Generally, avoid using it unless if something REALLY needs to be happen at the end of the block.

<aside class="notes"><p>Sometimes, rather than thinking &quot;at the end of block N&quot;, consider writing code &quot;at the beginning of block N+1&quot;</p>
</aside></script></section></section><section  data-markdown><script type="text/template">
## Hooks: `poll`

- The non-mandatory version of `on_initialize`.
- In the making üë∑

<aside class="notes"><p>See <a href="https://github.com/paritytech/substrate/pull/14279">https://github.com/paritytech/substrate/pull/14279</a> and related PRs</p>
</aside></script></section><section ><section data-markdown><script type="text/template">
## Hooks: `on_idle`

- **_Optional_** variant of `on_finalize`, also executed at the end of the block.
- Small semantical difference: executes one pallet's hook, per block, randomly, rather than all
  pallets'.
</script></section><section data-markdown><script type="text/template">
## The Future: Moving Away From Mandatory Hooks

- `on_initialize` -> `poll`
- `on_finalize` -> `on_idle`
- New primitives for multi-block migrations
- New primitives for optional service work via extrinsics.

<aside class="notes"><p>This is all in the agenda of the FRAME team at Parity for 2023.</p>
<p><a href="https://github.com/paritytech/substrate/issues/13530">https://github.com/paritytech/substrate/issues/13530</a>
<a href="https://github.com/paritytech/substrate/issues/13690">https://github.com/paritytech/substrate/issues/13690</a></p>
</aside></script></section></section><section  data-markdown><script type="text/template">
## Recap: Onchain/STF Hooks

<diagram class="mermaid">
%%{init: {'theme': 'dark', 'themeVariables': { 'darkMode': true }}}%%
graph LR
    subgraph AfterTransactions
        direction LR
        OnIdle --> OnFinalize
    end

    subgraph OnChain
        direction LR
        Optional --> BeforeExtrinsics
        BeforeExtrinsics --> Inherents
        Inherents --> Poll
        Poll --> Transactions
        Transactions --> AfterTransactions
    end

    subgraph Optional

OnRuntimeUpgrade
end

    subgraph BeforeExtrinsics
        OnInitialize
    end

    subgraph Transactions
        Transaction1 --> UnsignedTransaction2 --> Transaction3
    end

    subgraph Inherents
        Inherent1 --> Inherent2
    end

</diagram>

<aside class="notes"><p>implicit in this:</p>
<p>Inherents are only first, which is being discussed RIGHT NOW: <a href="https://github.com/polkadot-fellows/RFCs/pull/13">https://github.com/polkadot-fellows/RFCs/pull/13</a></p>
</aside></script></section><section ><section data-markdown><script type="text/template">
## Hooks: `genesis_build`

- Means for each pallet to specify a $f(input): state$ at genesis.
- This is called only once, by the client, when you **create a new chain**.
  - &shy;<!-- .element: class="fragment" --> Is this invoked every time you run `cargo run`?
- `#[pallet::genesis_build]`.
</script></section><section data-markdown><script type="text/template">
### Hooks: `genesis_build`

```rust
#[pallet::genesis_build]
pub struct GenesisConfig<T: Config> {
  pub foo: Option<u32>,
  pub bar: Vec<u8>,
}
```

<!-- .element: class="fragment" -->

```rust
impl<T: Config> Default for GenesisConfig<T> {
  fn default() -> Self {
    // snip
  }
}
```

<!-- .element: class="fragment" -->

```rust
#[pallet::genesis_build]
impl<T: Config> GenesisBuild<T> for GenesisConfig<T> {
  fn build(&self) {
    // use self.foo, self.bar etc.
  }
}
```

<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Hooks: `genesis_build`

- `GenesisConfig` is a composite/amalgamated item at the top level runtime.

```rust
construct_runtime!(
  pub enum Runtime where {
    System: frame_system,
    Balances: pallet_balances,
  }
);
```

```rust
struct RuntimeGenesisConfig {
  SystemConfig: pallet_system::GenesisConfig,
  PalletAConfig: pallet_a::GenesisConfig,
}
```

<!-- .element: class="fragment" -->

<aside class="notes"><p><a href="https://paritytech.github.io/substrate/master/node_template_runtime/struct.RuntimeGenesisConfig.html">https://paritytech.github.io/substrate/master/node_template_runtime/struct.RuntimeGenesisConfig.html</a></p>
</aside></script></section><section data-markdown><script type="text/template">
### Hooks: `genesis_build`

- Recent changes moving `genesis_build` to be used over a runtime API, rather than native runtime.
- `#[cfg(feature = "std")]` in pallets will go away.

<aside class="notes"><p><a href="https://github.com/paritytech/substrate/issues/13334">https://github.com/paritytech/substrate/issues/13334</a></p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Hooks: `offchain_worker`

**Fully offchain application**:

- Read chain state via RPC.
- submit desired side effects back to the chain as transactions.

**Runtime Offchain Worker**:

- &shy;<!-- .element: class="fragment" --> Code lives onchain, upgradable only in synchrony with the whole runtime üëé
- &shy;<!-- .element: class="fragment" --> Ergonomic and fast state access üëç
- &shy;<!-- .element: class="fragment" --> State writes are ignored ü§∑
- &shy;<!-- .element: class="fragment" --> Can submit transactions back to the chain as well ‚úÖ
- &shy;<!-- .element: class="fragment" --> Source of many confusions!

<aside class="notes"><p>People have often thought that they can do magic with things with OCW, please don&#39;t. BIG warning to
founders to be careful with this!</p>
<p><a href="https://paritytech.github.io/substrate/master/pallet_examples/index.html">https://paritytech.github.io/substrate/master/pallet_examples/index.html</a></p>
</aside></script></section><section data-markdown><script type="text/template">
### Hooks: `offchain_worker`

- Execution entirely up to the client.
- Has a totally separate thread pool than the normal execution.

```
--offchain-worker <ENABLED>
    Possible values:
    - always:
    - never:
    - when-authority

--execution-offchain-worker <STRATEGY>
    Possible values:
    - native:
    - wasm:
    - both:
    - native-else-wasm:
```
</script></section><section data-markdown><script type="text/template">
### Hooks: `offchain_worker`

- Threads can **overlap**, each is reading the state of its corresponding block

<img style="height: 500px" src="../../../assets/img/6-FRAME/ocw.svg"  />

<!-- .element: class="fragment" -->

<aside class="notes"><p><a href="https://paritytech.github.io/substrate/master/sp_runtime/offchain/storage_lock/index.html">https://paritytech.github.io/substrate/master/sp_runtime/offchain/storage_lock/index.html</a></p>
</aside></script></section><section data-markdown><script type="text/template">
### Hooks: `offchain_worker`

- &shy;<!-- .element: class="fragment" -->Offchain workers have their own **special host
  functions**: http, dedicated storage, time, etc.
- &shy;<!-- .element: class="fragment" -->Offchain workers have the same **execution limits** as
  Wasm (limited memory, custom allocator).

- &shy;<!-- .element: class="fragment" -->Source of confusion, why OCWs cannot write to state.

<aside class="notes"><p>These are the source of the confusion.</p>
<p>Word on allocator limit in Substrate Wasm execution (subject to change).</p>
<ul>
<li>Max single allocation limited</li>
<li>Max total allocation limited.</li>
</ul>
</aside></script></section></section><section  data-markdown><script type="text/template">
## Hooks: `integrity_test`

- Put into a test by `construct_runtime!`.

```rust
__construct_runtime_integrity_test::runtime_integrity_tests
```

<!-- .element: class="fragment" -->

```rust
fn integrity_test() {
  assert!(
    T::MyConfig::get() > 0,
    "Are all of the generic types I have sensible?"
  );
  // notice that this is for tests, std is available.
  assert!(std::mem::size_of::<T::Balance>() > 4);
}
```

<!-- .element: class="fragment" -->

<aside class="notes"><p>I am in fan of renaming this. If you are too, please comment here</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Hooks: `try_state`

- A means for you to ensure correctness of your $STF$, after each transition.
- &shy;<!-- .element: class="fragment" -->Entirely offchain, custom runtime-apis, conditional
  compilation.
  - &shy;<!-- .element: class="fragment" -->Called from `try-runtime-cli`, which you will learn about next week, or anyone else
- &shy;<!-- .element: class="fragment" -->Examples from your assignment?

<aside class="notes"><p>What is a transition? Either a block, or single extrinsic</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Hooks: Recap

<diagram class="mermaid">
%%{init: {'theme': 'dark', 'themeVariables': { 'darkMode': true }}}%%
graph LR
    subgraph Offchain
        OffchainWorker
        TryState
    end

    subgraph Genesis
        GenesisBuild
    end

    subgraph AfterTransactions
        direction LR
        OnIdle --> OnFinalize
    end

    subgraph OnChain
        direction LR
        Optional --> BeforeExtrinsics
        BeforeExtrinsics --> Inherents
        Inherents --> Poll
        Poll --> Transactions
        Transactions --> AfterTransactions
    end

    subgraph Optional

OnRuntimeUpgrade
end

    subgraph BeforeExtrinsics
        OnInitialize
    end

    subgraph Transactions
        Transaction1 --> UnsignedTransaction2 --> Transaction3
    end

    subgraph Inherents
        Inherent1 --> Inherent2
    end

</diagram>

- What other hooks can you think of?

<aside class="notes"><p>What other ideas you can think of?</p>
<ul>
<li>a hook called once a pallet is first initialized.
<a href="https://github.com/paritytech/substrate/issues/14098">https://github.com/paritytech/substrate/issues/14098</a></li>
<li>Local on Post/Pre dispatch: <a href="https://github.com/paritytech/substrate/issues/12047">https://github.com/paritytech/substrate/issues/12047</a></li>
<li>Global on Post/Pre dispatch is in fact a signed extension. It has to live in the runtime, because you have to specify order.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
## Additional Resources! üòã

> Check speaker notes (click "s" üòâ)

<aside class="notes"><h2 id="post-lecture-notes">Post lecture Notes</h2>
<p>Regarding this drawback to offchain workers that you can only upgrade in cadence with the network.
Offchain worker, like tx-pool api, is only called from an offchain context. Node operators can
easily use the runtime overrides feature to change the behavior of their offchain worker anytime
they want.</p>
</aside></script></section>
    </article>
  </main>

  <script src="./../../../dist/reveal.js"></script>

  <script src="./../../../plugin/markdown/markdown.js"></script>
  <script src="./../../../plugin/highlight/highlight.js"></script>
  <script src="./../../../plugin/zoom/zoom.js"></script>
  <script src="./../../../plugin/notes/notes.js"></script>
  <script src="./../../../plugin/math/math.js"></script>

  <script src="./../../../assets/plugin/mermaid.js"></script>
  <script src="./../../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../../assets/plugin/chart/chart.js"></script>
  <script src="./../../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>