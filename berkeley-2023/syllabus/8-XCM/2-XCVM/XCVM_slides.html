<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>XCVM</title>
  <link rel="shortcut icon" href="./../../../assets/favicon.ico" />
  <link rel="stylesheet" href="./../../../dist/reset.css" />
  <link rel="stylesheet" href="./../../../dist/reveal.css" />
  <link rel="stylesheet" href="./../../../assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# XCVM
</script></section><section  data-markdown><script type="text/template">
# ü´Ä The XCVM

At the core of XCM lies the **Cross-Consensus Virtual Machine (XCVM)**.

A ‚Äúmessage‚Äù in XCM is an XCVM program, which is a sequence of instructions.

The XCVM is a state machine, state is kept track in **registers**.

<aside class="notes"><p>It‚Äôs an ultra-high level non-Turing-complete computer.
Messages are one or more XCM instructions.
The program executes until it either runs to the end or hits an error, at which point it finishes up and halts.
An XCM executor following the XCVM specification is provided by Parity, and it can be extended or customized, or even ignored altogether and users can create their own construct that follows the XCVM spec.</p>
</aside></script></section><section ><section data-markdown><script type="text/template">
# üìú XCVM Instructions

XCVM Instructions might change a register, they might change the state of the consensus system or both.
</script></section><section data-markdown><script type="text/template">
## Kinds of instructions

<pba-flex center>

- Command
- Trusted Indication
- Information
- System Notification
</script></section><section data-markdown><script type="text/template">
## Example: TransferAsset

An instruction used to transfer assets to some other address.

<pba-flex center>

```rust
TransferAsset {
    assets: Assets,
    beneficiary: Location,
}
```

<aside class="notes"><p>This instruction is a command.
It needs to know which assets to transfer and to which account to transfer them to.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
# XCVM Registers

<diagram class="mermaid">
graph LR
    subgraph Registers[ ]
        Holding(Holding)
        Origin(Origin)
        More(...)
    end
</diagram>

<aside class="notes"><p>Registers <em>are</em> the state of XCVM.
Note that they are temporary/transient.
We&#39;ll talk about are the <code>holding</code> and <code>origin</code> registers, but there are more.</p>
</aside></script></section><section data-markdown><script type="text/template">
## üìç The Origin Register

Contains an `Option<Location>` of the cross-consensus origin where the message originated from.

<aside class="notes"><p>This <code>Location</code> can change over the course of program execution.</p>
<p>It might be <code>None</code> because some instructions clear the origin register.</p>
</aside></script></section><section data-markdown><script type="text/template">
### üí∏ The Holding Register

Expresses a number of assets in control of the xcm execution that have no on-chain representation.

They don't belong to any account.

It can be seen as the register holding "unspent assets".
</script></section></section><section ><section data-markdown><script type="text/template">
# Basic XCVM Operation

<diagram class="mermaid">
graph LR
    subgraph Program
        WithdrawAsset-->BuyExecution
        BuyExecution-->DepositAsset
        DepositAsset
    end
    Program-.->Fetch
    Fetch(Fetch Instruction)-->Execute(Execute instruction)
    Execute-->Fetch
    Execute-.->Registers
    subgraph Registers
        Holding(Holding)
        Origin(Origin)
        More(...)
    end
</diagram>

<aside class="notes"><p>The XCVM fetches instruction from the program and executes them one by one.</p>
</aside></script></section><section data-markdown><script type="text/template">
## XCVM vs. Standard State Machine

<pba-flex center>

1. Error _handler_ register
2. Appendix register

<aside class="notes"><ol>
<li>Code that is run in the case where the XCM program fails or errors.
Regardless of the result, when the program completes, the error handler register is cleared.
This ensures that error handling logic from a previous program does not affect any appended code (i.e. the code in the error handler register does not loop infinitely, the code in the Appendix register cannot access the result of the code execution in the error handler).</li>
<li>Code that is run regardless of the execution result of the XCM program.</li>
</ol>
</aside></script></section><section data-markdown><script type="text/template">
## More complete XCVM operation

<diagram class="mermaid">
graph LR
    subgraph Program
        WithdrawAsset-->BuyExecution
        BuyExecution-->DepositAsset
        DepositAsset
    end
    Program-.->Fetch
    Fetch(Fetch Instruction)-->Execute(Execute instruction)
    Execute-->Fetch
    Execute-.->Registers
    subgraph Registers
        Holding(Holding)
        Origin(Origin)
        ErrorRegister(Error)
        ErrorHandler(Error Handler)
        AppendixRegister(Appendix)
        More(...)
    end
    Execute-- Error -->Error(Error Handler)
    Error-.->ErrorHandler
    Error-.->ErrorRegister
    Error-->Appendix
    Appendix-.->AppendixRegister
    Execute-->Appendix
</diagram>
</script></section></section><section ><section data-markdown><script type="text/template">
# üíÅ XCM by example
</script></section><section data-markdown><script type="text/template">
## The `WithdrawAsset` instruction

<pba-flex center>

```rust
enum Instruction {
    /* snip */
    WithdrawAsset(Assets),
    /* snip */
}
```

<aside class="notes"><p>There are a number of instructions
which place assets on the Holding Register.
One very simple one is the
<code>WithdrawAsset</code> instruction.</p>
<p>It withdraws some assets from the account of the location specified in the Origin Register.
But what does it do with them?
If they don‚Äôt get deposited anywhere then it&#39;s a pretty useless operation.
These assets are held in the holding register until something is done with them, for example, using the following instruction.</p>
</aside></script></section><section data-markdown><script type="text/template">
## The `BuyExecution` instruction

<pba-flex center>

```rust
enum Instruction {
    /* snip */
    BuyExecution {
        fees: Asset,
        weight_limit: WeightLimit,
    },
    /* snip */
}
```

<aside class="notes"><p>This instruction uses the specified assets in the Holding register to buy weight for the execution of the following instructions.
It&#39;s used in systems that pay fees.</p>
<p><code>weight_limit</code> is a sanity check, to make sure that the execution errors if you would buy more than that weight.
The estimate for the weight has to come from using the recipient&#39;s weigher, not the sender&#39;s.
The recipient is the one who actually executes the message.</p>
</aside></script></section><section data-markdown><script type="text/template">
## The `DepositAsset` instruction

<pba-flex center>

```rust
enum Instruction {
    /* snip */
    DepositAsset {
        assets: AssetFilter,
        beneficiary: Location,
    },
    /* snip */
}
```

<aside class="notes"><p>Takes assets from the holding register and deposits them in a beneficiary.
Typically an instruction that places assets into the holding register would have been executed previously.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Putting it all together

<pba-flex center>

```rust
Xcm(vec![
    WithdrawAsset((Here, amount).into()),
    BuyExecution {
        fees: (Here, amount).into(),
        weight_limit: Limited(sanity_check_weight_limit)
    },
    DepositAsset { assets: All.into(), beneficiary: AccountId32 { ... }.into() },
])
```

<aside class="notes"><p>All examples in these slides use the latest xcm version.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Good pattern

<pba-flex center>

```rust
Xcm(vec![
    WithdrawAsset((Here, amount).into()),
    BuyExecution {
        fees: (Here, amount).into(),
        weight_limit: Limited(sanity_check_weight_limit)
    },
    DepositAsset { assets: All.into(), beneficiary: AccountId32 { ... }.into() },
    RefundSurplus,
    DepositAsset { assets: All.into(), beneficiary: sender }
])
```
</script></section></section><section ><section data-markdown><script type="text/template">
# Reserve asset transfer

<pba-flex center>

```rust
Xcm(vec![
    WithdrawAsset(asset),
    InitiateReserveWithdraw {
        assets: All.into(),
        reserve: reserve_location,
        xcm: /* ...what to do with the funds in the reserve... */,
    },
])
```

<aside class="notes"><p>This message is executed locally.
Then, a message is sent to the <code>reserve</code> location.
That message contains the custom <code>xcm</code> provided along with other instructions.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Message received in reserve

<pba-flex center>

```rust
Xcm(vec![
    WithdrawAsset(reanchored_asset),
    ClearOrigin, // <- Why is this needed?
    /* ...custom instructions... */
])
```

<aside class="notes"><p>This is the message the reserve receives.</p>
<p>The <code>ClearOrigin</code> instruction deletes the content of the origin register.
This is needed because we don&#39;t trust the origin to do anything other than move its own assets.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Custom XCM

<pba-flex center>

```rust
let xcm_for_reserve = Xcm(vec![
    DepositReserveAsset {
        assets: All.into(),
        dest: location,
        xcm: Xcm(vec![
            DepositAsset {
                assets: All.into(),
                beneficiary: AccountId32 { ... }.into(),
            },
        ]),
    },
]);
```

<aside class="notes"><p>For a simple reserve asset transfer, this message will work.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Message received in destination

<pba-flex center>

```rust
Xcm(vec![
    ReserveAssetDeposited(reanchored_asset),
    ClearOrigin, // <- Why is this needed?
    /* ...custom instructions... */
])
```

<aside class="notes"><p>A very clear exploit in not having <code>ClearOrigin</code> here is syphoning all funds from
the reserve&#39;s sovereign account in the destination.
The destination can&#39;t trust the reserve to totally speak for the source, only for the assets.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
# Summary

<pba-flex center>

- XCVM
- Kinds of instructions
- Registers
  - Origin
  - Holding
  - Error handler
  - Appendix
- Instructions
  - WithdrawAsset, BuyExecution, DepositAsset
  - RefundSurplus
  - InitiateReserveWithdraw, ReserveAssetDeposited
</script></section><section data-markdown><script type="text/template">
## Next steps

<pba-flex center>

1. Blog series introducing XCM: Parts [1](https://medium.com/polkadot-network/xcm-the-cross-consensus-message-format-3b77b1373392), [2](https://medium.com/polkadot-network/xcm-part-ii-versioning-and-compatibility-b313fc257b83), and [3](https://medium.com/polkadot-network/xcm-part-iii-execution-and-error-management-ceb8155dd166).
2. XCM Format [repository](https://github.com/paritytech/xcm-format)
3. XCM [Docs](https://paritytech.github.io/xcm-docs/)
</script></section></section>
    </article>
  </main>

  <script src="./../../../dist/reveal.js"></script>

  <script src="./../../../plugin/markdown/markdown.js"></script>
  <script src="./../../../plugin/highlight/highlight.js"></script>
  <script src="./../../../plugin/zoom/zoom.js"></script>
  <script src="./../../../plugin/notes/notes.js"></script>
  <script src="./../../../plugin/math/math.js"></script>

  <script src="./../../../assets/plugin/mermaid.js"></script>
  <script src="./../../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../../assets/plugin/chart/chart.js"></script>
  <script src="./../../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>