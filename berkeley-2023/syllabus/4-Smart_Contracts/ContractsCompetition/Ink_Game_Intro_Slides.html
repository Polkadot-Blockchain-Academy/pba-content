<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>ink! Workshop (First Day)</title>
  <link rel="shortcut icon" href="./../../../assets/favicon.ico" />
  <link rel="stylesheet" href="./../../../dist/reset.css" />
  <link rel="stylesheet" href="./../../../dist/reveal.css" />
  <link rel="stylesheet" href="./../../../assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../../assets/img/0-Shared/logo/pba-logo-white.svg"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

<img rounded style="width: 1200px; padding-top:15px;" src="../img/ink/beginners-workshop.jpg" />

<aside class="notes"><p>This workshop was an idea that came from first wave of PBA in Cambridge. The first time it was ever played was back in Buenos Aires. It&#39;s very much a PBA right of passage, so it&#39;s exciting to be able to play today.</p>
</aside></script></section><section  data-markdown><script type="text/template">
# Day 1
</script></section><section  data-markdown><script type="text/template">
<img rounded style="margin-top: 25px; width: 1200px;" src="../img/ink/beamer.png" />

<aside class="notes"><p>This is us playing in BA earlier this year.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Components

<br/>

<div class="flex-container fragment">
<div class="left"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->
<div style="text-align: center"> <center><h2><pre> game.contract </pre></h2></center> </div>
<ul>
<li>We deploy + run.</li>
<li>Runs game loop.</li>
<li>Invokes each player.</li>
<li>Determines the score.</li>
</ul>
</div>

<div class="left fragment"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->
<div style="text-align: center"> <center><h2><pre> player.contract </pre></h2></center> </div>

<ul>
<li>Your job.</li>
</ul>
</div>
<div class="right fragment"> <!-- Gotcha: You Need an empty line to render MD inside <div> -->
<div style="text-align: center"> <center><h2><pre> frontend </pre></h2></center> </div>
<ul>
<li>On big screen during game.</li>
</ul>
</div>
</div>

<aside class="notes"><p>The game has three components:<br><strong>click</strong> the first is a game contract, which is something that we have taken care of. I will deploy it and run it on Rococo. The game contract runs the game loop. It invokes each player contract and it determines the score.<br><strong>click</strong> And the player.contract, that&#39;s your job. so we we have a template for a very basic player and you can basically modify it in any way you like. I will explain the scoring function in a moment.<br><strong>click</strong> Lastly, we have a front-end that we will put on the big screen here, but it&#39;s online, you can open it up on your laptop and follow the game locally.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## The Process

1. ğŸ§  Create contract that plays on your behalf<!-- .element: class="fragment" data-fragment-index="1" -->
1. ğŸš€ Deploy contract to Rococo testnet <!-- .element: class="fragment" data-fragment-index="2" -->
1. ğŸ¤ Register contract as player with game contract<!-- .element: class="fragment" data-fragment-index="3" -->
1. ï¸ğŸ® We start the game<!-- .element: class="fragment" data-fragment-index="4" -->
1. ğŸ“ºï¸ï¸ It runs for some minutes, we watch it on screen<!-- .element: class="fragment" data-fragment-index="5" -->

<aside class="notes"><p>So the process is as follows:<br><strong>click</strong> - you brainstorm and create a contract that plays on your behalf ideally in a better way than the other contracts<br><strong>click</strong> - you deploy the contract to the Rococo testnet<br><strong>click</strong> - you register your contract as a player with the game contract. We will publish the addresses and it&#39;s it&#39;s not complicated you can just use contracts UI. I will also show it in a second<br><strong>click</strong> - then we start the game. We have a script that calls the game contract regularly and the front end will display the changes<br><strong>click</strong> - so the game will run for some minutes. Your contract will already be uploaded at this point - so you can&#39;t do anything. The contract will play on your behalf. Meaning it&#39;s hands off. I mean you can also change it with upgradable contract patterns and stuff, but in general, you won&#39;t have to. So you can just watch the game play out.<br>If you&#39;re familiar with AI agents, that&#39;s also a similar idea, where you have an agent that plays a game on your behalf.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## How the Game looks

<img rounded src="../img/ink/splash-2.png" />

<aside class="notes"><p>This is what the game board itself looks like.
You can see, it&#39;s a it&#39;s a coordinate grid.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## How the Game looks

<img rounded src="../img//ink/splash-9.png" />

<aside class="notes"><p>this is X1 y0<br>And the idea is for you, as a contract developer, to paint as many fields of this canvas of the script as possible. There&#39;s an API function for how to paint. I&#39;ll show it in a minute, but the idea is that in the end the contract that painted the most Fields wins.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## How the Game looks

<img rounded src="../img//ink/splash-10.png" />

<aside class="notes"><p>So yeah, there&#39;s bit of scoring to be done. There&#39;s also scoreboard here on the side, where all players will be shown as well as their rank. You will be assigned a random color to your player contract.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## How to score?

- Use as little gas as possible to paint as many fields as possible.

<!-- .element: class="fragment" -->

- Stay within your gas budget.

<!-- .element: class="fragment" -->

- The later you manage to still paint a field the better you score.

<!-- .element: class="fragment" -->

- No overpainting! First player to paint a field owns it.

<!-- .element: class="fragment" -->

<aside class="notes"><p>This game was designed in a way where all of the best practices for smart contract development will make your player run better. We really tried to gamify some of the concepts that are really best practices of how you should develop a smart contract.<br><strong>click</strong> - first one is to use as little gas as possible to paint as many fields as possible. Gas consumption is a super big thing as user fees derived from that and the transaction throughput also relates to how big a contract is so the less complex your contract is the better it will do.<br><strong>click</strong> - There&#39;s a certain gas budget allocated per player and if you if you&#39;re above that then you just won&#39;t make a turn. So you have to stay in an optimal gas budget.<br><strong>click</strong> - the later in the in the game that you still manage to paint the field the better you score because what will happen is that there will be all kinds of fields painted and it will convert to a place where there&#39;s only a few left. so if you have a player that just randomly tries to paint things then at some at some point it just won&#39;t no longer work because it doesn&#39;t paint the unpainted fields. But in order to find those, you will have to have some more complex logic in your contract.<br><strong>click</strong> - and lastly, there&#39;s no overpainting. So the first player to paint a field owns it. So if you have a contract that just paints the same field over and over again, it will just not work. So you have to have some logic in there that checks whether a field is already painted or not.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Basic Player Contract

```rust [1-2,19|3-4|7-10|12-17|1-19]
#[ink::contract]
mod player {
    #[ink(storage)]
    pub struct Player {}

    impl Player {
        #[ink(constructor)]
        pub fn new() -> Self {
            Self {}
        }

        /// Called during every game round.
        /// Return `(x, y)` coordinate of pixel you want to color.
        #[ink(message, selector = 0)]
        pub fn your_turn(&self) -> Option<(u32, u32)> {
            Some(1, 2)
        }
    }
}
```

<aside class="notes"><p>So this is a very basic player contract.<br>We have a repository app set up with the template for this - I will share the link in a second. How it looks is - it&#39;s a contract that defines the player module,<br><strong>click</strong> - a super simple player doesn&#39;t have to contain any storage whatsoever.<br><strong>click</strong>- a super simple player also doesn&#39;t have to contain any Constructor arguments<br><strong>click</strong> - and it can just return a random constant value. So this is the most simple player ever.
What your player needs to do is to have one message, that has a defined selector, so you don&#39;t have to think more about this. It&#39;s just that it needs to have this function and this function is called by the game with every round. And whatever you return from this function. This is your your turn for the game.<br>So if in this case you return an option some(1,2), this would mean you paint the pixel at X1 Y2.<br>In that case, it would be a very boring play.<br>Who can tell me what would happen here?<br><em>(a player that only makes one turn - it always tries to paint the same field. And if someone else also chose the same magic numbers then it wouldn&#39;t even make a turn at all.)</em><br><strong>click</strong> - So there&#39;s a couple things of how you can improve on that and I will show some hints later, but for now what we&#39;re gonna do is look at the repository and see how we can get started with this.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## How to play

<img rounded src="../img/ink/github.png" />

<aside class="notes"><p>This is the Squink-Splash-beginner Repository - it contains a couple of things.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## How to play

<img rounded src="../img/ink/github1.png" />
<aside class="notes"><p>It contains the cargo.toml file and the lib.rs, which is the player that I just showed.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## How to play

<img rounded src="../img/ink/github2.png" />

<aside class="notes"><p>It contains the game metadata. You will need this in order to interact with the game itself, to register your player and so on. but yeah we will show that.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## How to play

<img rounded src="../img/ink/github3.png" />

<aside class="notes"><p>And it has 2 todo files. The first is some instructions on General setup and the second one is in order to build your player.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Now (1)

[github.com/paritytech/squink-splash-beginner âœ todo-1.md](https://github.com/paritytech/squink-splash-beginner/blob/main/todo-1.md)

<aside class="notes"><p>So, the first thing that we are going to do is that I would ask all of you to go to this link here and follow the instructions.<br>We will go around and help whoever has an issue. I think you might even have already used some of the requirements in there, so it may not be super complicated.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Now (2)

[github.com/paritytech/squink-splash-beginner âœ todo-2.md](https://github.com/paritytech/squink-splash-beginner/blob/main/todo-2.md)

<aside class="notes"><p>For this stage, you will need the address of the game. We&#39;ll post it in the chat.
This is a simple example - we&#39;re just giving you exposure to the flow of uploading your player contract.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## ğŸ•¹ï¸ğŸ® Let's play! ğŸ•¹ï¸ğŸ®

[https://splash.use.ink](https://splash.use.ink)

<aside class="notes"><p>The next slides go over strategy. (maybe wait to to go through until you&#39;ve played one game)</p>
</aside></script></section><section  data-markdown><script type="text/template">
## The Game Contract

> [`ink-workshop/game/lib.rs`](https://github.com/paritytech/ink-workshop/blob/main/game/lib.rs)

- `pub fn submit_turn(&mut self)`

<!-- .element: class="fragment" -->

- `pub fn board(&self) -> Vec<Option<FieldEntry>>`

<!-- .element: class="fragment" -->

- `pub fn gas_budget(&self) -> u64`

<!-- .element: class="fragment" -->

- `pub fn dimensions(&self) -> (u32, u32)`

<!-- .element: class="fragment" -->

<aside class="notes"><p>When you deployed it you already saw that there&#39;s different functions that you can call.<br>There are a lot of functions that are ineresting.<br><strong>click</strong> - the game runner calls this - if you&#39;re interested, you can take a look how it works and there might be some hints for for the game.<br><strong>click</strong> - then there&#39;s a function to to query the board in order to find out if certain fields are already occupied or if they are still free.<br><strong>click</strong> - there&#39;s a function for the gas budget so you can find out how much gas your player is allowed to use per one round. Because worst thing is if you are above this gas budget, then you just won&#39;t execute any turn during that round.
<strong>click</strong> - there&#39;s also function to query the game dimensions. same thing there, if you paint outside the bounds, then also you just missed one turn.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Things to consider ğŸ§ 

- Develop a strategy for your player.<br/><br/>
- Use as little gas as possible to paint as many fields as possible.
- Stay within your gas budget.
- The later you manage to still paint a field, the better you score.<br/><br/>
- No overpainting! First player to paint a field owns it.
- [paritytech/squink-splash-advanced](https://github.com/paritytech/squink-splash-advanced)
</script></section><section  data-markdown><script type="text/template">
## How to test locally?

[paritytech/squink-splash-advanced](https://github.com/paritytech/squink-splash-advanced)

<aside class="notes"><p>There&#39;s details in here. You could deploy locally to test things out. there&#39;s also commands you can use to deploy not using the UI.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Hint: Playfield Dimensions

- Paint within the bounds of the playfield!
- Otherwise you wasted a turn.
</script></section><section  data-markdown><script type="text/template">
## Ideas

- You can call your own contract as often as you want!

<!-- .element: class="fragment" -->

- Random number

<!-- .element: class="fragment" -->

- Query which fields are free
  - Query game state via cross-contract call
  - Off-chain computation

<!-- .element: class="fragment" -->

<aside class="notes"><p><strong>click</strong> Lastly, some ideas for for your agent in the game you can you yourself can call your contract. as often as you want and this won&#39;t contribute to the gas used during the game. You can during the game you could also call a set of function of your contract if you want to adapt something.<br><strong>click</strong> You could also Generate random numbers. There are a couple of libraries out there, if you want to go along those lines you have to pay attention that it&#39;s a no standard Library. typically a random number generator libraries they typically have a feature that you need to enable in order to make them no standard compatible
<strong>click</strong> A clever strategy would be a query which fields are free. that&#39;s a bit more complex with the with the code snippet that we have in this Advanced repository, this would give you a hint.</p>
</aside></script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background="../img/ink/Questions_2.svg"" -->
</script></section><section  data-markdown><script type="text/template">
# Day 2
</script></section><section  data-markdown><script type="text/template">
<img rounded style="width: 1400px; padding-top:15px;" src="../img/ink/advanced-workshop.jpg" />
</script></section><section  data-markdown><script type="text/template">
<pba-cols>
<pba-col center>

### Now

We help you debug!

</pba-col>
<pba-col center>

### Then

ğŸ•¹ï¸ğŸ®ğŸ•¹ï¸ğŸ®

</pba-col>
<pba-col center>

### Thereafter

Solutions Explainer

</pba-col>
</pba-cols>

<br/>

<blockquote style="text-align: left; font-size: 0.9em;">
Use as little gas as possible to paint as many fields as possible.<br/><br/>
Stay within your gas budget.<br/><br/>
The later you manage to still paint a field, the better you score.<br/><br/>
No overpainting! First player to paint a field owns it.<br/>
</blockquote>

<br/>
<br/>

[paritytech/squink-splash-advanced](https://github.com/paritytech/squink-splash-advanced)
</script></section><section  data-markdown><script type="text/template">
## Frontend

[https://splash.use.ink](https://splash.use.ink)
</script></section><section  data-markdown><script type="text/template">
## Questions

- What strategy did the winner choose?

<!-- .element: class="fragment" -->

- What strategies did the others choose?

<!-- .element: class="fragment" -->

- What do you think would be the perfect strategy?

<!-- .element: class="fragment" -->
</script></section><section  data-markdown><script type="text/template">
## Board Dimensions

- Worst ğŸ˜±
  - Cross-contract call to `game`<br/><br/>

```rust
#[ink(message)]
pub fn dimensions(&self) -> (u32, u32)
```

<br/><br/>

<!-- .element: class="fragment" -->

- Best ğŸ‘ï¸
  - `const width: u32`
  - `new(width: u32, height: u32)`

<!-- .element: class="fragment" -->
</script></section><section  data-markdown><script type="text/template">
## More Pitfalls

<img rounded style="margin-top: 25px; width: 400px;" src="../img/ink/oopsie.gif" />

- Forgetting `--release`

<!-- .element: class="fragment" -->

- Iterating over a datastructure in your contract

<!-- .element: class="fragment" -->
</script></section><section  data-markdown><script type="text/template">
## Avoid iteration

<pba-cols>
<pba-col center>

```
#[ink(message)]
fn pay_winner()
  let winner = self.players.find(â€¦);

  self.transfer(winner, â€¦);
}
```

</pba-col>
<!-- .element: class="fragment" -->
<pba-col center>

```rust
#[ink(message)]
fn pay_winner(
    winner: AccountId
) {
  assert!(is_winner(winner));

  self.transfer(winner, â€¦);
}
```

</pba-col>
<!-- .element: class="fragment" -->
</pba-cols></script></section><section  data-markdown><script type="text/template">
## Strategy 1<br/>Return Random Numbers

<img rounded style="margin-top: 25px; width: 500px;" src="../img/ink/0.png" />
</script></section><section  data-markdown><script type="text/template">
## Strategy 1<br/>Return Random Number

- Wasm-compatible RNG
<!-- .element: class="fragment" -->
- Use Storage to hold seed for random number
<!-- .element: class="fragment" -->
- ğŸ“ˆ Uses little Gas
<!-- .element: class="fragment" -->
- ğŸ“‰ Quickly runs into collisions
<!-- .element: class="fragment" -->
- ğŸ“‰ Score function rewards players that late in game still paint fields
<!-- .element: class="fragment" -->
</script></section><section  data-markdown><script type="text/template">
## Strategy 2<br/>Paint only free fields

<img rounded style="margin-top: 25px; width: 500px;" src="../img/ink/1.png" />
</script></section><section  data-markdown><script type="text/template">
## Strategy 2<br/>Paint only free fields

- Query board for free fields
- ğŸ“ˆ Succeeds late in game

<!-- .element: class="fragment" -->

- ğŸ“‰ Cross-contract call ğŸ’°ï¸
- ğŸ“‰ Need to iterate over `Mapping`: `O(n)`

<!-- .element: class="fragment" -->
</script></section><section  data-markdown><script type="text/template">
## Strategy 3<br/>Shift computation off-chain

<img rounded style="margin-top: 25px; width: 500px;" src="../img/ink/2.png" />
</script></section><section  data-markdown><script type="text/template">
## Strategy 3<br/>Shift computation off-chain

- Off-chain Script
  - Query board âœ Search free field<br/><br/>

<!-- .element: class="fragment" -->

- ```rust[1-2|1-7]
  #[ink(message)]
  fn set_next_turn(turn: â€¦) {}

  #[ink(message, selector = 0)]
  pub fn your_turn(&mut self) -> {
    self.next_turn
  }
  ```

<!-- .element: class="fragment"  -->
</script></section><section  data-markdown><script type="text/template">
## Strategy 4<br/>Exploit player sorting in game loop

<img rounded style="margin-top: 25px; width: 500px;" src="../img/ink/3.png" />
</script></section><section  data-markdown><script type="text/template">
## Strategy 4<br/>Exploit player sorting in game loop

- On top of Strategy 3 (off-chain computation).
<!-- .element: class="fragment"  -->

- Game loop calls players in same order each time.
<!-- .element: class="fragment"  -->

```rust
#[ink(message)]
fn submit_turn(&mut self) {
    // -- snip --

    for (idx, player) in players.iter_mut().enumerate() {
        â€¦
    }

  // -- snip --
}
```

<!-- .element: class="fragment"  -->
</script></section><section  data-markdown><script type="text/template">
## Strategy 4<br/>Exploit player sorting in game loop

```rust
impl<T: Config> AddressGenerator<T> for DefaultAddressGenerator {
	fn generate_address(
		deploying_address: &T::AccountId,
		code_hash: &CodeHash<T>,
		input_data: &[u8],
		salt: &[u8],
	) -> T::AccountId {

    // -- snip --

	}
}
```

âœ All inputs are known

<!-- .element: class="fragment"  -->

âœ Generate low `T::AccountId` with known inputs

<!-- .element: class="fragment"  -->
</script></section><section  data-markdown><script type="text/template">
## Strategy 5<br/>Checking these slides already yesterday

<img rounded style="margin-top: 25px; width: 500px;" src="../img/ink/4.png" />
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background="../img/ink/Questions_2.svg"" -->
</script></section>
    </article>
  </main>

  <script src="./../../../dist/reveal.js"></script>

  <script src="./../../../plugin/markdown/markdown.js"></script>
  <script src="./../../../plugin/highlight/highlight.js"></script>
  <script src="./../../../plugin/zoom/zoom.js"></script>
  <script src="./../../../plugin/notes/notes.js"></script>
  <script src="./../../../plugin/math/math.js"></script>

  <script src="./../../../assets/plugin/mermaid.js"></script>
  <script src="./../../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../../assets/plugin/chart/chart.js"></script>
  <script src="./../../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>